// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Infrastructure
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Abstractions, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IDbContextLogger, IDiagnosticsLogger_1, IInterceptor, ISingletonInterceptor, WarningsConfiguration } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import type { IDbContextPool_1 } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Metadata_Builders_Internal from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { IConventionAnnotatableBuilder, IConventionModelBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { ConventionAnnotation, IMemberClassifier } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Metadata_Internal from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { ConfigurationSource, IClrPropertySetter, IConstructorBindingFactory, IConventionAnnotatable, IConventionAnnotation, IModel, IMutableAnnotatable, IParameterBindingFactories, IProperty, IPropertyBase, IReadOnlyProperty, IRelationalAnnotationProvider, MemberIdentity, StoreObjectIdentifier } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IValueConverterSelector } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Storage_Internal from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { ExecutionStrategyDependencies, IDatabaseFacadeDependencies, IDatabaseFacadeDependenciesAccessor, IDbContextTransaction, IExecutionStrategy, IRelationalTypeMappingSource, ITypeMappingSource } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { IRowForeignKeyValueFactoryFactory, IRowIndexValueFactoryFactory, IRowKeyValueFactoryFactory } from "../../Microsoft.EntityFrameworkCore.Update.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Internal from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { AutoTransactionBehavior, DbContext, DbContextOptions_1, DbContextOptionsBuilder, DbLoggerCategory_Model, DbLoggerCategory_Model_Validation, IDbContextFactory_1, ModelBuilder, ModelCreationDependencies, ParameterTranslationMode, QuerySplittingBehavior, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IDictionary, IEnumerable, IReadOnlyDictionary, IReadOnlyList, ISet } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbConnection } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Diagnostics_Tracing_Internal from "@tsonic/dotnet/System.Diagnostics.Tracing.js";
import type { EventSource } from "@tsonic/dotnet/System.Diagnostics.Tracing.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Attribute, Boolean as ClrBoolean, Char, Enum, FormattableString, Func, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, IServiceProvider, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression, MemberExpression, MethodCallExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { Assembly, MemberInfo, MethodInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { IMemoryCache } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Caching.Memory.js";
import type { IServiceCollection, ServiceLifetime } from "@tsonic/microsoft-extensions/Microsoft.Extensions.DependencyInjection.js";
import type { ILoggerFactory } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Logging.js";

export enum MetadataDebugStringOptions {
    includeAnnotations = 1,
    includePropertyIndexes = 2,
    singleLine = 4,
    shortDefault = 0,
    longDefault = 1,
    singleLineDefault = 4
}


export interface IAnnotatable$instance extends IReadOnlyAnnotatable {
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export interface IAnnotatable$instance extends IReadOnlyAnnotatable$instance {}

export type IAnnotatable = IAnnotatable$instance;

export interface IAnnotation$instance {
    readonly name: string;
    readonly value: unknown | undefined;
}


export type IAnnotation = IAnnotation$instance;

export interface IConcurrencyDetector$instance {
    enterCriticalSection(): ConcurrencyDetectorCriticalSectionDisposer;
    exitCriticalSection(): void;
}


export type IConcurrencyDetector = IConcurrencyDetector$instance;

export interface ICoreSingletonOptions$instance extends ISingletonOptions {
    readonly areDetailedErrorsEnabled: boolean;
    readonly areThreadSafetyChecksEnabled: boolean;
    readonly rootApplicationServiceProvider: IServiceProvider | undefined;
    initialize(options: IDbContextOptions): void;
}


export interface ICoreSingletonOptions$instance extends ISingletonOptions$instance {}

export type ICoreSingletonOptions = ICoreSingletonOptions$instance;

export interface ICurrentDbContext$instance {
    readonly context: DbContext;
}


export type ICurrentDbContext = ICurrentDbContext$instance;

export interface IDbContextOptions$instance {
    readonly extensions: IEnumerable<IDbContextOptionsExtension>;
    findExtension<TExtension extends IDbContextOptionsExtension>(): TExtension | undefined;
}


export type IDbContextOptions = IDbContextOptions$instance;

export interface IDbContextOptionsBuilderInfrastructure$instance {
    addOrUpdateExtension<TExtension extends IDbContextOptionsExtension>(extension: TExtension): void;
}


export type IDbContextOptionsBuilderInfrastructure = IDbContextOptionsBuilderInfrastructure$instance;

export interface IDbContextOptionsConfiguration_1$instance<TContext extends DbContext> {
    configure(serviceProvider: IServiceProvider, optionsBuilder: DbContextOptionsBuilder): void;
}


export type IDbContextOptionsConfiguration_1<TContext extends DbContext> = IDbContextOptionsConfiguration_1$instance<TContext>;

export interface IDbContextOptionsExtension$instance {
    readonly info: DbContextOptionsExtensionInfo;
    applyDefaults(options: IDbContextOptions): IDbContextOptionsExtension;
    applyServices(services: IServiceCollection): void;
    validate(options: IDbContextOptions): void;
}


export type IDbContextOptionsExtension = IDbContextOptionsExtension$instance;

export interface IDbSetFinder$instance {
    findSets(contextType: Type): IReadOnlyList<DbSetProperty>;
}


export type IDbSetFinder = IDbSetFinder$instance;

export interface IInfrastructure_1$instance<T> {
    readonly instance: T;
}


export type IInfrastructure_1<T> = IInfrastructure_1$instance<T>;

export interface IInternalServiceCollectionMap$instance {
    addDependencySingleton<TDependencies>(): IInternalServiceCollectionMap;
}


export type IInternalServiceCollectionMap = IInternalServiceCollectionMap$instance;

export interface ILazyLoader$instance {
    dispose(): void;
    isLoaded(entity: unknown, navigationName?: string): boolean;
    load(entity: unknown, navigationName?: string): void;
    loadAsync(entity: unknown, cancellationToken?: CancellationToken, navigationName?: string): Task;
    setLoaded(entity: unknown, navigationName?: string, loaded?: boolean): void;
}


export type ILazyLoader = ILazyLoader$instance;

export interface IModelCacheKeyFactory$instance {
    create(context: DbContext, designTime: boolean): unknown;
}


export type IModelCacheKeyFactory = IModelCacheKeyFactory$instance;

export interface IModelCustomizer$instance {
    customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export type IModelCustomizer = IModelCustomizer$instance;

export interface IModelRuntimeInitializer$instance {
    initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
}


export type IModelRuntimeInitializer = IModelRuntimeInitializer$instance;

export interface IModelSource$instance {
    getModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
}


export type IModelSource = IModelSource$instance;

export interface IModelValidator$instance {
    validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export type IModelValidator = IModelValidator$instance;

export interface IReadOnlyAnnotatable$instance {
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IReadOnlyAnnotatable = IReadOnlyAnnotatable$instance;

export interface IRelationalDbContextOptionsBuilderInfrastructure$instance {
    readonly optionsBuilder: DbContextOptionsBuilder;
}


export type IRelationalDbContextOptionsBuilderInfrastructure = IRelationalDbContextOptionsBuilderInfrastructure$instance;

export interface IResettableService$instance {
    resetState(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
}


export type IResettableService = IResettableService$instance;

export interface ISingletonOptions$instance {
    initialize(options: IDbContextOptions): void;
}


export type ISingletonOptions = ISingletonOptions$instance;

export interface ConcurrencyDetectorCriticalSectionDisposer$instance {
    dispose(): void;
}


export const ConcurrencyDetectorCriticalSectionDisposer: {
    new(concurrencyDetector: IConcurrencyDetector): ConcurrencyDetectorCriticalSectionDisposer;
};


export type ConcurrencyDetectorCriticalSectionDisposer = ConcurrencyDetectorCriticalSectionDisposer$instance;

export interface DbSetProperty$instance {
    readonly name: string;
    readonly setter: IClrPropertySetter | undefined;
    readonly type_: Type;
}


export const DbSetProperty: {
    new(name: string, type_: Type, setter: IClrPropertySetter): DbSetProperty;
};


export type DbSetProperty = DbSetProperty$instance;

export interface ServiceCharacteristics$instance {
    readonly lifetime: ServiceLifetime;
    readonly multipleRegistrations: boolean;
}


export const ServiceCharacteristics: {
    new(lifetime: ServiceLifetime, multipleRegistrations: boolean): ServiceCharacteristics;
};


export type ServiceCharacteristics = ServiceCharacteristics$instance;

export interface Annotatable$instance extends AnnotatableBase$instance {
    addAnnotation(name: string, value: unknown): Annotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    removeAnnotation(name: string): Annotation | undefined;
    setAnnotation(name: string, value: unknown): void;
}


export const Annotatable: {
    new(): Annotatable;
};


export interface __Annotatable$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
    As_IMutableAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IMutableAnnotatable$instance;
}

export type Annotatable = Annotatable$instance & __Annotatable$views;


export interface AnnotatableBase$instance {
    readonly isReadOnly: boolean;
    get item(): unknown | undefined;
    set item(value: unknown);
    addAnnotation(name: string, value: unknown): Annotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotations(annotations: IEnumerable<Annotation>): void;
    addRuntimeAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    getAnnotation(annotationName: string): Annotation;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    removeAnnotation(name: string): Annotation | undefined;
    removeRuntimeAnnotation(name: string): Annotation | undefined;
    setAnnotation(name: string, value: unknown): void;
    setRuntimeAnnotation(name: string, value: unknown): Annotation;
}


export const AnnotatableBase: {
    new(): AnnotatableBase;
};


export interface __AnnotatableBase$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
}

export type AnnotatableBase = AnnotatableBase$instance & __AnnotatableBase$views;


export interface AnnotatableBuilder_2$instance<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> {
    readonly metadata: ComplexType | TMetadata;
    readonly modelBuilder: InternalModelBuilder | TModelBuilder;
    canRemoveAnnotation(name: string, configurationSource: ConfigurationSource): boolean;
    canSetAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): boolean;
    hasAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    hasNoAnnotation(name: string, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    hasNonNullAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    mergeAnnotationsFrom(annotatable: TMetadata): AnnotatableBuilder_2<TMetadata, TModelBuilder>;
    mergeAnnotationsFrom(annotatable: TMetadata, minimalConfigurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder>;
    removeAnnotation(name: string, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
}


export const AnnotatableBuilder_2: {
};


export interface __AnnotatableBuilder_2$views<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> {
    As_IConventionAnnotatableBuilder(): Microsoft_EntityFrameworkCore_Metadata_Builders_Internal.IConventionAnnotatableBuilder$instance;
}

export type AnnotatableBuilder_2<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> = AnnotatableBuilder_2$instance<TMetadata, TModelBuilder> & __AnnotatableBuilder_2$views<TMetadata, TModelBuilder>;


export interface Annotation$instance {
    readonly name: string;
    readonly value: unknown | undefined;
}


export const Annotation: {
    new(name: string, value: unknown): Annotation;
};


export interface __Annotation$views {
    As_IAnnotation(): IAnnotation$instance;
}

export interface Annotation$instance extends IAnnotation$instance {}

export type Annotation = Annotation$instance & __Annotation$views;


export interface ConventionAnnotatable$instance extends Annotatable$instance {
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotation(name: string, value: unknown): Annotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    removeAnnotation(name: string): IAnnotation | undefined;
    removeAnnotation(name: string): Annotation | undefined;
    setAnnotation(name: string, value: unknown): void;
    setOrRemoveAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): ConventionAnnotation | undefined;
}


export const ConventionAnnotatable: {
};


export interface __ConventionAnnotatable$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
    As_IConventionAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IConventionAnnotatable$instance;
    As_IMutableAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IMutableAnnotatable$instance;
}

export type ConventionAnnotatable = ConventionAnnotatable$instance & __ConventionAnnotatable$views;


export interface CoreOptionsExtension$instance {
    readonly applicationServiceProvider: IServiceProvider | undefined;
    readonly asyncSeeder: Func<DbContext, System_Internal.Boolean, CancellationToken, Task> | undefined;
    readonly autoResolveRootProvider: boolean;
    readonly dbContextLogger: IDbContextLogger;
    readonly detailedErrorsEnabled: boolean;
    readonly info: DbContextOptionsExtensionInfo;
    readonly interceptors: IEnumerable<IInterceptor>;
    readonly internalServiceProvider: IServiceProvider;
    readonly isSensitiveDataLoggingEnabled: boolean;
    readonly loggerFactory: ILoggerFactory | undefined;
    readonly loggingCacheTime: TimeSpan;
    readonly maxPoolSize: Nullable<System_Internal.Int32>;
    readonly memoryCache: IMemoryCache;
    readonly model: IModel;
    readonly queryTrackingBehavior: QueryTrackingBehavior;
    readonly replacedServices: IReadOnlyDictionary<ValueTuple<Type, Type>, Type | undefined> | undefined;
    readonly rootApplicationServiceProvider: IServiceProvider | undefined;
    readonly seeder: Action<DbContext, System_Internal.Boolean> | undefined;
    readonly serviceProviderCachingEnabled: boolean;
    readonly singletonInterceptors: IEnumerable<ISingletonInterceptor>;
    readonly threadSafetyChecksEnabled: boolean;
    readonly warningsConfiguration: WarningsConfiguration;
    applyServices(services: IServiceCollection): void;
    validate(options: IDbContextOptions): void;
    withApplicationServiceProvider(applicationServiceProvider: IServiceProvider): CoreOptionsExtension;
    withAsyncSeeding(seedAsync: Func<DbContext, System_Internal.Boolean, CancellationToken, Task>): CoreOptionsExtension;
    withDbContextLogger(contextLogger: IDbContextLogger): CoreOptionsExtension;
    withDetailedErrorsEnabled(detailedErrorsEnabled: boolean): CoreOptionsExtension;
    withInterceptors(interceptors: IEnumerable<IInterceptor>): CoreOptionsExtension;
    withInternalServiceProvider(internalServiceProvider: IServiceProvider): CoreOptionsExtension;
    withLoggerFactory(loggerFactory: ILoggerFactory): CoreOptionsExtension;
    withLoggingCacheTime(timeSpan: TimeSpan): CoreOptionsExtension;
    withMaxPoolSize(maxPoolSize: Nullable<System_Internal.Int32>): CoreOptionsExtension;
    withMemoryCache(memoryCache: IMemoryCache): CoreOptionsExtension;
    withModel(model: IModel): CoreOptionsExtension;
    withQueryTrackingBehavior(queryTrackingBehavior: QueryTrackingBehavior): CoreOptionsExtension;
    withReplacedService(serviceType: Type, newImplementationType: Type, currentImplementationType?: Type): CoreOptionsExtension;
    withRootApplicationServiceProvider(rootApplicationServiceProvider: IServiceProvider): CoreOptionsExtension;
    withRootApplicationServiceProvider(autoResolve?: boolean): CoreOptionsExtension;
    withSeeding(seed: Action<DbContext, System_Internal.Boolean>): CoreOptionsExtension;
    withSensitiveDataLoggingEnabled(sensitiveDataLoggingEnabled: boolean): CoreOptionsExtension;
    withServiceProviderCachingEnabled(serviceProviderCachingEnabled: boolean): CoreOptionsExtension;
    withSingletonInterceptors(interceptors: IEnumerable<ISingletonInterceptor>): CoreOptionsExtension;
    withThreadSafetyChecksEnabled(checksEnabled: boolean): CoreOptionsExtension;
    withWarningsConfiguration(warningsConfiguration: WarningsConfiguration): CoreOptionsExtension;
}


export const CoreOptionsExtension: {
    new(): CoreOptionsExtension;
};


export interface __CoreOptionsExtension$views {
    As_IDbContextOptionsExtension(): IDbContextOptionsExtension$instance;
}

export interface CoreOptionsExtension$instance extends IDbContextOptionsExtension$instance {}

export type CoreOptionsExtension = CoreOptionsExtension$instance & __CoreOptionsExtension$views;


export interface DatabaseFacade$instance {
    autoSavepointsEnabled: boolean;
    autoTransactionBehavior: AutoTransactionBehavior;
    autoTransactionsEnabled: boolean;
    readonly currentTransaction: IDbContextTransaction | undefined;
    readonly providerName: string | undefined;
    beginTransaction(): IDbContextTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    canConnect(): boolean;
    canConnectAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    commitTransaction(): void;
    commitTransactionAsync(cancellationToken?: CancellationToken): Task;
    createExecutionStrategy(): IExecutionStrategy;
    ensureCreated(): boolean;
    ensureCreatedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    ensureDeleted(): boolean;
    ensureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    rollbackTransaction(): void;
    rollbackTransactionAsync(cancellationToken?: CancellationToken): Task;
    toString(): string | undefined;
}


export const DatabaseFacade: {
    new(context: DbContext): DatabaseFacade;
};


export interface __DatabaseFacade$views {
    As_IInfrastructure_1(): IInfrastructure_1$instance<IServiceProvider>;
    As_IResettableService(): IResettableService$instance;
    As_IDatabaseFacadeDependenciesAccessor(): Microsoft_EntityFrameworkCore_Storage_Internal.IDatabaseFacadeDependenciesAccessor$instance;
}

export interface DatabaseFacade$instance extends IInfrastructure_1$instance<IServiceProvider>, IResettableService$instance, Microsoft_EntityFrameworkCore_Storage_Internal.IDatabaseFacadeDependenciesAccessor$instance {}

export type DatabaseFacade = DatabaseFacade$instance & __DatabaseFacade$views;


export interface DbContextAttribute$instance extends Attribute {
    readonly contextType: Type;
}


export const DbContextAttribute: {
    new(contextType: Type): DbContextAttribute;
};


export type DbContextAttribute = DbContextAttribute$instance;

export interface DbContextModelAttribute$instance extends Attribute {
    readonly contextType: Type;
    readonly modelType: Type;
}


export const DbContextModelAttribute: {
    new(contextType: Type, modelType: Type): DbContextModelAttribute;
};


export type DbContextModelAttribute = DbContextModelAttribute$instance;

export interface DbContextOptionsExtensionInfo$instance {
    readonly extension: IDbContextOptionsExtension;
    readonly isDatabaseProvider: boolean;
    readonly logFragment: string;
    getServiceProviderHashCode(): int;
    populateDebugInfo(debugInfo: IDictionary<System_Internal.String, System_Internal.String>): void;
    shouldUseSameServiceProvider(other: DbContextOptionsExtensionInfo): boolean;
}


export const DbContextOptionsExtensionInfo: {
};


export type DbContextOptionsExtensionInfo = DbContextOptionsExtensionInfo$instance;

export interface DebugView$instance {
    readonly longView: string;
    readonly shortView: string;
}


export const DebugView: {
    new(toShortDebugString: Func<System_Internal.String>, toLongDebugString: Func<System_Internal.String>): DebugView;
};


export type DebugView = DebugView$instance;

export interface EntityFrameworkEventSource$instance extends EventSource {
    compiledQueryCacheHit(): void;
    compiledQueryCacheMiss(): void;
    dbContextDisposing(): void;
    dbContextInitializing(): void;
    executionStrategyOperationFailure(): void;
    optimisticConcurrencyFailure(): void;
    queryExecuting(): void;
    savingChanges(): void;
}


export const EntityFrameworkEventSource: {
    new(): EntityFrameworkEventSource;
    readonly log: EntityFrameworkEventSource;
};


export type EntityFrameworkEventSource = EntityFrameworkEventSource$instance;

export interface EntityFrameworkInternalAttribute$instance extends Attribute {
}


export const EntityFrameworkInternalAttribute: {
    new(): EntityFrameworkInternalAttribute;
};


export type EntityFrameworkInternalAttribute = EntityFrameworkInternalAttribute$instance;

export interface EntityFrameworkRelationalServicesBuilder$instance extends EntityFrameworkServicesBuilder {
    tryAddCoreServices(): EntityFrameworkServicesBuilder;
}


export const EntityFrameworkRelationalServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkRelationalServicesBuilder;
    readonly relationalServices: IDictionary<Type, ServiceCharacteristics>;
};


export type EntityFrameworkRelationalServicesBuilder = EntityFrameworkRelationalServicesBuilder$instance;

export interface EntityFrameworkServicesBuilder$instance {
    tryAdd<TService, TImplementation extends TService>(): EntityFrameworkServicesBuilder;
    tryAdd(serviceType: Type, implementationType: Type): EntityFrameworkServicesBuilder;
    tryAdd<TService>(factory: Func<IServiceProvider, TService>): EntityFrameworkServicesBuilder;
    tryAdd(serviceType: Type, implementationType: Type, factory: Func<IServiceProvider, unknown>): EntityFrameworkServicesBuilder;
    tryAdd<TService>(implementation: TService): EntityFrameworkServicesBuilder;
    tryAdd(serviceType: Type, implementation: unknown): EntityFrameworkServicesBuilder;
    tryAddCoreServices(): EntityFrameworkServicesBuilder;
    tryAddProviderSpecificServices(serviceMap: Action<ServiceCollectionMap>): EntityFrameworkServicesBuilder;
}


export const EntityFrameworkServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkServicesBuilder;
    readonly coreServices: IDictionary<Type, ServiceCharacteristics>;
};


export type EntityFrameworkServicesBuilder = EntityFrameworkServicesBuilder$instance;

export interface IndentedStringBuilder$instance {
    readonly indentCount: int;
    readonly length: int;
    append(value: string): IndentedStringBuilder;
    append(value: FormattableString): IndentedStringBuilder;
    append(value: char): IndentedStringBuilder;
    append(value: IEnumerable<System_Internal.String>): IndentedStringBuilder;
    append(value: IEnumerable<System_Internal.Char>): IndentedStringBuilder;
    appendJoin(values: IEnumerable<System_Internal.String>, separator?: string): IndentedStringBuilder;
    appendJoin(separator: string, ...values: string[]): IndentedStringBuilder;
    appendLine(): IndentedStringBuilder;
    appendLine(value: string): IndentedStringBuilder;
    appendLine(value: FormattableString): IndentedStringBuilder;
    appendLines(value: string, skipFinalNewline?: boolean): IndentedStringBuilder;
    clear(): IndentedStringBuilder;
    clone(): IndentedStringBuilder;
    decrementIndent(): IndentedStringBuilder;
    incrementIndent(): IndentedStringBuilder;
    indent(): IDisposable;
    suspendIndent(): IDisposable;
    toString(): string;
}


export const IndentedStringBuilder: {
    new(): IndentedStringBuilder;
};


export type IndentedStringBuilder = IndentedStringBuilder$instance;

export interface ModelCacheKey$instance {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ModelCacheKey: {
    new(context: DbContext): ModelCacheKey;
    new(context: DbContext, designTime: boolean): ModelCacheKey;
};


export type ModelCacheKey = ModelCacheKey$instance;

export interface ModelCacheKeyFactory$instance {
    create(context: DbContext): unknown;
    create(context: DbContext, designTime: boolean): unknown;
}


export const ModelCacheKeyFactory: {
    new(dependencies: ModelCacheKeyFactoryDependencies): ModelCacheKeyFactory;
};


export interface __ModelCacheKeyFactory$views {
    As_IModelCacheKeyFactory(): IModelCacheKeyFactory$instance;
}

export type ModelCacheKeyFactory = ModelCacheKeyFactory$instance & __ModelCacheKeyFactory$views;


export interface ModelCacheKeyFactoryDependencies$instance {
    _Clone_$(): ModelCacheKeyFactoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelCacheKeyFactoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelCacheKeyFactoryDependencies: {
    new(): ModelCacheKeyFactoryDependencies;
};


export type ModelCacheKeyFactoryDependencies = ModelCacheKeyFactoryDependencies$instance;

export interface ModelCustomizer$instance {
    customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export const ModelCustomizer: {
    new(dependencies: ModelCustomizerDependencies): ModelCustomizer;
};


export interface __ModelCustomizer$views {
    As_IModelCustomizer(): IModelCustomizer$instance;
}

export interface ModelCustomizer$instance extends IModelCustomizer$instance {}

export type ModelCustomizer = ModelCustomizer$instance & __ModelCustomizer$views;


export interface ModelCustomizerDependencies$instance {
    _Clone_$(): ModelCustomizerDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelCustomizerDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelCustomizerDependencies: {
    new(): ModelCustomizerDependencies;
};


export type ModelCustomizerDependencies = ModelCustomizerDependencies$instance;

export interface ModelDependencies$instance {
    logger: IDiagnosticsLogger_1<DbLoggerCategory_Model>;
    _Clone_$(): ModelDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelDependencies: {
    new(logger: IDiagnosticsLogger_1<DbLoggerCategory_Model>): ModelDependencies;
};


export type ModelDependencies = ModelDependencies$instance;

export interface ModelRuntimeInitializer$instance {
    initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
}


export const ModelRuntimeInitializer: {
    new(dependencies: ModelRuntimeInitializerDependencies): ModelRuntimeInitializer;
};


export type ModelRuntimeInitializer = ModelRuntimeInitializer$instance;

export interface ModelRuntimeInitializerDependencies$instance {
    modelDependencies: RuntimeModelDependencies;
    modelValidator: IModelValidator;
    _Clone_$(): ModelRuntimeInitializerDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelRuntimeInitializerDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelRuntimeInitializerDependencies: {
    new(runtimeModelDependencies: RuntimeModelDependencies, modelValidator: IModelValidator): ModelRuntimeInitializerDependencies;
};


export type ModelRuntimeInitializerDependencies = ModelRuntimeInitializerDependencies$instance;

export interface ModelSnapshot$instance {
    readonly model: IModel;
}


export const ModelSnapshot: {
};


export type ModelSnapshot = ModelSnapshot$instance;

export interface ModelSource$instance {
    createModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
    getModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
}


export const ModelSource: {
    new(dependencies: ModelSourceDependencies): ModelSource;
};


export interface __ModelSource$views {
    As_IModelSource(): IModelSource$instance;
}

export interface ModelSource$instance extends IModelSource$instance {}

export type ModelSource = ModelSource$instance & __ModelSource$views;


export interface ModelSourceDependencies$instance {
    memoryCache: IMemoryCache;
    modelCacheKeyFactory: IModelCacheKeyFactory;
    modelCustomizer: IModelCustomizer;
    _Clone_$(): ModelSourceDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelSourceDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelSourceDependencies: {
    new(modelCustomizer: IModelCustomizer, modelCacheKeyFactory: IModelCacheKeyFactory, memoryCache: IMemoryCache): ModelSourceDependencies;
};


export type ModelSourceDependencies = ModelSourceDependencies$instance;

export interface ModelValidator$instance {
    validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export const ModelValidator: {
    new(dependencies: ModelValidatorDependencies): ModelValidator;
};


export interface __ModelValidator$views {
    As_IModelValidator(): IModelValidator$instance;
}

export interface ModelValidator$instance extends IModelValidator$instance {}

export type ModelValidator = ModelValidator$instance & __ModelValidator$views;


export interface ModelValidatorDependencies$instance {
    memberClassifier: IMemberClassifier;
    _Clone_$(): ModelValidatorDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModelValidatorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModelValidatorDependencies: {
    new(memberClassifier: IMemberClassifier): ModelValidatorDependencies;
};


export type ModelValidatorDependencies = ModelValidatorDependencies$instance;

export interface PooledDbContextFactory_1$instance<TContext extends DbContext> {
    createDbContext(): TContext;
    createDbContextAsync(cancellationToken?: CancellationToken): Task<TContext>;
}


export const PooledDbContextFactory_1: {
    new<TContext extends DbContext>(pool: IDbContextPool_1<TContext>): PooledDbContextFactory_1<TContext>;
    new<TContext extends DbContext>(options: DbContextOptions_1<TContext>, poolSize: int): PooledDbContextFactory_1<TContext>;
};


export interface __PooledDbContextFactory_1$views<TContext extends DbContext> {
    As_IDbContextFactory_1(): Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext>;
}

export interface PooledDbContextFactory_1$instance<TContext extends DbContext> extends Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext> {}

export type PooledDbContextFactory_1<TContext extends DbContext> = PooledDbContextFactory_1$instance<TContext> & __PooledDbContextFactory_1$views<TContext>;


export interface RelationalDbContextOptionsBuilder_2$instance<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> {
    commandTimeout(commandTimeout: Nullable<System_Internal.Int32>): TBuilder;
    equals(obj: unknown): boolean;
    executionStrategy(getExecutionStrategy: Func<ExecutionStrategyDependencies, IExecutionStrategy>): TBuilder;
    getHashCode(): int;
    maxBatchSize(maxBatchSize: int): TBuilder;
    migrationsAssembly(assemblyName: string): TBuilder;
    migrationsAssembly(assembly: Assembly): TBuilder;
    migrationsHistoryTable(tableName: string, schema?: string): TBuilder;
    minBatchSize(minBatchSize: int): TBuilder;
    toString(): string | undefined;
    translateParameterizedCollectionsToConstants(): TBuilder;
    translateParameterizedCollectionsToParameters(): TBuilder;
    useParameterizedCollectionMode(parameterizedCollectionMode: ParameterTranslationMode): TBuilder;
    useQuerySplittingBehavior(querySplittingBehavior: QuerySplittingBehavior): TBuilder;
    useRelationalNulls(useRelationalNulls?: boolean): TBuilder;
}


export const RelationalDbContextOptionsBuilder_2: {
};


export interface __RelationalDbContextOptionsBuilder_2$views<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> {
    As_IRelationalDbContextOptionsBuilderInfrastructure(): IRelationalDbContextOptionsBuilderInfrastructure$instance;
}

export interface RelationalDbContextOptionsBuilder_2$instance<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> extends IRelationalDbContextOptionsBuilderInfrastructure$instance {}

export type RelationalDbContextOptionsBuilder_2<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> = RelationalDbContextOptionsBuilder_2$instance<TBuilder, TExtension> & __RelationalDbContextOptionsBuilder_2$views<TBuilder, TExtension>;


export interface RelationalModelCustomizer$instance extends ModelCustomizer$instance {
    customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export const RelationalModelCustomizer: {
    new(dependencies: ModelCustomizerDependencies): RelationalModelCustomizer;
};


export interface __RelationalModelCustomizer$views {
    As_IModelCustomizer(): IModelCustomizer$instance;
}

export type RelationalModelCustomizer = RelationalModelCustomizer$instance & __RelationalModelCustomizer$views;


export interface RelationalModelDependencies$instance {
    rowForeignKeyValueFactoryFactory: IRowForeignKeyValueFactoryFactory;
    rowIndexValueFactoryFactory: IRowIndexValueFactoryFactory;
    rowKeyValueFactoryFactory: IRowKeyValueFactoryFactory;
    valueConverterSelector: IValueConverterSelector;
    _Clone_$(): RelationalModelDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalModelDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalModelDependencies: {
    new(rowKeyValueFactoryFactory: IRowKeyValueFactoryFactory, foreignKeyRowValueFactorySource: IRowForeignKeyValueFactoryFactory, rowIndexValueFactoryFactory: IRowIndexValueFactoryFactory, valueConverterSelector: IValueConverterSelector): RelationalModelDependencies;
};


export type RelationalModelDependencies = RelationalModelDependencies$instance;

export interface RelationalModelRuntimeInitializer$instance extends ModelRuntimeInitializer {
    initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
}


export const RelationalModelRuntimeInitializer: {
    new(dependencies: ModelRuntimeInitializerDependencies, relationalDependencies: RelationalModelRuntimeInitializerDependencies): RelationalModelRuntimeInitializer;
};


export interface __RelationalModelRuntimeInitializer$views {
    As_IModelRuntimeInitializer(): IModelRuntimeInitializer$instance;
}

export type RelationalModelRuntimeInitializer = RelationalModelRuntimeInitializer$instance & __RelationalModelRuntimeInitializer$views;


export interface RelationalModelRuntimeInitializerDependencies$instance {
    relationalAnnotationProvider: IRelationalAnnotationProvider;
    relationalModelDependencies: RelationalModelDependencies;
    _Clone_$(): RelationalModelRuntimeInitializerDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalModelRuntimeInitializerDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalModelRuntimeInitializerDependencies: {
    new(relationalModelDependencies: RelationalModelDependencies, relationalAnnotationProvider: IRelationalAnnotationProvider): RelationalModelRuntimeInitializerDependencies;
};


export type RelationalModelRuntimeInitializerDependencies = RelationalModelRuntimeInitializerDependencies$instance;

export interface RelationalModelValidator$instance extends ModelValidator$instance {
    validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export const RelationalModelValidator: {
    new(dependencies: ModelValidatorDependencies, relationalDependencies: RelationalModelValidatorDependencies): RelationalModelValidator;
};


export interface __RelationalModelValidator$views {
    As_IModelValidator(): IModelValidator$instance;
}

export type RelationalModelValidator = RelationalModelValidator$instance & __RelationalModelValidator$views;


export interface RelationalModelValidatorDependencies$instance {
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalModelValidatorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalModelValidatorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalModelValidatorDependencies: {
    new(typeMappingSource: IRelationalTypeMappingSource): RelationalModelValidatorDependencies;
};


export type RelationalModelValidatorDependencies = RelationalModelValidatorDependencies$instance;

export interface RelationalOptionsExtension$instance {
    readonly commandTimeout: Nullable<System_Internal.Int32>;
    readonly connection: DbConnection;
    readonly connectionString: string | undefined;
    readonly executionStrategyFactory: Func<ExecutionStrategyDependencies, IExecutionStrategy>;
    readonly info: DbContextOptionsExtensionInfo;
    readonly isConnectionOwned: boolean;
    readonly maxBatchSize: Nullable<System_Internal.Int32>;
    readonly migrationsAssembly: string;
    readonly migrationsAssemblyObject: Assembly | undefined;
    readonly migrationsHistoryTableName: string | undefined;
    readonly migrationsHistoryTableSchema: string | undefined;
    readonly minBatchSize: Nullable<System_Internal.Int32>;
    readonly parameterizedCollectionMode: ParameterTranslationMode;
    readonly querySplittingBehavior: Nullable<QuerySplittingBehavior>;
    readonly useRelationalNulls: boolean;
    applyServices(services: IServiceCollection): void;
    validate(options: IDbContextOptions): void;
    withCommandTimeout(commandTimeout: Nullable<System_Internal.Int32>): RelationalOptionsExtension;
    withConnection(connection: DbConnection): RelationalOptionsExtension;
    withConnection(connection: DbConnection, owned: boolean): RelationalOptionsExtension;
    withConnectionString(connectionString: string): RelationalOptionsExtension;
    withExecutionStrategyFactory(executionStrategyFactory: Func<ExecutionStrategyDependencies, IExecutionStrategy>): RelationalOptionsExtension;
    withMaxBatchSize(maxBatchSize: Nullable<System_Internal.Int32>): RelationalOptionsExtension;
    withMigrationsAssembly(migrationsAssembly: string): RelationalOptionsExtension;
    withMigrationsAssembly(migrationsAssembly: Assembly): RelationalOptionsExtension;
    withMigrationsHistoryTableName(migrationsHistoryTableName: string): RelationalOptionsExtension;
    withMigrationsHistoryTableSchema(migrationsHistoryTableSchema: string): RelationalOptionsExtension;
    withMinBatchSize(minBatchSize: Nullable<System_Internal.Int32>): RelationalOptionsExtension;
    withUseParameterizedCollectionMode(parameterizedCollectionMode: ParameterTranslationMode): RelationalOptionsExtension;
    withUseQuerySplittingBehavior(querySplittingBehavior: QuerySplittingBehavior): RelationalOptionsExtension;
    withUseRelationalNulls(useRelationalNulls: boolean): RelationalOptionsExtension;
}


export const RelationalOptionsExtension: {
    extract(options: IDbContextOptions): RelationalOptionsExtension;
    withDefaultWarningConfiguration(coreOptionsExtension: CoreOptionsExtension): CoreOptionsExtension;
};


export interface __RelationalOptionsExtension$views {
    As_IDbContextOptionsExtension(): IDbContextOptionsExtension$instance;
}

export interface RelationalOptionsExtension$instance extends IDbContextOptionsExtension$instance {}

export type RelationalOptionsExtension = RelationalOptionsExtension$instance & __RelationalOptionsExtension$views;


export interface RuntimeAnnotatableBase$instance {
    get item(): unknown | undefined;
    set item(value: unknown);
    addAnnotation(name: string, value: unknown): Annotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotations(annotations: IEnumerable<Annotation>): void;
    addRuntimeAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    getAnnotation(annotationName: string): Annotation;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    removeAnnotation(name: string): Annotation | undefined;
    removeRuntimeAnnotation(name: string): Annotation | undefined;
    setAnnotation(name: string, value: unknown): void;
    setRuntimeAnnotation(name: string, value: unknown): Annotation;
}


export const RuntimeAnnotatableBase: {
    new(): RuntimeAnnotatableBase;
};


export interface __RuntimeAnnotatableBase$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
}

export type RuntimeAnnotatableBase = RuntimeAnnotatableBase$instance & __RuntimeAnnotatableBase$views;


export interface RuntimeModelDependencies$instance {
    constructorBindingFactory: IConstructorBindingFactory;
    parameterBindingFactories: IParameterBindingFactories;
    typeMappingSource: ITypeMappingSource;
    _Clone_$(): RuntimeModelDependencies;
    equals(obj: unknown): boolean;
    equals(other: RuntimeModelDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RuntimeModelDependencies: {
    new(typeMappingSource: ITypeMappingSource, constructorBindingFactory: IConstructorBindingFactory, parameterBindingFactories: IParameterBindingFactories): RuntimeModelDependencies;
};


export type RuntimeModelDependencies = RuntimeModelDependencies$instance;

export interface ServiceCollectionMap$instance {
    readonly serviceCollection: IServiceCollection;
    tryAdd(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceCollectionMap;
    tryAdd(serviceType: Type, factory: Func<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceCollectionMap;
    tryAddEnumerable(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceCollectionMap;
    tryAddEnumerable(serviceType: Type, implementationType: Type, factory: Func<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceCollectionMap;
    tryAddScoped<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddScoped(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddScoped<TService>(factory: Func<IServiceProvider, TService>): ServiceCollectionMap;
    tryAddScoped(serviceType: Type, factory: Func<IServiceProvider, unknown>): ServiceCollectionMap;
    tryAddScopedEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddScopedEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddScopedEnumerable<TService, TImplementation extends TService>(factory: Func<IServiceProvider, TImplementation>): ServiceCollectionMap;
    tryAddSingleton<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddSingleton(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddSingleton<TService>(factory: Func<IServiceProvider, TService>): ServiceCollectionMap;
    tryAddSingleton(serviceType: Type, factory: Func<IServiceProvider, unknown>): ServiceCollectionMap;
    tryAddSingleton<TService>(implementation: TService): ServiceCollectionMap;
    tryAddSingleton(serviceType: Type, implementation: unknown): ServiceCollectionMap;
    tryAddSingletonEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddSingletonEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddSingletonEnumerable<TService, TImplementation extends TService>(factory: Func<IServiceProvider, TImplementation>): ServiceCollectionMap;
    tryAddSingletonEnumerable<TService>(implementation: TService): ServiceCollectionMap;
    tryAddSingletonEnumerable(serviceType: Type, implementation: unknown): ServiceCollectionMap;
    tryAddTransient<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddTransient(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddTransient<TService>(factory: Func<IServiceProvider, TService>): ServiceCollectionMap;
    tryAddTransient(serviceType: Type, factory: Func<IServiceProvider, unknown>): ServiceCollectionMap;
    tryAddTransientEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    tryAddTransientEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    tryAddTransientEnumerable<TService, TImplementation extends TService>(factory: Func<IServiceProvider, TImplementation>): ServiceCollectionMap;
}


export const ServiceCollectionMap: {
    new(serviceCollection: IServiceCollection): ServiceCollectionMap;
};


export interface __ServiceCollectionMap$views {
    As_IInfrastructure_1(): IInfrastructure_1$instance<IInternalServiceCollectionMap>;
}

export interface ServiceCollectionMap$instance extends IInfrastructure_1$instance<IInternalServiceCollectionMap> {}

export type ServiceCollectionMap = ServiceCollectionMap$instance & __ServiceCollectionMap$views;


export interface ServiceProviderAccessor$instance {
    readonly rootServiceProvider: IServiceProvider;
}


export const ServiceProviderAccessor: {
    new(rootServiceProvider: IServiceProvider): ServiceProviderAccessor;
};


export type ServiceProviderAccessor = ServiceProviderAccessor$instance;

export abstract class AccessorExtensions$instance {
    static getInfrastructure<T>(accessor: IInfrastructure_1<T>): T;
    static getService(accessor: IInfrastructure_1<IServiceProvider>, serviceType: Type): unknown;
    static getService<TService>(accessor: IInfrastructure_1<IServiceProvider>): TService;
}


export type AccessorExtensions = AccessorExtensions$instance;

export abstract class EntityFrameworkMetricsData$instance {
    static reportCompiledQueryCacheHit(): void;
    static reportCompiledQueryCacheMiss(): void;
    static reportDbContextDisposing(): void;
    static reportDbContextInitializing(): void;
    static reportExecutionStrategyOperationFailure(): void;
    static reportOptimisticConcurrencyFailure(): void;
    static reportQueryExecuting(): void;
    static reportSavingChanges(): void;
}


export type EntityFrameworkMetricsData = EntityFrameworkMetricsData$instance;

export abstract class ExpressionExtensions$instance {
    static readonly valueBufferTryReadValueMethod: MethodInfo;
    static assign(memberExpression: MemberExpression, valueExpression: Expression): Expression;
    static createEFPropertyExpression(target: Expression, property: IPropertyBase, makeNullable?: boolean): Expression;
    static createEFPropertyExpression(target: Expression, propertyDeclaringType: Type, propertyType: Type, propertyName: string, makeNullable: boolean): Expression;
    static createEqualsExpression(left: Expression, right: Expression, negated?: boolean): Expression;
    static createKeyValuesExpression(target: Expression, properties: IReadOnlyList<IProperty>, makeNullable?: boolean): Expression;
    static createValueBufferReadValueExpression(valueBuffer: Expression, type_: Type, index: int, property: IPropertyBase): Expression;
    static getMemberAccess(memberAccessExpression: LambdaExpression): MemberInfo;
    static getMemberAccessList(memberAccessExpression: LambdaExpression): IReadOnlyList<MemberInfo>;
    static getPropertyAccess(propertyAccessExpression: LambdaExpression): PropertyInfo;
    static getPropertyAccessList(propertyAccessExpression: LambdaExpression): IReadOnlyList<PropertyInfo>;
    static isMemberAccess(expression: Expression, model: IModel, baseExpression: Expression, memberIdentity: MemberIdentity): boolean;
    static isMemberAccess(expression: Expression, model: IModel, baseExpression: Expression): boolean;
    static makeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    static print(expression: Expression, characterLimit?: Nullable<System_Internal.Int32>): string;
    static tryGetEFPropertyArguments(methodCallExpression: MethodCallExpression, entityExpression: Expression, propertyName: string): boolean;
    static tryGetIndexerArguments(methodCallExpression: MethodCallExpression, model: IModel, entityExpression: Expression, propertyName: string): boolean;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class LazyLoaderExtensions$instance {
    static load<TRelated>(loader: ILazyLoader, entity: unknown, navigationField: TRelated, navigationName?: string): TRelated | undefined;
}


export type LazyLoaderExtensions = LazyLoaderExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static isEFPropertyMethod(methodInfo: MethodInfo): boolean;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ProductInfo$instance {
    static getVersion(): string;
}


export type ProductInfo = ProductInfo$instance;

export abstract class RelationalModelExtensions$instance {
    static getRelationalDependencies(model: IModel, methodName?: string): RelationalModelDependencies;
}


export type RelationalModelExtensions = RelationalModelExtensions$instance;

export abstract class RelationalPropertyExtensions$instance {
    static formatColumns(properties: IEnumerable<IReadOnlyProperty>, storeObject: StoreObjectIdentifier): string;
    static getColumnNames(properties: IEnumerable<IReadOnlyProperty>, storeObject: StoreObjectIdentifier): IReadOnlyList<System_Internal.String> | undefined;
}


export type RelationalPropertyExtensions = RelationalPropertyExtensions$instance;

export abstract class TypeExtensions$instance {
    static shortDisplayName(type_: Type): string;
}


export type TypeExtensions = TypeExtensions$instance;

export abstract class Uniquifier$instance {
    static truncate(identifier: string, maxLength: int, uniquifier?: Nullable<System_Internal.Int32>): string;
    static truncate(identifier: string, maxLength: int, suffix: string, uniquifier?: Nullable<System_Internal.Int32>): string;
    static uniquify<TKey, TValue>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary<TKey, TValue>, keySelector: Func<System_Internal.String, TKey>, maxLength: int): string;
    static uniquify<TKey, TValue>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary<TKey, TValue>, keySelector: Func<System_Internal.String, TKey>, suffix: string, maxLength: int): string;
    static uniquify<T>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary<System_Internal.String, T>, maxLength: int): string;
    static uniquify<T>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary<System_Internal.String, T>, suffix: string, maxLength: int): string;
    static uniquify(currentIdentifier: string, otherIdentifiers: ISet<System_Internal.String>, suffix: string, maxLength: int): string;
}


export type Uniquifier = Uniquifier$instance;

