// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Infrastructure
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Abstractions, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IDbContextLogger, IDiagnosticsLogger_1, IInterceptor, ISingletonInterceptor, WarningsConfiguration } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import type { IDbContextPool_1 } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Metadata_Builders_Internal from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { IConventionAnnotatableBuilder, IConventionModelBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { IConventionSetBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Conventions.Infrastructure/internal/index.js";
import type { ConventionAnnotation, IMemberClassifier } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Metadata_Internal from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { ConfigurationSource, ICheckConstraint, IClrPropertySetter, IComplexType, IConstructorBindingFactory, IConventionAnnotatable, IConventionAnnotation, IConventionComplexProperty, IConventionModel, IConventionProperty, IConventionTypeBase, IEntityType, IForeignKey, IIndex, IKey, IModel, IMutableAnnotatable, IParameterBindingFactories, IProperty, IPropertyBase, IReadOnlyProperty, IRelationalAnnotationProvider, ITrigger, MemberIdentity, StoreObjectIdentifier } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IValueConverterSelector } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Storage_Internal from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { ExecutionStrategyDependencies, IDatabaseFacadeDependencies, IDatabaseFacadeDependenciesAccessor, IDbContextTransaction, IExecutionStrategy, IRelationalTypeMappingSource, ITypeMappingSource } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { IRowForeignKeyValueFactoryFactory, IRowIndexValueFactoryFactory, IRowKeyValueFactoryFactory } from "../../Microsoft.EntityFrameworkCore.Update.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Internal from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { AutoTransactionBehavior, DbContext, DbContextOptions_1, DbContextOptionsBuilder, DbLoggerCategory_Model, DbLoggerCategory_Model_Validation, IDbContextFactory_1, ModelBuilder, ModelCreationDependencies, ParameterTranslationMode, QuerySplittingBehavior, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IDictionary_2, IEnumerable_1, IReadOnlyDictionary_2, IReadOnlyList_1, ISet_1 } from "@tsonic/dotnet/System.Collections.Generic/internal/index.js";
import type { DbConnection } from "@tsonic/dotnet/System.Data.Common/internal/index.js";
import * as System_Diagnostics_Tracing_Internal from "@tsonic/dotnet/System.Diagnostics.Tracing/internal/index.js";
import type { EventCommandEventArgs, EventSource } from "@tsonic/dotnet/System.Diagnostics.Tracing/internal/index.js";
import type { Expression, LambdaExpression, MemberExpression, MethodCallExpression } from "@tsonic/dotnet/System.Linq.Expressions/internal/index.js";
import type { Assembly, MemberInfo, MethodInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection/internal/index.js";
import type { Task, Task_1 } from "@tsonic/dotnet/System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System/internal/index.js";
import type { Action_1, Action_2, Attribute, Boolean as ClrBoolean, Char, Enum, FormattableString, Func_1, Func_2, Func_4, IComparable, IConvertible, IDisposable, IEquatable_1, IFormattable, Int32, IServiceProvider, ISpanFormattable, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, ValueTuple_2, ValueType, Void } from "@tsonic/dotnet/System/internal/index.js";
import type { IMemoryCache } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Caching.Memory/internal/index.js";
import type { IServiceCollection, ServiceLifetime } from "@tsonic/microsoft-extensions/Microsoft.Extensions.DependencyInjection/internal/index.js";
import type { ILoggerFactory } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Logging/internal/index.js";

export enum MetadataDebugStringOptions {
    IncludeAnnotations = 1,
    IncludePropertyIndexes = 2,
    SingleLine = 4,
    ShortDefault = 0,
    LongDefault = 1,
    SingleLineDefault = 4
}


export interface IAnnotatable$instance extends IReadOnlyAnnotatable {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotatable: never;

    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func_2<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable_1<IAnnotation>;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable_1<IAnnotation>;
}


export interface IAnnotatable$instance extends IReadOnlyAnnotatable$instance {}

export type IAnnotatable = IAnnotatable$instance & { readonly [name: string]: unknown | undefined; };

export interface IAnnotation$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotation: never;

    readonly Name: string;
    readonly Value: unknown | undefined;
}


export type IAnnotation = IAnnotation$instance;

export interface IConcurrencyDetector$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IConcurrencyDetector: never;

    EnterCriticalSection(): ConcurrencyDetectorCriticalSectionDisposer;
    ExitCriticalSection(): void;
}


export type IConcurrencyDetector = IConcurrencyDetector$instance;

export interface ICoreSingletonOptions$instance extends ISingletonOptions {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_ICoreSingletonOptions: never;

    readonly AreDetailedErrorsEnabled: boolean;
    readonly AreThreadSafetyChecksEnabled: boolean;
    readonly RootApplicationServiceProvider: IServiceProvider | undefined;
    Initialize(options: IDbContextOptions): void;
}


export interface ICoreSingletonOptions$instance extends ISingletonOptions$instance {}

export type ICoreSingletonOptions = ICoreSingletonOptions$instance;

export interface ICurrentDbContext$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_ICurrentDbContext: never;

    readonly Context: DbContext;
}


export type ICurrentDbContext = ICurrentDbContext$instance;

export interface IDbContextOptions$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptions: never;

    readonly Extensions: IEnumerable_1<IDbContextOptionsExtension>;
    FindExtension<TExtension extends IDbContextOptionsExtension>(): TExtension | undefined;
}


export type IDbContextOptions = IDbContextOptions$instance;

export interface IDbContextOptionsBuilderInfrastructure$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptionsBuilderInfrastructure: never;

    AddOrUpdateExtension<TExtension extends IDbContextOptionsExtension>(extension: TExtension): void;
}


export type IDbContextOptionsBuilderInfrastructure = IDbContextOptionsBuilderInfrastructure$instance;

export interface IDbContextOptionsConfiguration_1$instance<TContext extends DbContext> {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptionsConfiguration_1: never;

    Configure(serviceProvider: IServiceProvider, optionsBuilder: DbContextOptionsBuilder): void;
}


export type IDbContextOptionsConfiguration_1<TContext extends DbContext> = IDbContextOptionsConfiguration_1$instance<TContext>;

export interface IDbContextOptionsExtension$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptionsExtension: never;

    readonly Info: DbContextOptionsExtensionInfo;
    ApplyDefaults(options: IDbContextOptions): IDbContextOptionsExtension;
    ApplyServices(services: IServiceCollection): void;
    Validate(options: IDbContextOptions): void;
}


export type IDbContextOptionsExtension = IDbContextOptionsExtension$instance;

export interface IDbSetFinder$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbSetFinder: never;

    FindSets(contextType: Type): IReadOnlyList_1<DbSetProperty>;
}


export type IDbSetFinder = IDbSetFinder$instance;

export interface IInfrastructure_1$instance<T> {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IInfrastructure_1: never;

    readonly Instance: T;
}


export type IInfrastructure_1<T> = IInfrastructure_1$instance<T>;

export interface IInternalServiceCollectionMap$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IInternalServiceCollectionMap: never;

    AddDependencySingleton<TDependencies>(): IInternalServiceCollectionMap;
}


export type IInternalServiceCollectionMap = IInternalServiceCollectionMap$instance;

export interface ILazyLoader$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_ILazyLoader: never;

    Dispose(): void;
    IsLoaded(entity: unknown, navigationName?: string): boolean;
    Load(entity: unknown, navigationName?: string): void;
    LoadAsync(entity: unknown, cancellationToken?: CancellationToken, navigationName?: string): Task;
    SetLoaded(entity: unknown, navigationName?: string, loaded?: boolean): void;
}


export type ILazyLoader = ILazyLoader$instance;

export interface IModelCacheKeyFactory$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelCacheKeyFactory: never;

    Create(context: DbContext, designTime: boolean): unknown;
}


export type IModelCacheKeyFactory = IModelCacheKeyFactory$instance;

export interface IModelCustomizer$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelCustomizer: never;

    Customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export type IModelCustomizer = IModelCustomizer$instance;

export interface IModelRuntimeInitializer$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelRuntimeInitializer: never;

    Initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
}


export type IModelRuntimeInitializer = IModelRuntimeInitializer$instance;

export interface IModelSource$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelSource: never;

    GetModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
}


export type IModelSource = IModelSource$instance;

export interface IModelValidator$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelValidator: never;

    Validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export type IModelValidator = IModelValidator$instance;

export interface IReadOnlyAnnotatable$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IReadOnlyAnnotatable: never;

    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable_1<IAnnotation>;
}


export type IReadOnlyAnnotatable = IReadOnlyAnnotatable$instance & { readonly [name: string]: unknown | undefined; };

export interface IRelationalDbContextOptionsBuilderInfrastructure$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IRelationalDbContextOptionsBuilderInfrastructure: never;

    readonly OptionsBuilder: DbContextOptionsBuilder;
}


export type IRelationalDbContextOptionsBuilderInfrastructure = IRelationalDbContextOptionsBuilderInfrastructure$instance;

export interface IResettableService$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IResettableService: never;

    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
}


export type IResettableService = IResettableService$instance;

export interface ISingletonOptions$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_ISingletonOptions: never;

    Initialize(options: IDbContextOptions): void;
}


export type ISingletonOptions = ISingletonOptions$instance;

export interface ConcurrencyDetectorCriticalSectionDisposer$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ConcurrencyDetectorCriticalSectionDisposer: never;

    readonly __tsonic_iface_System_IDisposable: never;

    Dispose(): void;
}


export const ConcurrencyDetectorCriticalSectionDisposer: {
    new(concurrencyDetector: IConcurrencyDetector): ConcurrencyDetectorCriticalSectionDisposer;
};


export type ConcurrencyDetectorCriticalSectionDisposer = ConcurrencyDetectorCriticalSectionDisposer$instance;

export interface DbSetProperty$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DbSetProperty: never;

    readonly Name: string;
    readonly Setter: IClrPropertySetter | undefined;
    readonly Type: Type;
}


export const DbSetProperty: {
    new(name: string, type: Type, setter: IClrPropertySetter): DbSetProperty;
};


export type DbSetProperty = DbSetProperty$instance;

export interface ServiceCharacteristics$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ServiceCharacteristics: never;

    readonly Lifetime: ServiceLifetime;
    readonly MultipleRegistrations: boolean;
}


export const ServiceCharacteristics: {
    new(lifetime: ServiceLifetime, multipleRegistrations: boolean): ServiceCharacteristics;
};


export type ServiceCharacteristics = ServiceCharacteristics$instance;

export interface Annotatable$instance extends AnnotatableBase$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_Annotatable: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IReadOnlyAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Metadata_IMutableAnnotatable: never;

    AddAnnotation(name: string, value: unknown): Annotation;
    AddAnnotation(name: string, annotation: Annotation): Annotation;
    AddAnnotations(annotations: IEnumerable_1<IAnnotation>): void;
    AddAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    EnsureMutable(): void;
    EnsureReadOnly(): void;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable_1<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func_2<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable_1<Annotation>;
    RemoveAnnotation(name: string): Annotation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetAnnotation(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation | undefined;
}


export const Annotatable: {
    new(): Annotatable;
};


export interface __Annotatable$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
    As_IMutableAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IMutableAnnotatable$instance;
}

export type Annotatable = Annotatable$instance & __Annotatable$views;


export interface AnnotatableBase$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_AnnotatableBase: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IReadOnlyAnnotatable: never;

    readonly IsReadOnly: boolean;
    AddAnnotation(name: string, value: unknown): Annotation;
    AddAnnotation(name: string, annotation: Annotation): Annotation;
    AddAnnotations(annotations: IEnumerable_1<IAnnotation>): void;
    AddAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotations(annotations: IEnumerable_1<Annotation>): void;
    AddRuntimeAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    CreateAnnotation(name: string, value: unknown): Annotation;
    CreateRuntimeAnnotation(name: string, value: unknown): Annotation;
    EnsureMutable(): void;
    EnsureReadOnly(): void;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    GetAnnotation(annotationName: string): Annotation;
    GetAnnotations(): IEnumerable_1<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func_2<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable_1<Annotation>;
    OnAnnotationSet(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation | undefined;
    RemoveAnnotation(name: string): Annotation | undefined;
    RemoveRuntimeAnnotation(name: string): Annotation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetAnnotation(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation | undefined;
    SetRuntimeAnnotation(name: string, value: unknown): Annotation;
    SetRuntimeAnnotation(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation;
}


export const AnnotatableBase: {
    new(): AnnotatableBase;
};


export interface __AnnotatableBase$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
}

export type AnnotatableBase = AnnotatableBase$instance & __AnnotatableBase$views & { [name: string]: unknown | undefined; };


export interface AnnotatableBuilder_2$instance<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_AnnotatableBuilder_2: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Metadata_Builders_IConventionAnnotatableBuilder: never;

    readonly Metadata: TMetadata;
    readonly ModelBuilder: TModelBuilder;
    CanRemoveAnnotation(name: string, configurationSource: ConfigurationSource): boolean;
    CanSetAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): boolean;
    HasAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    HasNoAnnotation(name: string, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    HasNonNullAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
    MergeAnnotationsFrom(annotatable: TMetadata): AnnotatableBuilder_2<TMetadata, TModelBuilder>;
    MergeAnnotationsFrom(annotatable: TMetadata, minimalConfigurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder>;
    RemoveAnnotation(name: string, configurationSource: ConfigurationSource): AnnotatableBuilder_2<TMetadata, TModelBuilder> | undefined;
}


export const AnnotatableBuilder_2: (abstract new<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder>(metadata: TMetadata, modelBuilder: TModelBuilder) => AnnotatableBuilder_2<TMetadata, TModelBuilder>) & {
};


export interface __AnnotatableBuilder_2$views<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> {
    As_IConventionAnnotatableBuilder(): Microsoft_EntityFrameworkCore_Metadata_Builders_Internal.IConventionAnnotatableBuilder$instance;
}

export type AnnotatableBuilder_2<TMetadata extends ConventionAnnotatable, TModelBuilder extends IConventionModelBuilder> = AnnotatableBuilder_2$instance<TMetadata, TModelBuilder> & __AnnotatableBuilder_2$views<TMetadata, TModelBuilder>;


export interface Annotation$instance extends IAnnotation$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_Annotation: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotation: never;

    readonly Name: string;
    readonly Value: unknown | undefined;
}


export const Annotation: {
    new(name: string, value: unknown): Annotation;
};


export interface __Annotation$views {
    As_IAnnotation(): IAnnotation$instance;
}

export type Annotation = Annotation$instance & __Annotation$views;


export interface ConventionAnnotatable$instance extends Annotatable$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ConventionAnnotatable: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IReadOnlyAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Metadata_IConventionAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Metadata_IMutableAnnotatable: never;

    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotation(name: string, value: unknown): Annotation;
    AddAnnotation(name: string, annotation: Annotation): Annotation;
    AddAnnotations(annotations: IEnumerable_1<IAnnotation>): void;
    AddAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    CreateAnnotation(name: string, value: unknown): Annotation;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable_1<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func_2<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable_1<IAnnotation>;
    OnAnnotationSet(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation | undefined;
    OnAnnotationSet(name: string, annotation: IConventionAnnotation, oldAnnotation: IConventionAnnotation): IConventionAnnotation | undefined;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    RemoveAnnotation(name: string): Annotation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetAnnotation(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation | undefined;
    SetOrRemoveAnnotation(name: string, value: unknown, configurationSource: ConfigurationSource): ConventionAnnotation | undefined;
}


export const ConventionAnnotatable: (abstract new() => ConventionAnnotatable) & {
};


export interface __ConventionAnnotatable$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
    As_IConventionAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IConventionAnnotatable$instance;
    As_IMutableAnnotatable(): Microsoft_EntityFrameworkCore_Metadata_Internal.IMutableAnnotatable$instance;
}

export type ConventionAnnotatable = ConventionAnnotatable$instance & __ConventionAnnotatable$views;


export interface CoreOptionsExtension$instance extends IDbContextOptionsExtension$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_CoreOptionsExtension: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptionsExtension: never;

    readonly ApplicationServiceProvider: IServiceProvider | undefined;
    readonly AsyncSeeder: Func_4<DbContext, System_Internal.Boolean, CancellationToken, Task> | undefined;
    readonly AutoResolveRootProvider: boolean;
    readonly DbContextLogger: IDbContextLogger | undefined;
    readonly DetailedErrorsEnabled: boolean;
    readonly Info: DbContextOptionsExtensionInfo;
    readonly Interceptors: IEnumerable_1<IInterceptor> | undefined;
    readonly InternalServiceProvider: IServiceProvider | undefined;
    readonly IsSensitiveDataLoggingEnabled: boolean;
    readonly LoggerFactory: ILoggerFactory | undefined;
    readonly LoggingCacheTime: TimeSpan;
    readonly MaxPoolSize: Nullable_1<System_Internal.Int32>;
    readonly MemoryCache: IMemoryCache | undefined;
    readonly Model: IModel | undefined;
    readonly QueryTrackingBehavior: QueryTrackingBehavior;
    readonly ReplacedServices: IReadOnlyDictionary_2<ValueTuple_2<Type, Type>, Type | undefined> | undefined;
    readonly RootApplicationServiceProvider: IServiceProvider | undefined;
    readonly Seeder: Action_2<DbContext, System_Internal.Boolean> | undefined;
    readonly ServiceProviderCachingEnabled: boolean;
    readonly SingletonInterceptors: IEnumerable_1<ISingletonInterceptor> | undefined;
    readonly ThreadSafetyChecksEnabled: boolean;
    readonly WarningsConfiguration: WarningsConfiguration;
    ApplyServices(services: IServiceCollection): void;
    Clone(): CoreOptionsExtension;
    Validate(options: IDbContextOptions): void;
    WithApplicationServiceProvider(applicationServiceProvider: IServiceProvider): CoreOptionsExtension;
    WithAsyncSeeding(seedAsync: Func_4<DbContext, System_Internal.Boolean, CancellationToken, Task>): CoreOptionsExtension;
    WithDbContextLogger(contextLogger: IDbContextLogger): CoreOptionsExtension;
    WithDetailedErrorsEnabled(detailedErrorsEnabled: boolean): CoreOptionsExtension;
    WithInterceptors(interceptors: IEnumerable_1<IInterceptor>): CoreOptionsExtension;
    WithInternalServiceProvider(internalServiceProvider: IServiceProvider): CoreOptionsExtension;
    WithLoggerFactory(loggerFactory: ILoggerFactory): CoreOptionsExtension;
    WithLoggingCacheTime(timeSpan: TimeSpan): CoreOptionsExtension;
    WithMaxPoolSize(maxPoolSize: Nullable_1<System_Internal.Int32>): CoreOptionsExtension;
    WithMemoryCache(memoryCache: IMemoryCache): CoreOptionsExtension;
    WithModel(model: IModel): CoreOptionsExtension;
    WithQueryTrackingBehavior(queryTrackingBehavior: QueryTrackingBehavior): CoreOptionsExtension;
    WithReplacedService(serviceType: Type, newImplementationType: Type, currentImplementationType?: Type): CoreOptionsExtension;
    WithRootApplicationServiceProvider(rootApplicationServiceProvider: IServiceProvider): CoreOptionsExtension;
    WithRootApplicationServiceProvider(autoResolve?: boolean): CoreOptionsExtension;
    WithSeeding(seed: Action_2<DbContext, System_Internal.Boolean>): CoreOptionsExtension;
    WithSensitiveDataLoggingEnabled(sensitiveDataLoggingEnabled: boolean): CoreOptionsExtension;
    WithServiceProviderCachingEnabled(serviceProviderCachingEnabled: boolean): CoreOptionsExtension;
    WithSingletonInterceptors(interceptors: IEnumerable_1<ISingletonInterceptor>): CoreOptionsExtension;
    WithThreadSafetyChecksEnabled(checksEnabled: boolean): CoreOptionsExtension;
    WithWarningsConfiguration(warningsConfiguration: WarningsConfiguration): CoreOptionsExtension;
}


export const CoreOptionsExtension: {
    new(): CoreOptionsExtension;
};


export interface __CoreOptionsExtension$views {
    As_IDbContextOptionsExtension(): IDbContextOptionsExtension$instance;
}

export type CoreOptionsExtension = CoreOptionsExtension$instance & __CoreOptionsExtension$views;


export interface DatabaseFacade$instance extends IInfrastructure_1$instance<IServiceProvider>, IResettableService$instance, Microsoft_EntityFrameworkCore_Storage_Internal.IDatabaseFacadeDependenciesAccessor$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DatabaseFacade: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IInfrastructure_1: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IResettableService: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Storage_IDatabaseFacadeDependenciesAccessor: never;

    AutoSavepointsEnabled: boolean;
    AutoTransactionBehavior: AutoTransactionBehavior;
    AutoTransactionsEnabled: boolean;
    readonly CurrentTransaction: IDbContextTransaction | undefined;
    readonly ProviderName: string | undefined;
    BeginTransaction(): IDbContextTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): Task_1<IDbContextTransaction>;
    CanConnect(): boolean;
    CanConnectAsync(cancellationToken?: CancellationToken): Task_1<System_Internal.Boolean>;
    CommitTransaction(): void;
    CommitTransactionAsync(cancellationToken?: CancellationToken): Task;
    CreateExecutionStrategy(): IExecutionStrategy;
    EnsureCreated(): boolean;
    EnsureCreatedAsync(cancellationToken?: CancellationToken): Task_1<System_Internal.Boolean>;
    EnsureDeleted(): boolean;
    EnsureDeletedAsync(cancellationToken?: CancellationToken): Task_1<System_Internal.Boolean>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    RollbackTransaction(): void;
    RollbackTransactionAsync(cancellationToken?: CancellationToken): Task;
    ToString(): string | undefined;
}


export const DatabaseFacade: {
    new(context: DbContext): DatabaseFacade;
};


export interface __DatabaseFacade$views {
    As_IInfrastructure_1(): IInfrastructure_1$instance<IServiceProvider>;
    As_IResettableService(): IResettableService$instance;
    As_IDatabaseFacadeDependenciesAccessor(): Microsoft_EntityFrameworkCore_Storage_Internal.IDatabaseFacadeDependenciesAccessor$instance;
}

export type DatabaseFacade = DatabaseFacade$instance & __DatabaseFacade$views;


export interface DbContextAttribute$instance extends Attribute {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DbContextAttribute: never;

    readonly ContextType: Type;
}


export const DbContextAttribute: {
    new(contextType: Type): DbContextAttribute;
};


export type DbContextAttribute = DbContextAttribute$instance;

export interface DbContextModelAttribute$instance extends Attribute {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DbContextModelAttribute: never;

    readonly ContextType: Type;
    readonly ModelType: Type;
}


export const DbContextModelAttribute: {
    new(contextType: Type, modelType: Type): DbContextModelAttribute;
};


export type DbContextModelAttribute = DbContextModelAttribute$instance;

export interface DbContextOptionsExtensionInfo$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DbContextOptionsExtensionInfo: never;

    readonly Extension: IDbContextOptionsExtension;
    readonly IsDatabaseProvider: boolean;
    readonly LogFragment: string;
    GetServiceProviderHashCode(): int;
    PopulateDebugInfo(debugInfo: IDictionary_2<System_Internal.String, System_Internal.String>): void;
    ShouldUseSameServiceProvider(other: DbContextOptionsExtensionInfo): boolean;
}


export const DbContextOptionsExtensionInfo: (abstract new(extension: IDbContextOptionsExtension) => DbContextOptionsExtensionInfo) & {
};


export type DbContextOptionsExtensionInfo = DbContextOptionsExtensionInfo$instance;

export interface DebugView$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_DebugView: never;

    readonly LongView: string;
    readonly ShortView: string;
}


export const DebugView: {
    new(toShortDebugString: Func_1<System_Internal.String>, toLongDebugString: Func_1<System_Internal.String>): DebugView;
};


export type DebugView = DebugView$instance;

export interface EntityFrameworkEventSource$instance extends EventSource {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_EntityFrameworkEventSource: never;

    readonly __tsonic_iface_System_IDisposable: never;

    CompiledQueryCacheHit(): void;
    CompiledQueryCacheMiss(): void;
    DbContextDisposing(): void;
    DbContextInitializing(): void;
    ExecutionStrategyOperationFailure(): void;
    OnEventCommand(command: EventCommandEventArgs): void;
    OptimisticConcurrencyFailure(): void;
    QueryExecuting(): void;
    SavingChanges(): void;
}


export const EntityFrameworkEventSource: {
    readonly Log: EntityFrameworkEventSource;
};


export type EntityFrameworkEventSource = EntityFrameworkEventSource$instance;

export interface EntityFrameworkInternalAttribute$instance extends Attribute {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_EntityFrameworkInternalAttribute: never;

}


export const EntityFrameworkInternalAttribute: {
    new(): EntityFrameworkInternalAttribute;
};


export type EntityFrameworkInternalAttribute = EntityFrameworkInternalAttribute$instance;

export interface EntityFrameworkRelationalServicesBuilder$instance extends EntityFrameworkServicesBuilder {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_EntityFrameworkRelationalServicesBuilder: never;

    TryAddCoreServices(): EntityFrameworkServicesBuilder;
    TryGetServiceCharacteristics(serviceType: Type): Nullable_1<ServiceCharacteristics>;
    TryGetServiceCharacteristics(serviceType: Type): Nullable_1<ServiceCharacteristics>;
}


export const EntityFrameworkRelationalServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkRelationalServicesBuilder;
    readonly RelationalServices: IDictionary_2<Type, ServiceCharacteristics>;
};


export type EntityFrameworkRelationalServicesBuilder = EntityFrameworkRelationalServicesBuilder$instance;

export interface EntityFrameworkServicesBuilder$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_EntityFrameworkServicesBuilder: never;

    readonly ServiceCollectionMap: ServiceCollectionMap;
    GetServiceCharacteristics(serviceType: Type): ServiceCharacteristics;
    TryAdd<TService, TImplementation extends TService>(): EntityFrameworkServicesBuilder;
    TryAdd(serviceType: Type, implementationType: Type): EntityFrameworkServicesBuilder;
    TryAdd<TService>(factory: Func_2<IServiceProvider, TService>): EntityFrameworkServicesBuilder;
    TryAdd(serviceType: Type, implementationType: Type, factory: Func_2<IServiceProvider, unknown>): EntityFrameworkServicesBuilder;
    TryAdd<TService>(implementation: TService): EntityFrameworkServicesBuilder;
    TryAdd(serviceType: Type, implementation: unknown): EntityFrameworkServicesBuilder;
    TryAddCoreServices(): EntityFrameworkServicesBuilder;
    TryAddProviderSpecificServices(serviceMap: Action_1<ServiceCollectionMap>): EntityFrameworkServicesBuilder;
    TryGetServiceCharacteristics(serviceType: Type): Nullable_1<ServiceCharacteristics>;
}


export const EntityFrameworkServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkServicesBuilder;
    readonly CoreServices: IDictionary_2<Type, ServiceCharacteristics>;
};


export type EntityFrameworkServicesBuilder = EntityFrameworkServicesBuilder$instance;

export interface IndentedStringBuilder$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_IndentedStringBuilder: never;

    readonly IndentCount: int;
    readonly Length: int;
    Append(value: string): IndentedStringBuilder;
    Append(value: FormattableString): IndentedStringBuilder;
    Append(value: char): IndentedStringBuilder;
    Append(value: IEnumerable_1<System_Internal.String>): IndentedStringBuilder;
    Append(value: IEnumerable_1<System_Internal.Char>): IndentedStringBuilder;
    AppendJoin(values: IEnumerable_1<System_Internal.String>, separator?: string): IndentedStringBuilder;
    AppendJoin(separator: string, ...values: string[]): IndentedStringBuilder;
    AppendLine(): IndentedStringBuilder;
    AppendLine(value: string): IndentedStringBuilder;
    AppendLine(value: FormattableString): IndentedStringBuilder;
    AppendLines(value: string, skipFinalNewline?: boolean): IndentedStringBuilder;
    Clear(): IndentedStringBuilder;
    Clone(): IndentedStringBuilder;
    DecrementIndent(): IndentedStringBuilder;
    IncrementIndent(): IndentedStringBuilder;
    Indent(): IDisposable;
    SuspendIndent(): IDisposable;
    ToString(): string;
}


export const IndentedStringBuilder: {
    new(): IndentedStringBuilder;
};


export type IndentedStringBuilder = IndentedStringBuilder$instance;

export interface ModelCacheKey$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelCacheKey: never;

    Equals(other: ModelCacheKey): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const ModelCacheKey: {
    new(context: DbContext): ModelCacheKey;
    new(context: DbContext, designTime: boolean): ModelCacheKey;
};


export type ModelCacheKey = ModelCacheKey$instance;

export interface ModelCacheKeyFactory$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelCacheKeyFactory: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelCacheKeyFactory: never;

    readonly Dependencies: ModelCacheKeyFactoryDependencies;
    Create(context: DbContext): unknown;
    Create(context: DbContext, designTime: boolean): unknown;
}


export const ModelCacheKeyFactory: {
    new(dependencies: ModelCacheKeyFactoryDependencies): ModelCacheKeyFactory;
};


export interface __ModelCacheKeyFactory$views {
    As_IModelCacheKeyFactory(): IModelCacheKeyFactory$instance;
}

export type ModelCacheKeyFactory = ModelCacheKeyFactory$instance & __ModelCacheKeyFactory$views;


export interface ModelCacheKeyFactoryDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelCacheKeyFactoryDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    _Clone_$(): ModelCacheKeyFactoryDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelCacheKeyFactoryDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelCacheKeyFactoryDependencies: {
    new(): ModelCacheKeyFactoryDependencies;
};


export type ModelCacheKeyFactoryDependencies = ModelCacheKeyFactoryDependencies$instance;

export interface ModelCustomizer$instance extends IModelCustomizer$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelCustomizer: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelCustomizer: never;

    readonly Dependencies: ModelCustomizerDependencies;
    Customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export const ModelCustomizer: {
    new(dependencies: ModelCustomizerDependencies): ModelCustomizer;
};


export interface __ModelCustomizer$views {
    As_IModelCustomizer(): IModelCustomizer$instance;
}

export type ModelCustomizer = ModelCustomizer$instance & __ModelCustomizer$views;


export interface ModelCustomizerDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelCustomizerDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    _Clone_$(): ModelCustomizerDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelCustomizerDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelCustomizerDependencies: {
    new(): ModelCustomizerDependencies;
};


export type ModelCustomizerDependencies = ModelCustomizerDependencies$instance;

export interface ModelDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    Logger: IDiagnosticsLogger_1<DbLoggerCategory_Model>;
    _Clone_$(): ModelDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelDependencies: {
    new(logger: IDiagnosticsLogger_1<DbLoggerCategory_Model>): ModelDependencies;
};


export type ModelDependencies = ModelDependencies$instance;

export interface ModelRuntimeInitializer$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelRuntimeInitializer: never;

    readonly Dependencies: ModelRuntimeInitializerDependencies;
    Initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
    InitializeModel(model: IModel, designTime: boolean, prevalidation: boolean): void;
}


export const ModelRuntimeInitializer: {
    new(dependencies: ModelRuntimeInitializerDependencies): ModelRuntimeInitializer;
};


export type ModelRuntimeInitializer = ModelRuntimeInitializer$instance;

export interface ModelRuntimeInitializerDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelRuntimeInitializerDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    ModelDependencies: RuntimeModelDependencies;
    ModelValidator: IModelValidator;
    _Clone_$(): ModelRuntimeInitializerDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelRuntimeInitializerDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelRuntimeInitializerDependencies: {
    new(runtimeModelDependencies: RuntimeModelDependencies, modelValidator: IModelValidator): ModelRuntimeInitializerDependencies;
};


export type ModelRuntimeInitializerDependencies = ModelRuntimeInitializerDependencies$instance;

export interface ModelSnapshot$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelSnapshot: never;

    readonly Model: IModel;
    BuildModel(modelBuilder: ModelBuilder): void;
}


export const ModelSnapshot: (abstract new() => ModelSnapshot) & {
};


export type ModelSnapshot = ModelSnapshot$instance;

export interface ModelSource$instance extends IModelSource$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelSource: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelSource: never;

    readonly Dependencies: ModelSourceDependencies;
    CreateModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
    CreateModel(context: DbContext, conventionSetBuilder: IConventionSetBuilder, modelDependencies: ModelDependencies): IModel;
    GetModel(context: DbContext, modelCreationDependencies: ModelCreationDependencies, designTime: boolean): IModel;
}


export const ModelSource: {
    new(dependencies: ModelSourceDependencies): ModelSource;
};


export interface __ModelSource$views {
    As_IModelSource(): IModelSource$instance;
}

export type ModelSource = ModelSource$instance & __ModelSource$views;


export interface ModelSourceDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelSourceDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    MemoryCache: IMemoryCache;
    ModelCacheKeyFactory: IModelCacheKeyFactory;
    ModelCustomizer: IModelCustomizer;
    _Clone_$(): ModelSourceDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelSourceDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelSourceDependencies: {
    new(modelCustomizer: IModelCustomizer, modelCacheKeyFactory: IModelCacheKeyFactory, memoryCache: IMemoryCache): ModelSourceDependencies;
};


export type ModelSourceDependencies = ModelSourceDependencies$instance;

export interface ModelValidator$instance extends IModelValidator$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelValidator: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelValidator: never;

    readonly Dependencies: ModelValidatorDependencies;
    IsOwned(targetType: Type, conventionModel: IConventionModel): boolean;
    IsRedundant(foreignKey: IForeignKey): boolean;
    LogShadowProperties(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ThrowPropertyNotMappedException(propertyType: string, structuralType: IConventionTypeBase, unmappedProperty: IConventionProperty): void;
    Validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateChangeTrackingStrategy(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateClrInheritance(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateData(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateDiscriminatorValues(rootEntityType: IEntityType): void;
    ValidateDiscriminatorValues(complexType: IComplexType): void;
    ValidateEntityClrTypes(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateFieldMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateForeignKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateIgnoredMembers(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateInheritanceMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateNoCycles(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateNoMutableKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateNonNullPrimaryKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateNoShadowKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateOwnership(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePrimitiveCollections(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(structuralType: IConventionTypeBase, model: IConventionModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(complexProperty: IConventionComplexProperty, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateQueryFilters(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateRelationships(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateTriggers(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateTypeMappings(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export const ModelValidator: {
    new(dependencies: ModelValidatorDependencies): ModelValidator;
};


export interface __ModelValidator$views {
    As_IModelValidator(): IModelValidator$instance;
}

export type ModelValidator = ModelValidator$instance & __ModelValidator$views;


export interface ModelValidatorDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ModelValidatorDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    MemberClassifier: IMemberClassifier;
    _Clone_$(): ModelValidatorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModelValidatorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModelValidatorDependencies: {
    new(memberClassifier: IMemberClassifier): ModelValidatorDependencies;
};


export type ModelValidatorDependencies = ModelValidatorDependencies$instance;

export interface PooledDbContextFactory_1$instance<TContext extends DbContext> extends Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext> {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_PooledDbContextFactory_1: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_IDbContextFactory_1: never;

    CreateDbContext(): TContext;
    CreateDbContextAsync(cancellationToken?: CancellationToken): Task_1<TContext>;
}


export const PooledDbContextFactory_1: {
    new<TContext extends DbContext>(pool: IDbContextPool_1<TContext>): PooledDbContextFactory_1<TContext>;
    new<TContext extends DbContext>(options: DbContextOptions_1<TContext>, poolSize: int): PooledDbContextFactory_1<TContext>;
};


export interface __PooledDbContextFactory_1$views<TContext extends DbContext> {
    As_IDbContextFactory_1(): Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext>;
}

export type PooledDbContextFactory_1<TContext extends DbContext> = PooledDbContextFactory_1$instance<TContext> & __PooledDbContextFactory_1$views<TContext>;


export interface RelationalDbContextOptionsBuilder_2$instance<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> extends IRelationalDbContextOptionsBuilderInfrastructure$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalDbContextOptionsBuilder_2: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IRelationalDbContextOptionsBuilderInfrastructure: never;

    readonly OptionsBuilder: DbContextOptionsBuilder;
    CommandTimeout(commandTimeout: Nullable_1<System_Internal.Int32>): TBuilder;
    Equals(obj: unknown): boolean;
    ExecutionStrategy(getExecutionStrategy: Func_2<ExecutionStrategyDependencies, IExecutionStrategy>): TBuilder;
    GetHashCode(): int;
    MaxBatchSize(maxBatchSize: int): TBuilder;
    MigrationsAssembly(assemblyName: string): TBuilder;
    MigrationsAssembly(assembly: Assembly): TBuilder;
    MigrationsHistoryTable(tableName: string, schema?: string): TBuilder;
    MinBatchSize(minBatchSize: int): TBuilder;
    ToString(): string | undefined;
    TranslateParameterizedCollectionsToConstants(): TBuilder;
    TranslateParameterizedCollectionsToParameters(): TBuilder;
    UseParameterizedCollectionMode(parameterizedCollectionMode: ParameterTranslationMode): TBuilder;
    UseQuerySplittingBehavior(querySplittingBehavior: QuerySplittingBehavior): TBuilder;
    UseRelationalNulls(useRelationalNulls?: boolean): TBuilder;
    WithOption(setAction: Func_2<TExtension, TExtension>): TBuilder;
}


export const RelationalDbContextOptionsBuilder_2: (abstract new<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension>(optionsBuilder: DbContextOptionsBuilder) => RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>) & {
};


export interface __RelationalDbContextOptionsBuilder_2$views<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> {
    As_IRelationalDbContextOptionsBuilderInfrastructure(): IRelationalDbContextOptionsBuilderInfrastructure$instance;
}

export type RelationalDbContextOptionsBuilder_2<TBuilder extends RelationalDbContextOptionsBuilder_2<TBuilder, TExtension>, TExtension extends RelationalOptionsExtension> = RelationalDbContextOptionsBuilder_2$instance<TBuilder, TExtension> & __RelationalDbContextOptionsBuilder_2$views<TBuilder, TExtension>;


export interface RelationalModelCustomizer$instance extends ModelCustomizer$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelCustomizer: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelCustomizer: never;

    Customize(modelBuilder: ModelBuilder, context: DbContext): void;
}


export const RelationalModelCustomizer: {
    new(dependencies: ModelCustomizerDependencies): RelationalModelCustomizer;
};


export interface __RelationalModelCustomizer$views {
    As_IModelCustomizer(): IModelCustomizer$instance;
}

export type RelationalModelCustomizer = RelationalModelCustomizer$instance & __RelationalModelCustomizer$views;


export interface RelationalModelDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    RowForeignKeyValueFactoryFactory: IRowForeignKeyValueFactoryFactory;
    RowIndexValueFactoryFactory: IRowIndexValueFactoryFactory;
    RowKeyValueFactoryFactory: IRowKeyValueFactoryFactory;
    ValueConverterSelector: IValueConverterSelector;
    _Clone_$(): RelationalModelDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalModelDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalModelDependencies: {
    new(rowKeyValueFactoryFactory: IRowKeyValueFactoryFactory, foreignKeyRowValueFactorySource: IRowForeignKeyValueFactoryFactory, rowIndexValueFactoryFactory: IRowIndexValueFactoryFactory, valueConverterSelector: IValueConverterSelector): RelationalModelDependencies;
};


export type RelationalModelDependencies = RelationalModelDependencies$instance;

export interface RelationalModelRuntimeInitializer$instance extends ModelRuntimeInitializer {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelRuntimeInitializer: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelRuntimeInitializer: never;

    readonly RelationalDependencies: RelationalModelRuntimeInitializerDependencies;
    Initialize(model: IModel, designTime?: boolean, validationLogger?: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): IModel;
    InitializeModel(model: IModel, designTime: boolean, prevalidation: boolean): void;
}


export const RelationalModelRuntimeInitializer: {
    new(dependencies: ModelRuntimeInitializerDependencies, relationalDependencies: RelationalModelRuntimeInitializerDependencies): RelationalModelRuntimeInitializer;
};


export interface __RelationalModelRuntimeInitializer$views {
    As_IModelRuntimeInitializer(): IModelRuntimeInitializer$instance;
}

export type RelationalModelRuntimeInitializer = RelationalModelRuntimeInitializer$instance & __RelationalModelRuntimeInitializer$views;


export interface RelationalModelRuntimeInitializerDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelRuntimeInitializerDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    RelationalAnnotationProvider: IRelationalAnnotationProvider;
    RelationalModelDependencies: RelationalModelDependencies;
    _Clone_$(): RelationalModelRuntimeInitializerDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalModelRuntimeInitializerDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalModelRuntimeInitializerDependencies: {
    new(relationalModelDependencies: RelationalModelDependencies, relationalAnnotationProvider: IRelationalAnnotationProvider): RelationalModelRuntimeInitializerDependencies;
};


export type RelationalModelRuntimeInitializerDependencies = RelationalModelRuntimeInitializerDependencies$instance;

export interface RelationalModelValidator$instance extends ModelValidator$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelValidator: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IModelValidator: never;

    readonly RelationalDependencies: RelationalModelValidatorDependencies;
    GetDefaultColumnValue(property: IProperty, storeObject: StoreObjectIdentifier): unknown | undefined;
    IsRedundant(foreignKey: IForeignKey): boolean;
    ThrowPropertyNotMappedException(propertyType: string, typeBase: IConventionTypeBase, unmappedProperty: IConventionProperty): void;
    Validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    Validate(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateBoolsWithDefaults(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(property: IProperty, duplicateProperty: IProperty, columnName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(foreignKey: IForeignKey, duplicateForeignKey: IForeignKey, foreignKeyName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(index: IIndex, duplicateIndex: IIndex, indexName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(key: IKey, duplicateKey: IKey, keyName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(checkConstraint: ICheckConstraint, duplicateCheckConstraint: ICheckConstraint, indexName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateCompatible(trigger: ITrigger, duplicateTrigger: ITrigger, indexName: string, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateData(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateData(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateDbFunctions(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateDefaultValuesOnKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateIndexProperties(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateInheritanceMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateInheritanceMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateJsonEntities(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateJsonEntityKey(storeObject: StoreObjectIdentifier, jsonEntityType: IEntityType): void;
    ValidateJsonEntityNavigations(storeObject: StoreObjectIdentifier, jsonEntityType: IEntityType): void;
    ValidateJsonEntityProperties(storeObject: StoreObjectIdentifier, jsonEntityType: IEntityType): void;
    ValidateJsonEntityRoot(storeObject: StoreObjectIdentifier, rootType: IEntityType): void;
    ValidateMappingFragments(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateMappingStrategy(entityType: IEntityType, mappingStrategy: string): void;
    ValidateNoMutableKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateNoMutableKeys(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePrimitiveCollections(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePrimitiveCollections(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(complexProperty: IConventionComplexProperty, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(structuralType: IConventionTypeBase, model: IConventionModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyMapping(complexProperty: IConventionComplexProperty, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidatePropertyOverrides(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedCheckConstraintCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedColumnsCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedForeignKeysCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedIndexesCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedKeysCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedTableCompatibility(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedTableCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedTriggerCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, storeObject: StoreObjectIdentifier, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedViewCompatibility(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSharedViewCompatibility(mappedTypes: IReadOnlyList_1<IEntityType>, viewName: string, schema: string, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateSqlQueries(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateStoredProcedures(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateTriggers(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateTriggers(model: IModel, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
    ValidateValueGeneration(entityType: IEntityType, key: IKey, logger: IDiagnosticsLogger_1<DbLoggerCategory_Model_Validation>): void;
}


export const RelationalModelValidator: {
    new(dependencies: ModelValidatorDependencies, relationalDependencies: RelationalModelValidatorDependencies): RelationalModelValidator;
};


export interface __RelationalModelValidator$views {
    As_IModelValidator(): IModelValidator$instance;
}

export type RelationalModelValidator = RelationalModelValidator$instance & __RelationalModelValidator$views;


export interface RelationalModelValidatorDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalModelValidatorDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalModelValidatorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalModelValidatorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalModelValidatorDependencies: {
    new(typeMappingSource: IRelationalTypeMappingSource): RelationalModelValidatorDependencies;
};


export type RelationalModelValidatorDependencies = RelationalModelValidatorDependencies$instance;

export interface RelationalOptionsExtension$instance extends IDbContextOptionsExtension$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RelationalOptionsExtension: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IDbContextOptionsExtension: never;

    readonly CommandTimeout: Nullable_1<System_Internal.Int32>;
    readonly Connection: DbConnection | undefined;
    readonly ConnectionString: string | undefined;
    readonly ExecutionStrategyFactory: Func_2<ExecutionStrategyDependencies, IExecutionStrategy> | undefined;
    readonly Info: DbContextOptionsExtensionInfo;
    readonly IsConnectionOwned: boolean;
    readonly MaxBatchSize: Nullable_1<System_Internal.Int32>;
    readonly MigrationsAssembly: string | undefined;
    readonly MigrationsAssemblyObject: Assembly | undefined;
    readonly MigrationsHistoryTableName: string | undefined;
    readonly MigrationsHistoryTableSchema: string | undefined;
    readonly MinBatchSize: Nullable_1<System_Internal.Int32>;
    readonly ParameterizedCollectionMode: ParameterTranslationMode;
    readonly QuerySplittingBehavior: Nullable_1<QuerySplittingBehavior>;
    readonly UseRelationalNulls: boolean;
    ApplyServices(services: IServiceCollection): void;
    Clone(): RelationalOptionsExtension;
    Validate(options: IDbContextOptions): void;
    WithCommandTimeout(commandTimeout: Nullable_1<System_Internal.Int32>): RelationalOptionsExtension;
    WithConnection(connection: DbConnection): RelationalOptionsExtension;
    WithConnection(connection: DbConnection, owned: boolean): RelationalOptionsExtension;
    WithConnectionString(connectionString: string): RelationalOptionsExtension;
    WithExecutionStrategyFactory(executionStrategyFactory: Func_2<ExecutionStrategyDependencies, IExecutionStrategy>): RelationalOptionsExtension;
    WithMaxBatchSize(maxBatchSize: Nullable_1<System_Internal.Int32>): RelationalOptionsExtension;
    WithMigrationsAssembly(migrationsAssembly: string): RelationalOptionsExtension;
    WithMigrationsAssembly(migrationsAssembly: Assembly): RelationalOptionsExtension;
    WithMigrationsHistoryTableName(migrationsHistoryTableName: string): RelationalOptionsExtension;
    WithMigrationsHistoryTableSchema(migrationsHistoryTableSchema: string): RelationalOptionsExtension;
    WithMinBatchSize(minBatchSize: Nullable_1<System_Internal.Int32>): RelationalOptionsExtension;
    WithUseParameterizedCollectionMode(parameterizedCollectionMode: ParameterTranslationMode): RelationalOptionsExtension;
    WithUseQuerySplittingBehavior(querySplittingBehavior: QuerySplittingBehavior): RelationalOptionsExtension;
    WithUseRelationalNulls(useRelationalNulls: boolean): RelationalOptionsExtension;
}


export const RelationalOptionsExtension: (abstract new() => RelationalOptionsExtension) & (abstract new(copyFrom: RelationalOptionsExtension) => RelationalOptionsExtension) & {
    Extract(options: IDbContextOptions): RelationalOptionsExtension;
    WithDefaultWarningConfiguration(coreOptionsExtension: CoreOptionsExtension): CoreOptionsExtension;
};


export interface __RelationalOptionsExtension$views {
    As_IDbContextOptionsExtension(): IDbContextOptionsExtension$instance;
}

export type RelationalOptionsExtension = RelationalOptionsExtension$instance & __RelationalOptionsExtension$views;


export interface RuntimeAnnotatableBase$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RuntimeAnnotatableBase: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IAnnotatable: never;
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IReadOnlyAnnotatable: never;

    AddAnnotation(name: string, value: unknown): Annotation;
    AddAnnotations(annotations: IEnumerable_1<IAnnotation>): void;
    AddAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotations(annotations: IEnumerable_1<Annotation>): void;
    AddRuntimeAnnotations(annotations: IReadOnlyDictionary_2<System_Internal.String, unknown>): void;
    CreateAnnotation(name: string, value: unknown): Annotation;
    CreateRuntimeAnnotation(name: string, value: unknown): Annotation;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    GetAnnotation(annotationName: string): Annotation;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func_2<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable_1<Annotation>;
    RemoveAnnotation(name: string): Annotation | undefined;
    RemoveRuntimeAnnotation(name: string): Annotation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetRuntimeAnnotation(name: string, value: unknown): Annotation;
    SetRuntimeAnnotation(name: string, annotation: Annotation, oldAnnotation: Annotation): Annotation;
}


export const RuntimeAnnotatableBase: {
    new(): RuntimeAnnotatableBase;
};


export interface __RuntimeAnnotatableBase$views {
    As_IAnnotatable(): IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): IReadOnlyAnnotatable$instance;
}

export type RuntimeAnnotatableBase = RuntimeAnnotatableBase$instance & __RuntimeAnnotatableBase$views & { [name: string]: unknown | undefined; };


export interface RuntimeModelDependencies$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_RuntimeModelDependencies: never;

    readonly __tsonic_iface_System_IEquatable_1: never;

    ConstructorBindingFactory: IConstructorBindingFactory;
    ParameterBindingFactories: IParameterBindingFactories;
    TypeMappingSource: ITypeMappingSource;
    _Clone_$(): RuntimeModelDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RuntimeModelDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RuntimeModelDependencies: {
    new(typeMappingSource: ITypeMappingSource, constructorBindingFactory: IConstructorBindingFactory, parameterBindingFactories: IParameterBindingFactories): RuntimeModelDependencies;
};


export type RuntimeModelDependencies = RuntimeModelDependencies$instance;

export interface ServiceCollectionMap$instance extends IInfrastructure_1$instance<IInternalServiceCollectionMap> {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ServiceCollectionMap: never;

    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Infrastructure_IInfrastructure_1: never;

    readonly ServiceCollection: IServiceCollection;
    TryAdd(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceCollectionMap;
    TryAdd(serviceType: Type, factory: Func_2<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceCollectionMap;
    TryAddEnumerable(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceCollectionMap;
    TryAddEnumerable(serviceType: Type, implementationType: Type, factory: Func_2<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceCollectionMap;
    TryAddScoped<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddScoped(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddScoped<TService>(factory: Func_2<IServiceProvider, TService>): ServiceCollectionMap;
    TryAddScoped(serviceType: Type, factory: Func_2<IServiceProvider, unknown>): ServiceCollectionMap;
    TryAddScopedEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddScopedEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddScopedEnumerable<TService, TImplementation extends TService>(factory: Func_2<IServiceProvider, TImplementation>): ServiceCollectionMap;
    TryAddSingleton<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddSingleton(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddSingleton<TService>(factory: Func_2<IServiceProvider, TService>): ServiceCollectionMap;
    TryAddSingleton(serviceType: Type, factory: Func_2<IServiceProvider, unknown>): ServiceCollectionMap;
    TryAddSingleton<TService>(implementation: TService): ServiceCollectionMap;
    TryAddSingleton(serviceType: Type, implementation: unknown): ServiceCollectionMap;
    TryAddSingletonEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddSingletonEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddSingletonEnumerable<TService, TImplementation extends TService>(factory: Func_2<IServiceProvider, TImplementation>): ServiceCollectionMap;
    TryAddSingletonEnumerable<TService>(implementation: TService): ServiceCollectionMap;
    TryAddSingletonEnumerable(serviceType: Type, implementation: unknown): ServiceCollectionMap;
    TryAddTransient<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddTransient(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddTransient<TService>(factory: Func_2<IServiceProvider, TService>): ServiceCollectionMap;
    TryAddTransient(serviceType: Type, factory: Func_2<IServiceProvider, unknown>): ServiceCollectionMap;
    TryAddTransientEnumerable<TService, TImplementation extends TService>(): ServiceCollectionMap;
    TryAddTransientEnumerable(serviceType: Type, implementationType: Type): ServiceCollectionMap;
    TryAddTransientEnumerable<TService, TImplementation extends TService>(factory: Func_2<IServiceProvider, TImplementation>): ServiceCollectionMap;
}


export const ServiceCollectionMap: {
    new(serviceCollection: IServiceCollection): ServiceCollectionMap;
};


export interface __ServiceCollectionMap$views {
    As_IInfrastructure_1(): IInfrastructure_1$instance<IInternalServiceCollectionMap>;
}

export type ServiceCollectionMap = ServiceCollectionMap$instance & __ServiceCollectionMap$views;


export interface ServiceProviderAccessor$instance {
    readonly __tsonic_type_Microsoft_EntityFrameworkCore_Infrastructure_ServiceProviderAccessor: never;

    readonly RootServiceProvider: IServiceProvider;
}


export const ServiceProviderAccessor: {
    new(rootServiceProvider: IServiceProvider): ServiceProviderAccessor;
};


export type ServiceProviderAccessor = ServiceProviderAccessor$instance;

export abstract class AccessorExtensions$instance {
    static GetInfrastructure<T>(accessor: IInfrastructure_1<T>): T;
    static GetService(accessor: IInfrastructure_1<IServiceProvider>, serviceType: Type): unknown;
    static GetService<TService>(accessor: IInfrastructure_1<IServiceProvider>): TService;
}


export type AccessorExtensions = AccessorExtensions$instance;

export abstract class EntityFrameworkMetricsData$instance {
    static ReportCompiledQueryCacheHit(): void;
    static ReportCompiledQueryCacheMiss(): void;
    static ReportDbContextDisposing(): void;
    static ReportDbContextInitializing(): void;
    static ReportExecutionStrategyOperationFailure(): void;
    static ReportOptimisticConcurrencyFailure(): void;
    static ReportQueryExecuting(): void;
    static ReportSavingChanges(): void;
}


export type EntityFrameworkMetricsData = EntityFrameworkMetricsData$instance;

export abstract class ExpressionExtensions$instance {
    static readonly ValueBufferTryReadValueMethod: MethodInfo;
    static Assign(memberExpression: MemberExpression, valueExpression: Expression): Expression;
    static CreateEFPropertyExpression(target: Expression, property: IPropertyBase, makeNullable?: boolean): Expression;
    static CreateEFPropertyExpression(target: Expression, propertyDeclaringType: Type, propertyType: Type, propertyName: string, makeNullable: boolean): Expression;
    static CreateEqualsExpression(left: Expression, right: Expression, negated?: boolean): Expression;
    static CreateKeyValuesExpression(target: Expression, properties: IReadOnlyList_1<IProperty>, makeNullable?: boolean): Expression;
    static CreateValueBufferReadValueExpression(valueBuffer: Expression, type: Type, index: int, property: IPropertyBase): Expression;
    static GetMemberAccess(memberAccessExpression: LambdaExpression): MemberInfo;
    static GetMemberAccessList(memberAccessExpression: LambdaExpression): IReadOnlyList_1<MemberInfo>;
    static GetPropertyAccess(propertyAccessExpression: LambdaExpression): PropertyInfo;
    static GetPropertyAccessList(propertyAccessExpression: LambdaExpression): IReadOnlyList_1<PropertyInfo>;
    static IsMemberAccess(expression: Expression, model: IModel, baseExpression: Expression, memberIdentity: MemberIdentity): boolean;
    static IsMemberAccess(expression: Expression, model: IModel, baseExpression: Expression): boolean;
    static MakeMemberAccess(expression: Expression, member: MemberInfo): MemberExpression;
    static Print(expression: Expression, characterLimit?: Nullable_1<System_Internal.Int32>): string;
    static TryGetEFPropertyArguments(methodCallExpression: MethodCallExpression, entityExpression: Expression, propertyName: string): boolean;
    static TryGetIndexerArguments(methodCallExpression: MethodCallExpression, model: IModel, entityExpression: Expression, propertyName: string): boolean;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class LazyLoaderExtensions$instance {
    static Load<TRelated>(loader: ILazyLoader, entity: unknown, navigationField: TRelated, navigationName?: string): TRelated | undefined;
}


export type LazyLoaderExtensions = LazyLoaderExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static IsEFPropertyMethod(methodInfo: MethodInfo): boolean;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ProductInfo$instance {
    static GetVersion(): string;
}


export type ProductInfo = ProductInfo$instance;

export abstract class RelationalModelExtensions$instance {
    static GetRelationalDependencies(model: IModel, methodName?: string): RelationalModelDependencies;
}


export type RelationalModelExtensions = RelationalModelExtensions$instance;

export abstract class RelationalPropertyExtensions$instance {
    static FormatColumns(properties: IEnumerable_1<IReadOnlyProperty>, storeObject: StoreObjectIdentifier): string;
    static GetColumnNames(properties: IEnumerable_1<IReadOnlyProperty>, storeObject: StoreObjectIdentifier): IReadOnlyList_1<System_Internal.String> | undefined;
}


export type RelationalPropertyExtensions = RelationalPropertyExtensions$instance;

export abstract class TypeExtensions$instance {
    static ShortDisplayName(type: Type): string;
}


export type TypeExtensions = TypeExtensions$instance;

export abstract class Uniquifier$instance {
    static Truncate(identifier: string, maxLength: int, uniquifier?: Nullable_1<System_Internal.Int32>): string;
    static Truncate(identifier: string, maxLength: int, suffix: string, uniquifier?: Nullable_1<System_Internal.Int32>): string;
    static Uniquify<TKey, TValue>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary_2<TKey, TValue>, keySelector: Func_2<System_Internal.String, TKey>, maxLength: int): string;
    static Uniquify<TKey, TValue>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary_2<TKey, TValue>, keySelector: Func_2<System_Internal.String, TKey>, suffix: string, maxLength: int): string;
    static Uniquify<T>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary_2<System_Internal.String, T>, maxLength: int): string;
    static Uniquify<T>(currentIdentifier: string, otherIdentifiers: IReadOnlyDictionary_2<System_Internal.String, T>, suffix: string, maxLength: int): string;
    static Uniquify(currentIdentifier: string, otherIdentifiers: ISet_1<System_Internal.String>, suffix: string, maxLength: int): string;
}


export type Uniquifier = Uniquifier$instance;

