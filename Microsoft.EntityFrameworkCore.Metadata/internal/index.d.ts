// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Metadata
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IDependentsMap, IIdentityMap, IInternalEntry, ISnapshot } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { IDependentKeyValueFactory, IDependentKeyValueFactory_1, IPrincipalKeyValueFactory, IPrincipalKeyValueFactory_1, ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { QualifiedName } from "../../Microsoft.EntityFrameworkCore.Design.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { AnnotatableBase, Annotation, DebugView, IAnnotatable, IAnnotation, IReadOnlyAnnotatable, MetadataDebugStringOptions, RuntimeAnnotatableBase, RuntimeModelDependencies } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { ICollectionLoader } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import type { IConventionAnnotatableBuilder, IConventionCheckConstraintBuilder, IConventionComplexPropertyBuilder, IConventionComplexTypeBuilder, IConventionDbFunctionBuilder, IConventionDbFunctionParameterBuilder, IConventionElementTypeBuilder, IConventionEntityTypeBuilder, IConventionEntityTypeMappingFragmentBuilder, IConventionForeignKeyBuilder, IConventionIndexBuilder, IConventionKeyBuilder, IConventionModelBuilder, IConventionNavigationBuilder, IConventionPropertyBuilder, IConventionRelationalPropertyOverridesBuilder, IConventionSequenceBuilder, IConventionServicePropertyBuilder, IConventionSkipNavigationBuilder, IConventionStoredProcedureBuilder, IConventionStoredProcedureParameterBuilder, IConventionStoredProcedureResultColumnBuilder, IConventionTriggerBuilder, IConventionTypeBaseBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { ConventionSet, IConventionBatch } from "../../Microsoft.EntityFrameworkCore.Metadata.Conventions/internal/index.js";
import type { IRuntimeEntityType, IRuntimeTypeBase, PropertyAccessors, PropertyCounts, PropertyIndexes, RuntimeStoredProcedureParameter, RuntimeStoredProcedureResultColumn, TableBase } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import type { ReferentialAction } from "../../Microsoft.EntityFrameworkCore.Migrations/internal/index.js";
import type { SqlExpression } from "../../Microsoft.EntityFrameworkCore.Query.SqlExpressions/internal/index.js";
import type { IStructuralTypeMaterializerSource, StructuralTypeMaterializerSourceParameters } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { JsonValueReaderWriter } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { ValueConverter } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { CoreTypeMapping, MaterializationContext, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { IUpdateEntry } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { ValueGenerator } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import type { ChangeTrackingStrategy, DeleteBehavior, ModelCreationDependencies, PropertyAccessMode, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IComparer, IDictionary, IEnumerable, IEqualityComparer, IList, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList, ISet, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ParameterDirection } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Enum, Func, Guid, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression, ParameterExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, ParameterInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection.js";

export enum ConfigurationSource {
    explicit = 0,
    dataAnnotation = 1,
    convention = 2
}


export enum PropertySaveBehavior {
    save = 0,
    ignore = 1,
    throw_ = 2
}


export enum StoreObjectType {
    table = 0,
    view = 1,
    sqlQuery = 2,
    function_ = 3,
    insertStoredProcedure = 4,
    deleteStoredProcedure = 5,
    updateStoredProcedure = 6
}


export enum ValueGenerated {
    never_ = 0,
    onAdd = 1,
    onUpdate = 2,
    onUpdateSometimes = 4,
    onAddOrUpdate = 3
}


export interface IAdHocMapper$instance {
    getOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export type IAdHocMapper = IAdHocMapper$instance;

export interface ICheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IAnnotatable {
    readonly entityType: IEntityType;
    readonly modelName: string;
    readonly name: string;
    readonly sql: string;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDefaultName(): string | undefined;
    getName(storeObject: StoreObjectIdentifier): string | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ICheckConstraint = ICheckConstraint$instance;

export interface IClrCollectionAccessor$instance {
    readonly collectionType: Type;
    add(entity: unknown, value: unknown, forMaterialization: boolean): boolean;
    contains(entity: unknown, value: unknown): boolean;
    create(): unknown;
    getOrCreate(entity: unknown, forMaterialization: boolean): unknown;
}


export type IClrCollectionAccessor = IClrCollectionAccessor$instance;

export interface IClrIndexedCollectionAccessor$instance {
    create(capacity: int): unknown;
    get_(entity: unknown, index: int): unknown | undefined;
    set_(entity: unknown, index: int, value: unknown, forMaterialization: boolean): void;
}


export type IClrIndexedCollectionAccessor = IClrIndexedCollectionAccessor$instance;

export interface IClrPropertyGetter$instance {
    getClrValueUsingContainingEntity(entity: unknown, indices: IReadOnlyList<System_Internal.Int32>): unknown | undefined;
    getClrValueUsingContainingEntity(entity: unknown): unknown | undefined;
    hasSentinelValueUsingContainingEntity(entity: unknown, indices: IReadOnlyList<System_Internal.Int32>): boolean;
    hasSentinelValueUsingContainingEntity(entity: unknown): boolean;
}


export type IClrPropertyGetter = IClrPropertyGetter$instance;

export interface IClrPropertySetter$instance {
    setClrValue(instance: unknown, value: unknown): unknown;
    setClrValueUsingContainingEntity(instance: unknown, indices: IReadOnlyList<System_Internal.Int32>, value: unknown): void;
    setClrValueUsingContainingEntity(instance: unknown, value: unknown): void;
}


export type IClrPropertySetter = IClrPropertySetter$instance;

export interface IColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly table: ITable;
    readonly propertyMappings: IReadOnlyList<IColumnMapping>;
    readonly maxLength: Nullable<System_Internal.Int32>;
    readonly precision: Nullable<System_Internal.Int32>;
    readonly scale: Nullable<System_Internal.Int32>;
    readonly isUnicode: Nullable<System_Internal.Boolean>;
    readonly isFixedLength: Nullable<System_Internal.Boolean>;
    readonly isRowVersion: boolean;
    readonly order: Nullable<System_Internal.Int32>;
    readonly defaultValue: unknown | undefined;
    readonly defaultValueSql: string | undefined;
    readonly computedColumnSql: string | undefined;
    readonly isStored: Nullable<System_Internal.Boolean>;
    readonly comment: string | undefined;
    readonly collation: string | undefined;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMapping | undefined;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    tryGetDefaultValue(defaultValue: unknown): boolean;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumn = IColumn$instance;

export interface IColumnBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly propertyMappings: IReadOnlyList<IColumnMappingBase>;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnBase = IColumnBase$instance;

export interface IColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly column: IColumn;
    readonly tableMapping: ITableMapping;
    readonly property: IProperty;
    readonly typeMapping: RelationalTypeMapping;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnMapping = IColumnMapping$instance;

export interface IColumnMappingBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly property: IProperty;
    readonly column: IColumnBase;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnMappingBase = IColumnMappingBase$instance;

export interface IComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly complexType: IComplexType;
    readonly isNullable: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IComplexProperty = IComplexProperty$instance;

export interface IComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, ITypeBase, IAnnotatable {
    readonly complexProperty: IComplexProperty;
    readonly baseType: IComplexType | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    readonly constructorBinding: InstantiationBinding | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    findComplexProperty(name: string): IComplexProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findDiscriminatorProperty(): IProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMember(name: string): IPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findProperty(memberInfo: MemberInfo): IProperty | undefined;
    findProperty(name: string): IProperty | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IComplexType>;
    getDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDerivedTypes(): IEnumerable<ITypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyComplexType;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isContainedBy(type_: Type): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findComplexProperty2(name: string): IComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IComplexProperty | undefined;
    findDiscriminatorProperty2(): IProperty | undefined;
    findMember2(name: string): IPropertyBase | undefined;
    findProperty2(name: string): IProperty | undefined;
    findProperty3(memberInfo: MemberInfo): IProperty | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRootType2(): IReadOnlyTypeBase;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IComplexType = IComplexType$instance;

export interface IConstructorBindingFactory$instance {
    getBindings(entityType: IConventionEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    getBindings(entityType: IMutableEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    getBindings(complexType: IReadOnlyComplexType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    getBindings(entityType: IReadOnlyEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    tryBindConstructor(entityType: IConventionEntityType, constructor_: ConstructorInfo, binding: InstantiationBinding, unboundParameters: IEnumerable<ParameterInfo>): boolean;
    tryBindConstructor(entityType: IMutableEntityType, constructor_: ConstructorInfo, binding: InstantiationBinding, unboundParameters: IEnumerable<ParameterInfo>): boolean;
}


export type IConstructorBindingFactory = IConstructorBindingFactory$instance;

export interface IConventionAnnotatable$instance extends IReadOnlyAnnotatable {
    readonly builder: IConventionAnnotatableBuilder;
    readonly isInModel: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IConventionAnnotatable = IConventionAnnotatable$instance;

export interface IConventionAnnotation$instance extends IAnnotation {
    readonly name: string;
    readonly value: unknown | undefined;
    getConfigurationSource(): ConfigurationSource;
}


export interface IConventionAnnotation$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotation$instance {}

export type IConventionAnnotation = IConventionAnnotation$instance;

export interface IConventionCheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionCheckConstraintBuilder;
    readonly entityType: IConventionEntityType;
    readonly modelName: string;
    readonly name: string;
    readonly sql: string;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getDefaultName(): string | undefined;
    getName(storeObject: StoreObjectIdentifier): string | undefined;
    getNameConfigurationSource(): Nullable<ConfigurationSource>;
    setName(name: string, fromDataAnnotation?: boolean): string;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionCheckConstraint = IConventionCheckConstraint$instance;

export interface IConventionComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly builder: IConventionComplexPropertyBuilder;
    readonly complexType: IConventionComplexType;
    readonly isNullable: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldName(): string | undefined;
    getIsNullableConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionComplexProperty = IConventionComplexProperty$instance;

export interface IConventionComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionTypeBase, IConventionAnnotatable {
    readonly builder: IConventionComplexTypeBuilder;
    readonly complexProperty: IConventionComplexProperty;
    readonly baseType: IConventionComplexType | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    addProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    findComplexProperty(name: string): IConventionComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IConventionProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IConventionPropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    findProperty(name: string): IConventionProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IConventionComplexType>;
    getDerivedTypes(): IEnumerable<IConventionTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    getDiscriminatorValue(): unknown | undefined;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IConventionComplexType;
    getRootType(): IConventionTypeBase;
    getRootType(): IReadOnlyComplexType;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isContainedBy(type_: Type): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    removeIgnored(memberName: string): string | undefined;
    removeProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    setBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
    setDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    setDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    findComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    findMember2(name: string): IReadOnlyPropertyBase | undefined;
    findProperty2(name: string): IReadOnlyProperty | undefined;
    findProperty3(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getRootType2(): IReadOnlyTypeBase;
    removeDiscriminatorValue(): unknown | undefined;
}


export type IConventionComplexType = IConventionComplexType$instance;

export interface IConventionDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly model: IConventionModel;
    readonly builder: IConventionDbFunctionBuilder;
    readonly parameters: IReadOnlyList<IConventionDbFunctionParameter>;
    readonly name: string;
    readonly schema: string;
    readonly modelName: string;
    readonly methodInfo: MethodInfo | undefined;
    readonly isBuiltIn: boolean;
    readonly isScalar: boolean;
    readonly isAggregate: boolean;
    readonly isNullable: boolean;
    readonly storeType: string;
    readonly returnType: Type;
    readonly typeMapping: RelationalTypeMapping;
    readonly translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getNameConfigurationSource(): Nullable<ConfigurationSource>;
    setIsBuiltIn(builtIn: boolean, fromDataAnnotation?: boolean): boolean;
    setName(name: string, fromDataAnnotation?: boolean): string;
    setTranslation(translation: Func<IReadOnlyList<SqlExpression>, SqlExpression>, fromDataAnnotation?: boolean): Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    setTypeMapping(typeMapping: RelationalTypeMapping, fromDataAnnotation?: boolean): RelationalTypeMapping | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionDbFunction = IConventionDbFunction$instance;

export interface IConventionDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly function_: IConventionDbFunction;
    readonly builder: IConventionDbFunctionParameterBuilder;
    readonly name: string;
    readonly clrType: Type;
    readonly storeType: string;
    readonly propagatesNullability: boolean;
    readonly typeMapping: RelationalTypeMapping;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getStoreTypeConfigurationSource(): Nullable<ConfigurationSource>;
    setStoreType(storeType: string, fromDataAnnotation?: boolean): string | undefined;
    setTypeMapping(typeMapping: RelationalTypeMapping, fromDataAnnotation?: boolean): RelationalTypeMapping | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionDbFunctionParameter = IConventionDbFunctionParameter$instance;

export interface IConventionElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly collectionProperty: IConventionProperty;
    readonly builder: IConventionElementTypeBuilder;
    readonly clrType: Type;
    readonly isNullable: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getIsNullableConfigurationSource(): Nullable<ConfigurationSource>;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    setIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    setTypeMapping(typeMapping: CoreTypeMapping, fromDataAnnotation?: boolean): CoreTypeMapping | undefined;
    setValueComparer(comparer: ValueComparer, fromDataAnnotation?: boolean): ValueComparer | undefined;
    setValueConverter(converter: ValueConverter, fromDataAnnotation?: boolean): ValueConverter | undefined;
    setValueConverter(converterType: Type, fromDataAnnotation?: boolean): Type | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
}


export type IConventionElementType = IConventionElementType$instance;

export interface IConventionEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionTypeBase, IConventionAnnotatable {
    readonly builder: IConventionEntityTypeBuilder;
    readonly baseType: IConventionEntityType | undefined;
    readonly isKeyless: boolean;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addForeignKey(property: IConventionProperty, principalKey: IConventionKey, principalEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    addForeignKey(properties: IReadOnlyList<IConventionProperty>, principalKey: IConventionKey, principalEntityType: IConventionEntityType, setComponentConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    addIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    addIndex(property: IConventionProperty, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    addIndex(property: IConventionProperty, name: string, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    addIndex(properties: IReadOnlyList<IConventionProperty>, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    addIndex(properties: IReadOnlyList<IConventionProperty>, name: string, fromDataAnnotation?: boolean): IConventionIndex;
    addProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addServiceProperty(memberInfo: MemberInfo, serviceType?: Type, fromDataAnnotation?: boolean): IConventionServiceProperty;
    addSkipNavigation(name: string, navigationType: Type, memberInfo: MemberInfo, targetEntityType: IConventionEntityType, collection: boolean, onDependent: boolean, fromDataAnnotation?: boolean): IConventionSkipNavigation | undefined;
    addTrigger(name: string, fromDataAnnotation?: boolean): IConventionTrigger | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IConventionEntityType | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    findComplexProperty(name: string): IConventionComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    findDeclaredTrigger(name: string): IConventionTrigger | undefined;
    findDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    findDiscriminatorProperty(): IConventionProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IConventionForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IConventionForeignKey | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IConventionForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IConventionForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    findIndex(property: IReadOnlyProperty): IConventionIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IConventionIndex | undefined;
    findIndex(name: string): IConventionIndex | undefined;
    findIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    findIndex(name: string): IReadOnlyIndex | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findKey(property: IReadOnlyProperty): IConventionKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IConventionKey | undefined;
    findKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    findMember(name: string): IConventionPropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    findNavigation(memberInfo: MemberInfo): IConventionNavigation | undefined;
    findNavigation(name: string): IConventionNavigation | undefined;
    findNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    findNavigation(name: string): IReadOnlyNavigation | undefined;
    findOwnership(): IConventionForeignKey | undefined;
    findOwnership(): IReadOnlyForeignKey | undefined;
    findPrimaryKey(): IConventionKey | undefined;
    findPrimaryKey(): IReadOnlyKey | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    findProperty(name: string): IConventionProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findServiceProperty(name: string): IConventionServiceProperty | undefined;
    findServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IConventionSkipNavigation | undefined;
    findSkipNavigation(name: string): IConventionSkipNavigation | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    findSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    getAllBaseTypes(): IEnumerable<IConventionEntityType>;
    getAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getConfigurationSource(): ConfigurationSource;
    getDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    getDiscriminatorValue(): unknown | undefined;
    getIsDiscriminatorMappingComplete(): boolean;
    getNavigationAccessMode(): PropertyAccessMode;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getQueryFilter(): LambdaExpression | undefined;
    getQueryFilterConfigurationSource(): Nullable<ConfigurationSource>;
    getQueryFilterConfigurationSource(filterKey: string): Nullable<ConfigurationSource>;
    getRootType(): IConventionEntityType;
    getRootType(): IConventionTypeBase;
    getRootType(): IReadOnlyEntityType;
    getRootType(): IReadOnlyTypeBase;
    getSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    isAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    removeForeignKey(foreignKey: IReadOnlyForeignKey): IConventionForeignKey | undefined;
    removeForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IConventionKey, principalEntityType: IConventionEntityType): IConventionForeignKey | undefined;
    removeIgnored(memberName: string): string | undefined;
    removeIndex(index: IReadOnlyIndex): IConventionIndex | undefined;
    removeKey(key: IReadOnlyKey): IConventionKey | undefined;
    removeProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    removeServiceProperty(property: IReadOnlyServiceProperty): IConventionServiceProperty | undefined;
    removeSkipNavigation(navigation: IReadOnlySkipNavigation): IConventionSkipNavigation | undefined;
    setBaseType(entityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    setBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    setDiscriminatorMappingComplete(complete: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    setDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    setDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    setPrimaryKey(property: IConventionProperty, fromDataAnnotation?: boolean): IConventionKey | undefined;
    setPrimaryKey(properties: IReadOnlyList<IConventionProperty>, fromDataAnnotation?: boolean): IConventionKey | undefined;
    setQueryFilter(queryFilter: LambdaExpression, fromDataAnnotation?: boolean): LambdaExpression | undefined;
    setQueryFilter(filterKey: string, filter: LambdaExpression, fromDataAnnotation?: boolean): IQueryFilter | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    findComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    findIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    findMember2(name: string): IReadOnlyPropertyBase | undefined;
    findProperty2(name: string): IReadOnlyProperty | undefined;
    findProperty3(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getDerivedTypes(): IEnumerable<IConventionTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType2(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    removeDiscriminatorValue(): unknown | undefined;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
}


export type IConventionEntityType = IConventionEntityType$instance;

export interface IConventionEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly entityType: IConventionEntityType;
    readonly builder: IConventionEntityTypeMappingFragmentBuilder;
    readonly storeObject: StoreObjectIdentifier;
    readonly isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getIsTableExcludedFromMigrationsConfigurationSource(): Nullable<ConfigurationSource>;
    setIsTableExcludedFromMigrations(excluded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionEntityTypeMappingFragment = IConventionEntityTypeMappingFragment$instance;

export interface IConventionForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionForeignKeyBuilder;
    readonly properties: IReadOnlyList<IConventionProperty>;
    readonly principalKey: IConventionKey;
    readonly declaringEntityType: IConventionEntityType;
    readonly principalEntityType: IConventionEntityType;
    readonly dependentToPrincipal: IConventionNavigation | undefined;
    readonly principalToDependent: IConventionNavigation | undefined;
    readonly isUnique: boolean;
    readonly isRequired: boolean;
    readonly isRequiredDependent: boolean;
    readonly isOwnership: boolean;
    readonly deleteBehavior: DeleteBehavior;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getConfigurationSource(): ConfigurationSource;
    getNavigation(pointsToPrincipal: boolean): IConventionNavigation | undefined;
    getNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    getPropertiesConfigurationSource(): Nullable<ConfigurationSource>;
    getReferencingSkipNavigations(): IEnumerable<IConventionSkipNavigation>;
    getReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IConventionEntityType;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    isBaseLinking(): boolean;
    setDependentToPrincipal(property: MemberInfo, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    setDependentToPrincipal(name: string, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    setIsUnique(unique: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    setProperties(properties: IReadOnlyList<IConventionProperty>, principalKey: IConventionKey, fromDataAnnotation?: boolean): IReadOnlyList<IConventionProperty>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
}


export type IConventionForeignKey = IConventionForeignKey$instance;

export interface IConventionIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionIndexBuilder;
    readonly properties: IReadOnlyList<IConventionProperty>;
    readonly declaringEntityType: IConventionEntityType;
    readonly name: string;
    readonly isUnique: boolean;
    readonly isDescending: IReadOnlyList<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getIsUniqueConfigurationSource(): Nullable<ConfigurationSource>;
    setIsDescending(descending: IReadOnlyList<System_Internal.Boolean>, fromDataAnnotation?: boolean): IReadOnlyList<System_Internal.Boolean> | undefined;
    setIsUnique(unique: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionIndex = IConventionIndex$instance;

export interface IConventionKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionKeyBuilder;
    readonly properties: IReadOnlyList<IConventionProperty>;
    readonly declaringEntityType: IConventionEntityType;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getConfigurationSource(): ConfigurationSource;
    getReferencingForeignKeys(): IEnumerable<IConventionForeignKey>;
    getReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    isPrimaryKey(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
}


export type IConventionKey = IConventionKey$instance;

export interface IConventionModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionModelBuilder;
    readonly modelId: Guid;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    addEntityType(name: string, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    addEntityType(name: string, definingNavigationName: string, definingEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    addEntityType(name: string, clrType: Type, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    addEntityType(type_: Type, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    addEntityType(type_: Type, definingNavigationName: string, definingEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    addIgnored(type_: Type, fromDataAnnotation?: boolean): string | undefined;
    addShared(type_: Type, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    delayConventions(): IConventionBatch;
    finalizeModel(): IModel;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IConventionEntityType): IConventionEntityType | undefined;
    findEntityType(name: string): IConventionEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IConventionEntityType): IConventionEntityType | undefined;
    findEntityType(type_: Type): IConventionEntityType | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(name: string): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type): IReadOnlyEntityType | undefined;
    findEntityTypes(type_: Type): IEnumerable<IConventionEntityType>;
    findEntityTypes(type_: Type): IEnumerable<IReadOnlyEntityType>;
    findIgnoredConfigurationSource(typeName: string): Nullable<ConfigurationSource>;
    findIsSharedConfigurationSource(type_: Type): Nullable<ConfigurationSource>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IConventionEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getEmbeddedDiscriminatorName(): string;
    getEntityTypes(): IEnumerable<IConventionEntityType>;
    getEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    getPropertyAccessMode(): PropertyAccessMode;
    getPropertyAccessModeConfigurationSource(): Nullable<ConfigurationSource>;
    isIgnored(typeName: string): boolean;
    isOwned(type_: Type): boolean;
    removeEntityType(entityType: IConventionEntityType): IConventionEntityType | undefined;
    removeIgnored(typeName: string): string | undefined;
    removeOwned(type_: Type): string | undefined;
    removeShared(type_: Type): Type | undefined;
    setEmbeddedDiscriminatorName(name: string, fromDataAnnotation?: boolean): string | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    isShared(type_: Type): boolean;
}


export type IConventionModel = IConventionModel$instance;

export interface IConventionNavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionNavigationBase, IConventionPropertyBase, IConventionAnnotatable {
    readonly builder: IConventionNavigationBuilder;
    readonly declaringEntityType: IConventionEntityType;
    readonly targetEntityType: IConventionEntityType;
    readonly foreignKey: IConventionForeignKey;
    readonly inverse: IConventionNavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldName(): string | undefined;
    getInverseConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setInverse(inverse: MemberInfo, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    setInverse(inverseName: string, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    getIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionNavigation = IConventionNavigation$instance;

export interface IConventionNavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly targetEntityType: IConventionEntityType;
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly inverse: IReadOnlyNavigationBase;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly builder: IConventionAnnotatableBuilder;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldName(): string | undefined;
    getIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionNavigationBase = IConventionNavigationBase$instance;

export interface IConventionProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly builder: IConventionPropertyBuilder;
    readonly declaringEntityType: IConventionEntityType;
    readonly isNullable: boolean;
    readonly valueGenerated: ValueGenerated;
    readonly isConcurrencyToken: boolean;
    readonly isPrimitiveCollection: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findContainingPrimaryKey(): IConventionKey | undefined;
    findContainingPrimaryKey(): IReadOnlyKey | undefined;
    findFirstPrincipal(): IConventionProperty | undefined;
    findFirstPrincipal(): IReadOnlyProperty | undefined;
    getBeforeSaveBehavior(): PropertySaveBehavior;
    getConfigurationSource(): ConfigurationSource;
    getContainingForeignKeys(): IEnumerable<IConventionForeignKey>;
    getContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    getElementType(): IConventionElementType | undefined;
    getElementType(): IReadOnlyElementType | undefined;
    getFieldName(): string | undefined;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getPrincipals(): IReadOnlyList<IConventionProperty>;
    getPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    getPropertyAccessMode(): PropertyAccessMode;
    getProviderClrType(): Type | undefined;
    getTypeConfigurationSource(): Nullable<ConfigurationSource>;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    getValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    isImplicitlyCreated(): boolean;
    setElementType(elementType: Type, fromDataAnnotation?: boolean): IConventionElementType | undefined;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    setSentinel(sentinel: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    setTypeMapping(typeMapping: CoreTypeMapping, fromDataAnnotation?: boolean): CoreTypeMapping | undefined;
    setValueComparer(comparer: ValueComparer, fromDataAnnotation?: boolean): ValueComparer | undefined;
    setValueConverter(converter: ValueConverter, fromDataAnnotation?: boolean): ValueConverter | undefined;
    setValueGeneratorFactory(valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>, fromDataAnnotation?: boolean): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    setValueGeneratorFactory(valueGeneratorFactory: Type, fromDataAnnotation?: boolean): Type | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    getMaxLength(): Nullable<System_Internal.Int32>;
    isForeignKey(): boolean;
    isShadowProperty(): boolean;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionProperty = IConventionProperty$instance;

export interface IConventionPropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly declaringType: IConventionTypeBase;
    readonly name: string;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly builder: IConventionAnnotatableBuilder;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionPropertyBase = IConventionPropertyBase$instance;

export interface IConventionRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly property: IConventionProperty;
    readonly builder: IConventionRelationalPropertyOverridesBuilder;
    readonly storeObject: StoreObjectIdentifier;
    readonly columnName: string;
    readonly isColumnNameOverridden: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getColumnNameConfigurationSource(): Nullable<ConfigurationSource>;
    getConfigurationSource(): ConfigurationSource;
    removeColumnNameOverride(fromDataAnnotation?: boolean): boolean;
    setColumnName(name: string, fromDataAnnotation?: boolean): string | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionRelationalPropertyOverrides = IConventionRelationalPropertyOverrides$instance;

export interface IConventionSequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly model: IConventionModel;
    readonly builder: IConventionSequenceBuilder;
    readonly name: string;
    readonly modelSchema: string | undefined;
    readonly schema: string;
    readonly startValue: long;
    readonly incrementBy: int;
    readonly minValue: Nullable<System_Internal.Int64>;
    readonly maxValue: Nullable<System_Internal.Int64>;
    readonly type_: Type;
    readonly isCyclic: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getStartValueConfigurationSource(): Nullable<ConfigurationSource>;
    setStartValue(startValue: Nullable<System_Internal.Int64>, fromDataAnnotation?: boolean): Nullable<System_Internal.Int64>;
    setType(type_: Type, fromDataAnnotation?: boolean): Type | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionSequence = IConventionSequence$instance;

export interface IConventionServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly builder: IConventionServicePropertyBuilder;
    readonly declaringEntityType: IConventionEntityType;
    readonly parameterBinding: ServiceParameterBinding;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldName(): string | undefined;
    getParameterBindingConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setParameterBinding(parameterBinding: ServiceParameterBinding, fromDataAnnotation?: boolean): ServiceParameterBinding | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
}


export type IConventionServiceProperty = IConventionServiceProperty$instance;

export interface IConventionSkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionNavigationBase, IConventionPropertyBase, IConventionAnnotatable {
    readonly builder: IConventionSkipNavigationBuilder;
    readonly declaringEntityType: IConventionEntityType;
    readonly targetEntityType: IConventionEntityType;
    readonly joinEntityType: IConventionEntityType;
    readonly foreignKey: IConventionForeignKey;
    readonly inverse: IConventionSkipNavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getFieldName(): string | undefined;
    getForeignKeyConfigurationSource(): Nullable<ConfigurationSource>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    setForeignKey(foreignKey: IConventionForeignKey, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    setInverse(inverse: IConventionSkipNavigation, fromDataAnnotation?: boolean): IConventionSkipNavigation | undefined;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    getIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionSkipNavigation = IConventionSkipNavigation$instance;

export interface IConventionStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly entityType: IConventionEntityType;
    readonly builder: IConventionStoredProcedureBuilder;
    readonly parameters: IReadOnlyList<IConventionStoredProcedureParameter>;
    readonly resultColumns: IReadOnlyList<IConventionStoredProcedureResultColumn>;
    readonly name: string;
    readonly schema: string;
    readonly isRowsAffectedReturned: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    addParameter(propertyName: string, fromDataAnnotation?: boolean): IConventionStoredProcedureParameter | undefined;
    addResultColumn(propertyName: string, fromDataAnnotation?: boolean): IConventionStoredProcedureResultColumn | undefined;
    addRowsAffectedParameter(fromDataAnnotation?: boolean): IConventionStoredProcedureParameter | undefined;
    addRowsAffectedResultColumn(fromDataAnnotation?: boolean): IConventionStoredProcedureResultColumn | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findParameter(propertyName: string): IConventionStoredProcedureParameter | undefined;
    findParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    findResultColumn(propertyName: string): IConventionStoredProcedureResultColumn | undefined;
    findResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    findRowsAffectedParameter(): IConventionStoredProcedureParameter | undefined;
    findRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    findRowsAffectedResultColumn(): IConventionStoredProcedureResultColumn | undefined;
    findRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    getNameConfigurationSource(): Nullable<ConfigurationSource>;
    getSchemaQualifiedName(): string | undefined;
    setIsRowsAffectedReturned(rowsAffectedReturned: boolean, fromDataAnnotation?: boolean): boolean;
    setName(name: string, fromDataAnnotation?: boolean): string;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getStoreIdentifier(): Nullable<StoreObjectIdentifier>;
}


export type IConventionStoredProcedure = IConventionStoredProcedure$instance;

export interface IConventionStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly storedProcedure: IConventionStoredProcedure;
    readonly builder: IConventionStoredProcedureParameterBuilder;
    readonly name: string;
    readonly propertyName: string;
    readonly direction: ParameterDirection;
    readonly forOriginalValue: Nullable<System_Internal.Boolean>;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getNameConfigurationSource(): Nullable<ConfigurationSource>;
    setDirection(direction: ParameterDirection, fromDataAnnotation?: boolean): ParameterDirection;
    setName(name: string, fromDataAnnotation?: boolean): string;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionStoredProcedureParameter = IConventionStoredProcedureParameter$instance;

export interface IConventionStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly storedProcedure: IConventionStoredProcedure;
    readonly builder: IConventionStoredProcedureResultColumnBuilder;
    readonly name: string;
    readonly propertyName: string;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getNameConfigurationSource(): Nullable<ConfigurationSource>;
    setName(name: string, fromDataAnnotation?: boolean): string;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionStoredProcedureResultColumn = IConventionStoredProcedureResultColumn$instance;

export interface IConventionTrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly builder: IConventionTriggerBuilder;
    readonly entityType: IConventionEntityType;
    readonly modelName: string;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getConfigurationSource(): ConfigurationSource;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionTrigger = IConventionTrigger$instance;

export interface IConventionTypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly model: IConventionModel;
    readonly builder: IConventionTypeBaseBuilder;
    readonly containingEntityType: IConventionEntityType;
    readonly baseType: IConventionTypeBase | undefined;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    readonly isInModel: boolean;
    addAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    addAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    addIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    addProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): IConventionAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    findComplexProperty(name: string): IConventionComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IConventionProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IConventionPropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    findProperty(name: string): IConventionProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IConventionTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IConventionTypeBase;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    removeDiscriminatorValue(): unknown | undefined;
    removeIgnored(memberName: string): string | undefined;
    removeProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    setBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
    setDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    setDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    findAnnotation2(name: string): IConventionAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getAnnotations(): IEnumerable<IConventionAnnotation>;
    getDiscriminatorValue(): unknown | undefined;
}


export type IConventionTypeBase = IConventionTypeBase$instance;

export interface IDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IAnnotatable {
    readonly model: IModel;
    readonly parameters: IReadOnlyList<IDbFunctionParameter>;
    readonly storeFunction: IStoreFunction;
    readonly name: string;
    readonly schema: string;
    readonly modelName: string;
    readonly methodInfo: MethodInfo | undefined;
    readonly isBuiltIn: boolean;
    readonly isScalar: boolean;
    readonly isAggregate: boolean;
    readonly isNullable: boolean;
    readonly storeType: string;
    readonly returnType: Type;
    readonly typeMapping: RelationalTypeMapping;
    readonly translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IDbFunction = IDbFunction$instance;

export interface IDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IAnnotatable {
    readonly storeType: string;
    readonly function_: IDbFunction;
    readonly storeFunctionParameter: IStoreFunctionParameter;
    readonly name: string;
    readonly clrType: Type;
    readonly propagatesNullability: boolean;
    readonly typeMapping: RelationalTypeMapping;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IDbFunctionParameter = IDbFunctionParameter$instance;

export interface IDesignTimeModel$instance {
    readonly model: IModel;
}


export type IDesignTimeModel = IDesignTimeModel$instance;

export interface IElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IAnnotatable {
    readonly collectionProperty: IProperty;
    readonly clrType: Type;
    readonly isNullable: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IElementType = IElementType$instance;

export interface IEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, ITypeBase, IAnnotatable {
    readonly baseType: IEntityType | undefined;
    readonly serviceOnlyConstructorBinding: InstantiationBinding | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    readonly constructorBinding: InstantiationBinding | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findClosestCommonParent(otherEntityType: IEntityType): IEntityType | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    findComplexProperty(name: string): IComplexProperty | undefined;
    findDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    findDeclaredTrigger(name: string): ITrigger | undefined;
    findDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findDiscriminatorProperty(): IProperty | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IForeignKey | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    findIndex(property: IReadOnlyProperty): IIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IIndex | undefined;
    findIndex(name: string): IIndex | undefined;
    findIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    findIndex(name: string): IReadOnlyIndex | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findKey(property: IReadOnlyProperty): IKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IKey | undefined;
    findKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMember(name: string): IPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    findNavigation(memberInfo: MemberInfo): INavigation | undefined;
    findNavigation(name: string): INavigation | undefined;
    findNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    findNavigation(name: string): IReadOnlyNavigation | undefined;
    findOwnership(): IForeignKey | undefined;
    findOwnership(): IReadOnlyForeignKey | undefined;
    findPrimaryKey(): IKey | undefined;
    findPrimaryKey(): IReadOnlyKey | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IProperty | undefined;
    findProperty(name: string): IProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    findServiceProperty(name: string): IServiceProperty | undefined;
    findServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    findSkipNavigation(memberInfo: MemberInfo): ISkipNavigation | undefined;
    findSkipNavigation(name: string): ISkipNavigation | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    findSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    getAllBaseTypes(): IEnumerable<IEntityType>;
    getAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    getDiscriminatorValue(): unknown | undefined;
    getIsDiscriminatorMappingComplete(): boolean;
    getNavigationAccessMode(): PropertyAccessMode;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getQueryFilter(): LambdaExpression | undefined;
    getRootType(): IEntityType;
    getRootType(): IReadOnlyEntityType;
    getRootType(): IReadOnlyTypeBase;
    getSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    isAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findComplexProperty2(name: string): IComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IComplexProperty | undefined;
    findDiscriminatorProperty2(): IProperty | undefined;
    findMember2(name: string): IPropertyBase | undefined;
    findProperty2(name: string): IProperty | undefined;
    findProperty3(memberInfo: MemberInfo): IProperty | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDerivedTypes(): IEnumerable<ITypeBase>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType2(): IReadOnlyTypeBase;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isAbstract(): boolean;
}


export type IEntityType = IEntityType$instance;

export interface IEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IAnnotatable {
    readonly entityType: IEntityType;
    readonly storeObject: StoreObjectIdentifier;
    readonly isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IEntityTypeMappingFragment = IEntityTypeMappingFragment$instance;

export interface IForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IAnnotatable {
    readonly properties: IReadOnlyList<IProperty>;
    readonly principalKey: IKey;
    readonly declaringEntityType: IEntityType;
    readonly principalEntityType: IEntityType;
    readonly dependentToPrincipal: INavigation | undefined;
    readonly principalToDependent: INavigation | undefined;
    readonly isUnique: boolean;
    readonly isRequired: boolean;
    readonly isRequiredDependent: boolean;
    readonly isOwnership: boolean;
    readonly deleteBehavior: DeleteBehavior;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getDependentKeyValueFactory<TKey>(): IDependentKeyValueFactory_1<TKey>;
    getDependentKeyValueFactory(): IDependentKeyValueFactory;
    getNavigation(pointsToPrincipal: boolean): INavigation | undefined;
    getNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getReferencingSkipNavigations(): IEnumerable<ISkipNavigation>;
    getReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IEntityType;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    isBaseLinking(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IForeignKey = IForeignKey$instance;

export interface IForeignKeyConstraint$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly mappedForeignKeys: IEnumerable<IForeignKey>;
    readonly table: ITable;
    readonly principalTable: ITable;
    readonly columns: IReadOnlyList<IColumn>;
    readonly principalColumns: IReadOnlyList<IColumn>;
    readonly principalUniqueConstraint: IUniqueConstraint;
    readonly onDeleteAction: ReferentialAction;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IForeignKeyConstraint = IForeignKeyConstraint$instance;

export interface IFunctionColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly function_: IStoreFunction;
    readonly propertyMappings: IReadOnlyList<IFunctionColumnMapping>;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findColumnMapping(entityType: IReadOnlyEntityType): IFunctionColumnMapping | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionColumn = IFunctionColumn$instance;

export interface IFunctionColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly column: IFunctionColumn;
    readonly functionMapping: IFunctionMapping;
    readonly property: IProperty;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionColumnMapping = IFunctionColumnMapping$instance;

export interface IFunctionMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly isDefaultFunctionMapping: boolean;
    readonly storeFunction: IStoreFunction;
    readonly dbFunction: IDbFunction;
    readonly columnMappings: IEnumerable<IFunctionColumnMapping>;
    readonly typeBase: ITypeBase;
    readonly table: ITableBase;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionMapping = IFunctionMapping$instance;

export interface IIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IAnnotatable {
    readonly properties: IReadOnlyList<IProperty>;
    readonly declaringEntityType: IEntityType;
    readonly name: string;
    readonly isUnique: boolean;
    readonly isDescending: IReadOnlyList<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getNullableValueFactory<TKey>(): IDependentKeyValueFactory_1<TKey>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IIndex = IIndex$instance;

export interface IKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IAnnotatable {
    readonly properties: IReadOnlyList<IProperty>;
    readonly declaringEntityType: IEntityType;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getKeyType(): Type;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPrincipalKeyValueFactory<TKey>(): IPrincipalKeyValueFactory_1<TKey>;
    getPrincipalKeyValueFactory(): IPrincipalKeyValueFactory;
    getReferencingForeignKeys(): IEnumerable<IForeignKey>;
    getReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    isPrimaryKey(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IKey = IKey$instance;

export interface IMetadataReference_1$instance<T> extends IDisposable {
    readonly object_: T;
}


export type IMetadataReference_1<T> = IMetadataReference_1$instance<T>;

export interface IModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IAnnotatable {
    get modelDependencies(): RuntimeModelDependencies | undefined;
    set modelDependencies(value: RuntimeModelDependencies);
    readonly modelId: Guid;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IEntityType): IEntityType | undefined;
    findEntityType(name: string): IEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IEntityType): IEntityType | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(name: string): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type): IReadOnlyEntityType | undefined;
    findEntityTypes(type_: Type): IEnumerable<IEntityType>;
    findEntityTypes(type_: Type): IEnumerable<IReadOnlyEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    findRuntimeEntityType(type_: Type): IEntityType | undefined;
    findTypeMappingConfiguration(scalarType: Type): ITypeMappingConfiguration | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getEmbeddedDiscriminatorName(): string;
    getEntityTypes(): IEnumerable<IEntityType>;
    getEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    getModelDependencies(): RuntimeModelDependencies;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isIndexerMethod(methodInfo: MethodInfo): boolean;
    isShared(type_: Type): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IModel = IModel$instance;

export interface IMutableAnnotatable$instance extends IReadOnlyAnnotatable {
    get item(): unknown | undefined;
    set item(value: unknown);
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    removeAnnotation(name: string): IAnnotation | undefined;
    setAnnotation(name: string, value: unknown): void;
    findAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableAnnotatable = IMutableAnnotatable$instance;

export interface IMutableCheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly entityType: IMutableEntityType;
    name: string;
    readonly modelName: string;
    readonly sql: string;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDefaultName(): string | undefined;
    getName(storeObject: StoreObjectIdentifier): string | undefined;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableCheckConstraint = IMutableCheckConstraint$instance;

export interface IMutableComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly complexType: IMutableComplexType;
    isNullable: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableComplexProperty = IMutableComplexProperty$instance;

export interface IMutableComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableTypeBase, IMutableAnnotatable {
    readonly complexProperty: IMutableComplexProperty;
    readonly baseType: IMutableComplexType | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addIgnored(memberName: string): string;
    addProperty(memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type): IMutableProperty;
    addProperty(name: string): IMutableProperty;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    findComplexProperty(name: string): IMutableComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IMutableProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IMutablePropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IMutableComplexType>;
    getDerivedTypes(): IEnumerable<IMutableTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IMutableComplexType;
    getRootType(): IMutableTypeBase;
    getRootType(): IReadOnlyComplexType;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isContainedBy(type_: Type): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    removeDiscriminatorValue(): void;
    removeProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    setAnnotation(name: string, value: unknown): void;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
    setDiscriminatorProperty(property: IReadOnlyProperty): void;
    setDiscriminatorValue(value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    findMember2(name: string): IReadOnlyPropertyBase | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRootType2(): IReadOnlyTypeBase;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableComplexType = IMutableComplexType$instance;

export interface IMutableDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IMutableAnnotatable {
    name: string;
    schema: string;
    isBuiltIn: boolean;
    isNullable: boolean;
    storeType: string;
    typeMapping: RelationalTypeMapping;
    readonly model: IMutableModel;
    readonly parameters: IReadOnlyList<IMutableDbFunctionParameter>;
    get translation(): Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    set translation(value: Func<IReadOnlyList<SqlExpression>, SqlExpression>);
    readonly modelName: string;
    readonly methodInfo: MethodInfo | undefined;
    readonly isScalar: boolean;
    readonly isAggregate: boolean;
    readonly returnType: Type;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableDbFunction = IMutableDbFunction$instance;

export interface IMutableDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly function_: IMutableDbFunction;
    storeType: string;
    typeMapping: RelationalTypeMapping;
    readonly name: string;
    readonly clrType: Type;
    readonly propagatesNullability: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableDbFunctionParameter = IMutableDbFunctionParameter$instance;

export interface IMutableElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly collectionProperty: IMutableProperty;
    isNullable: boolean;
    readonly clrType: Type;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    setAnnotation(name: string, value: unknown): void;
    setMaxLength(maxLength: Nullable<System_Internal.Int32>): void;
    setTypeMapping(typeMapping: CoreTypeMapping): void;
    setValueComparer(comparer: ValueComparer): void;
    setValueConverter(converter: ValueConverter): void;
    setValueConverter(converterType: Type): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableElementType = IMutableElementType$instance;

export interface IMutableEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableTypeBase, IMutableAnnotatable {
    get baseType(): IMutableEntityType | undefined;
    set baseType(value: IMutableEntityType);
    isKeyless: boolean;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addData(data: IEnumerable<unknown>): void;
    addForeignKey(property: IMutableProperty, principalKey: IMutableKey, principalEntityType: IMutableEntityType): IMutableForeignKey;
    addForeignKey(properties: IReadOnlyList<IMutableProperty>, principalKey: IMutableKey, principalEntityType: IMutableEntityType): IMutableForeignKey;
    addIgnored(memberName: string): string;
    addIndex(property: IMutableProperty, name: string): IMutableIndex;
    addIndex(property: IMutableProperty): IMutableIndex;
    addIndex(properties: IReadOnlyList<IMutableProperty>, name: string): IMutableIndex;
    addIndex(properties: IReadOnlyList<IMutableProperty>): IMutableIndex;
    addProperty(memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type): IMutableProperty;
    addProperty(name: string): IMutableProperty;
    addServiceProperty(memberInfo: MemberInfo, serviceType?: Type): IMutableServiceProperty;
    addSkipNavigation(name: string, memberInfo: MemberInfo, targetEntityType: IMutableEntityType, collection: boolean, onDependent: boolean): IMutableSkipNavigation;
    addSkipNavigation(name: string, navigationType: Type, memberInfo: MemberInfo, targetEntityType: IMutableEntityType, collection: boolean, onDependent: boolean): IMutableSkipNavigation;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IMutableEntityType | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    findComplexProperty(name: string): IMutableComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    findDeclaredTrigger(name: string): IMutableTrigger | undefined;
    findDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    findDiscriminatorProperty(): IMutableProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IMutableForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IMutableForeignKey | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IMutableForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IMutableForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    findIndex(property: IReadOnlyProperty): IMutableIndex | undefined;
    findIndex(name: string): IMutableIndex | undefined;
    findIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    findIndex(name: string): IReadOnlyIndex | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findKey(property: IReadOnlyProperty): IMutableKey | undefined;
    findKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    findMember(name: string): IMutablePropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    findNavigation(memberInfo: MemberInfo): IMutableNavigation | undefined;
    findNavigation(name: string): IMutableNavigation | undefined;
    findNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    findNavigation(name: string): IReadOnlyNavigation | undefined;
    findOwnership(): IMutableForeignKey | undefined;
    findOwnership(): IReadOnlyForeignKey | undefined;
    findPrimaryKey(): IMutableKey | undefined;
    findPrimaryKey(): IReadOnlyKey | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findServiceProperty(name: string): IMutableServiceProperty | undefined;
    findServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IMutableSkipNavigation | undefined;
    findSkipNavigation(name: string): IMutableSkipNavigation | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    findSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    getAllBaseTypes(): IEnumerable<IMutableEntityType>;
    getAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    getDiscriminatorValue(): unknown | undefined;
    getIsDiscriminatorMappingComplete(): boolean;
    getNavigationAccessMode(): PropertyAccessMode;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getQueryFilter(): LambdaExpression | undefined;
    getRootType(): IMutableEntityType;
    getRootType(): IMutableTypeBase;
    getRootType(): IReadOnlyEntityType;
    getRootType(): IReadOnlyTypeBase;
    getSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    isAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    removeDiscriminatorValue(): void;
    removeForeignKey(foreignKey: IReadOnlyForeignKey): IMutableForeignKey | undefined;
    removeIndex(index: IReadOnlyIndex): IMutableIndex | undefined;
    removeKey(key: IReadOnlyKey): IMutableKey | undefined;
    removeProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    removeServiceProperty(property: IReadOnlyServiceProperty): IMutableServiceProperty | undefined;
    removeSkipNavigation(navigation: IReadOnlySkipNavigation): IMutableSkipNavigation | undefined;
    setAnnotation(name: string, value: unknown): void;
    setDiscriminatorMappingComplete(complete: Nullable<System_Internal.Boolean>): void;
    setDiscriminatorProperty(property: IReadOnlyProperty): void;
    setDiscriminatorValue(value: unknown): void;
    setPrimaryKey(property: IMutableProperty): IMutableKey | undefined;
    setPrimaryKey(properties: IReadOnlyList<IMutableProperty>): IMutableKey | undefined;
    setQueryFilter(queryFilter: LambdaExpression): void;
    setQueryFilter(filterKey: string, filter: LambdaExpression): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    findComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    findMember2(name: string): IReadOnlyPropertyBase | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDerivedTypes(): IEnumerable<IMutableTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType2(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    removeAnnotation(name: string): IAnnotation | undefined;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
}


export type IMutableEntityType = IMutableEntityType$instance;

export interface IMutableEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly entityType: IMutableEntityType;
    isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly storeObject: StoreObjectIdentifier;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableEntityTypeMappingFragment = IMutableEntityTypeMappingFragment$instance;

export interface IMutableForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly properties: IReadOnlyList<IMutableProperty>;
    readonly principalKey: IMutableKey;
    readonly declaringEntityType: IMutableEntityType;
    readonly principalEntityType: IMutableEntityType;
    isUnique: boolean;
    isRequired: boolean;
    isRequiredDependent: boolean;
    isOwnership: boolean;
    deleteBehavior: DeleteBehavior;
    readonly dependentToPrincipal: IMutableNavigation | undefined;
    readonly principalToDependent: IMutableNavigation | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getNavigation(pointsToPrincipal: boolean): IMutableNavigation | undefined;
    getNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    getReferencingSkipNavigations(): IEnumerable<IMutableSkipNavigation>;
    getReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IMutableEntityType;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    isBaseLinking(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setDependentToPrincipal(property: MemberInfo): IMutableNavigation | undefined;
    setDependentToPrincipal(name: string): IMutableNavigation | undefined;
    setProperties(properties: IReadOnlyList<IMutableProperty>, principalKey: IMutableKey): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableForeignKey = IMutableForeignKey$instance;

export interface IMutableIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IMutableAnnotatable {
    isUnique: boolean;
    isDescending: IReadOnlyList<System_Internal.Boolean>;
    readonly properties: IReadOnlyList<IMutableProperty>;
    readonly declaringEntityType: IMutableEntityType;
    readonly name: string;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableIndex = IMutableIndex$instance;

export interface IMutableKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly properties: IReadOnlyList<IMutableProperty>;
    readonly declaringEntityType: IMutableEntityType;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getReferencingForeignKeys(): IEnumerable<IMutableForeignKey>;
    getReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    isPrimaryKey(): boolean;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableKey = IMutableKey$instance;

export interface IMutableModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly modelId: Guid;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addEntityType(name: string, definingNavigationName: string, definingEntityType: IMutableEntityType): IMutableEntityType;
    addEntityType(name: string, type_: Type): IMutableEntityType;
    addEntityType(name: string): IMutableEntityType;
    addEntityType(type_: Type, definingNavigationName: string, definingEntityType: IMutableEntityType): IMutableEntityType;
    addEntityType(type_: Type): IMutableEntityType;
    addIgnored(typeName: string): string;
    addShared(type_: Type): void;
    annotationsToDebugString(indent?: int): string;
    delayConventions(): IConventionBatch;
    finalizeModel(): IModel;
    findAnnotation(name: string): IAnnotation | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(name: string): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type): IReadOnlyEntityType | undefined;
    findEntityTypes(type_: Type): IEnumerable<IMutableEntityType>;
    findEntityTypes(type_: Type): IEnumerable<IReadOnlyEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IMutableEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getEmbeddedDiscriminatorName(): string;
    getEntityTypes(): IEnumerable<IMutableEntityType>;
    getEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    getPropertyAccessMode(): PropertyAccessMode;
    isIgnored(typeName: string): boolean;
    isOwned(type_: Type): boolean;
    removeEntityType(entityType: IMutableEntityType): IMutableEntityType | undefined;
    removeOwned(type_: Type): string | undefined;
    removeShared(type_: Type): Type | undefined;
    setAnnotation(name: string, value: unknown): void;
    setEmbeddedDiscriminatorName(name: string): void;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    isShared(type_: Type): boolean;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableModel = IMutableModel$instance;

export interface IMutableNavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableNavigationBase, IMutablePropertyBase, IMutableAnnotatable {
    readonly declaringEntityType: IMutableEntityType;
    readonly targetEntityType: IMutableEntityType;
    readonly foreignKey: IMutableForeignKey;
    readonly inverse: IMutableNavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setInverse(inverse: MemberInfo): IMutableNavigation | undefined;
    setInverse(inverseName: string): IMutableNavigation | undefined;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableNavigation = IMutableNavigation$instance;

export interface IMutableNavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly targetEntityType: IReadOnlyEntityType;
    readonly inverse: IReadOnlyNavigationBase;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    removeAnnotation(name: string): IAnnotation | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableNavigationBase = IMutableNavigationBase$instance;

export interface IMutableProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly declaringEntityType: IMutableEntityType;
    isNullable: boolean;
    valueGenerated: ValueGenerated;
    isConcurrencyToken: boolean;
    get sentinel(): unknown | undefined;
    set sentinel(value: unknown);
    readonly isPrimitiveCollection: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findContainingPrimaryKey(): IMutableKey | undefined;
    findContainingPrimaryKey(): IReadOnlyKey | undefined;
    findFirstPrincipal(): IMutableProperty | undefined;
    findFirstPrincipal(): IReadOnlyProperty | undefined;
    getBeforeSaveBehavior(): PropertySaveBehavior;
    getContainingForeignKeys(): IEnumerable<IMutableForeignKey>;
    getContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    getElementType(): IMutableElementType | undefined;
    getElementType(): IReadOnlyElementType | undefined;
    getFieldName(): string | undefined;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getPrincipals(): IReadOnlyList<IMutableProperty>;
    getPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    getPropertyAccessMode(): PropertyAccessMode;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    getValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    isForeignKey(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setMaxLength(maxLength: Nullable<System_Internal.Int32>): void;
    setTypeMapping(typeMapping: CoreTypeMapping): void;
    setValueComparer(comparer: ValueComparer): void;
    setValueConverter(converter: ValueConverter): void;
    setValueGeneratorFactory(valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>): void;
    setValueGeneratorFactory(valueGeneratorFactory: Type): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    isShadowProperty(): boolean;
    removeAnnotation(name: string): IAnnotation | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableProperty = IMutableProperty$instance;

export interface IMutablePropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly declaringType: IMutableTypeBase;
    get fieldInfo(): FieldInfo | undefined;
    set fieldInfo(value: FieldInfo);
    readonly name: string;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutablePropertyBase = IMutablePropertyBase$instance;

export interface IMutableRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly property: IMutableProperty;
    columnName: string;
    readonly storeObject: StoreObjectIdentifier;
    readonly isColumnNameOverridden: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    removeColumnNameOverride(): void;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableRelationalPropertyOverrides = IMutableRelationalPropertyOverrides$instance;

export interface IMutableSequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly model: IMutableModel;
    startValue: long;
    incrementBy: int;
    minValue: Nullable<System_Internal.Int64>;
    maxValue: Nullable<System_Internal.Int64>;
    type_: Type;
    isCyclic: boolean;
    readonly name: string;
    readonly modelSchema: string | undefined;
    readonly schema: string;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableSequence = IMutableSequence$instance;

export interface IMutableServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly declaringEntityType: IMutableEntityType;
    parameterBinding: ServiceParameterBinding;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableServiceProperty = IMutableServiceProperty$instance;

export interface IMutableSkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableNavigationBase, IMutablePropertyBase, IMutableAnnotatable {
    readonly declaringEntityType: IMutableEntityType;
    readonly targetEntityType: IMutableEntityType;
    readonly joinEntityType: IMutableEntityType;
    readonly foreignKey: IMutableForeignKey;
    readonly inverse: IMutableSkipNavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setAnnotation(name: string, value: unknown): void;
    setField(fieldName: string): void;
    setForeignKey(foreignKey: IMutableForeignKey): void;
    setInverse(inverse: IMutableSkipNavigation): IMutableSkipNavigation | undefined;
    setIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
    setPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableSkipNavigation = IMutableSkipNavigation$instance;

export interface IMutableStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IMutableAnnotatable {
    name: string;
    schema: string;
    readonly entityType: IMutableEntityType;
    isRowsAffectedReturned: boolean;
    readonly parameters: IReadOnlyList<IMutableStoredProcedureParameter>;
    readonly resultColumns: IReadOnlyList<IMutableStoredProcedureResultColumn>;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findParameter(propertyName: string): IMutableStoredProcedureParameter | undefined;
    findParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    findResultColumn(propertyName: string): IMutableStoredProcedureResultColumn | undefined;
    findResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    findRowsAffectedParameter(): IMutableStoredProcedureParameter | undefined;
    findRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    findRowsAffectedResultColumn(): IMutableStoredProcedureResultColumn | undefined;
    findRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getSchemaQualifiedName(): string | undefined;
    getStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedure = IMutableStoredProcedure$instance;

export interface IMutableStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly storedProcedure: IMutableStoredProcedure;
    name: string;
    direction: ParameterDirection;
    readonly propertyName: string;
    readonly forOriginalValue: Nullable<System_Internal.Boolean>;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedureParameter = IMutableStoredProcedureParameter$instance;

export interface IMutableStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly storedProcedure: IMutableStoredProcedure;
    name: string;
    readonly propertyName: string;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedureResultColumn = IMutableStoredProcedureResultColumn$instance;

export interface IMutableTrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly entityType: IMutableEntityType;
    readonly modelName: string;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    setAnnotation(name: string, value: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableTrigger = IMutableTrigger$instance;

export interface IMutableTypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly model: IMutableModel;
    readonly containingEntityType: IMutableEntityType;
    get baseType(): IMutableTypeBase | undefined;
    set baseType(value: IMutableTypeBase);
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    addAnnotation(name: string, value: unknown): IAnnotation;
    addAnnotations(annotations: IEnumerable<IAnnotation>): void;
    addComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    addIgnored(memberName: string): string;
    addProperty(memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    addProperty(name: string, propertyType: Type): IMutableProperty;
    addProperty(name: string): IMutableProperty;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    findComplexProperty(name: string): IMutableComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IMutableProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IMutablePropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IMutableTypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IMutableTypeBase;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isIgnored(memberName: string): boolean;
    removeComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    removeDiscriminatorValue(): void;
    removeProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    setAnnotation(name: string, value: unknown): void;
    setChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
    setDiscriminatorProperty(property: IReadOnlyProperty): void;
    setDiscriminatorValue(value: unknown): void;
    getAnnotations(): IEnumerable<IAnnotation>;
    removeAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableTypeBase = IMutableTypeBase$instance;

export interface INavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, INavigationBase, IPropertyBase, IAnnotatable {
    readonly declaringEntityType: IEntityType;
    readonly targetEntityType: IEntityType;
    readonly foreignKey: IForeignKey;
    readonly inverse: INavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setIsLoadedWhenNoTracking(entity: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type INavigation = INavigation$instance;

export interface INavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly declaringEntityType: IEntityType;
    readonly targetEntityType: IEntityType;
    readonly inverse: INavigationBase;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setIsLoadedWhenNoTracking(entity: unknown): void;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type INavigationBase = INavigationBase$instance;

export interface IParameterBindingFactories$instance {
    findFactory(parameterType: Type, parameterName: string): IParameterBindingFactory | undefined;
}


export type IParameterBindingFactories = IParameterBindingFactories$instance;

export interface IParameterBindingFactory$instance {
    bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    canBind(parameterType: Type, parameterName: string): boolean;
}


export type IParameterBindingFactory = IParameterBindingFactory$instance;

export interface IPrimaryKeyConstraint$instance extends IUniqueConstraint, IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly mappedKeys: IEnumerable<IKey>;
    readonly table: ITable;
    readonly columns: IReadOnlyList<IColumn>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getIsPrimaryKey(): boolean;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IPrimaryKeyConstraint = IPrimaryKeyConstraint$instance;

export interface IProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly declaringEntityType: IEntityType;
    readonly isNullable: boolean;
    readonly valueGenerated: ValueGenerated;
    readonly isConcurrencyToken: boolean;
    readonly isPrimitiveCollection: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    createKeyEqualityComparer<TProperty>(): IEqualityComparer<TProperty>;
    findAnnotation(name: string): IAnnotation | undefined;
    findContainingPrimaryKey(): IKey | undefined;
    findContainingPrimaryKey(): IReadOnlyKey | undefined;
    findFirstPrincipal(): IProperty | undefined;
    findFirstPrincipal(): IReadOnlyProperty | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getBeforeSaveBehavior(): PropertySaveBehavior;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getContainingForeignKeys(): IEnumerable<IForeignKey>;
    getContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getElementType(): IElementType | undefined;
    getElementType(): IReadOnlyElementType | undefined;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPrincipals(): IReadOnlyList<IProperty>;
    getPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    getPropertyAccessMode(): PropertyAccessMode;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    getValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    isForeignKey(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isShadowProperty(): boolean;
}


export type IProperty = IProperty$instance;

export interface IPropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IAnnotatable {
    readonly declaringType: ITypeBase;
    readonly name: string;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IPropertyBase = IPropertyBase$instance;

export interface IPropertyParameterBindingFactory$instance {
    findParameter(complexType: IComplexType, parameterType: Type, parameterName: string): ParameterBinding | undefined;
    findParameter(entityType: IEntityType, parameterType: Type, parameterName: string): ParameterBinding | undefined;
}


export type IPropertyParameterBindingFactory = IPropertyParameterBindingFactory$instance;

export interface IQueryFilter$instance {
    readonly expression: LambdaExpression;
    readonly key: string;
    readonly isAnonymous: boolean;
}


export type IQueryFilter = IQueryFilter$instance;

export interface IReadOnlyCheckConstraint$instance extends IReadOnlyAnnotatable {
    readonly modelName: string;
    readonly name: string;
    readonly entityType: IReadOnlyEntityType;
    readonly sql: string;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDefaultName(): string | undefined;
    getName(storeObject: StoreObjectIdentifier): string | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyCheckConstraint$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyCheckConstraint = IReadOnlyCheckConstraint$instance;

export interface IReadOnlyComplexProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly complexType: IReadOnlyComplexType;
    readonly isNullable: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyComplexProperty = IReadOnlyComplexProperty$instance;

export interface IReadOnlyComplexType$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable {
    readonly complexProperty: IReadOnlyComplexProperty;
    readonly baseType: IReadOnlyComplexType | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyComplexType;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    isContainedBy(type_: Type): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IReadOnlyComplexType = IReadOnlyComplexType$instance;

export interface IReadOnlyDbFunction$instance extends IReadOnlyAnnotatable {
    readonly name: string;
    readonly schema: string;
    readonly modelName: string;
    readonly model: IReadOnlyModel;
    readonly methodInfo: MethodInfo | undefined;
    readonly isBuiltIn: boolean;
    readonly isScalar: boolean;
    readonly isAggregate: boolean;
    readonly isNullable: boolean;
    readonly storeType: string;
    readonly returnType: Type;
    readonly typeMapping: RelationalTypeMapping;
    readonly parameters: IReadOnlyList<IReadOnlyDbFunctionParameter>;
    readonly translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyDbFunction$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyDbFunction = IReadOnlyDbFunction$instance;

export interface IReadOnlyDbFunctionParameter$instance extends IReadOnlyAnnotatable {
    readonly function_: IReadOnlyDbFunction;
    readonly name: string;
    readonly clrType: Type;
    readonly storeType: string;
    readonly propagatesNullability: boolean;
    readonly typeMapping: RelationalTypeMapping;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyDbFunctionParameter$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyDbFunctionParameter = IReadOnlyDbFunctionParameter$instance;

export interface IReadOnlyElementType$instance extends IReadOnlyAnnotatable {
    readonly collectionProperty: IReadOnlyProperty;
    readonly clrType: Type;
    readonly isNullable: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyElementType$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyElementType = IReadOnlyElementType$instance;

export interface IReadOnlyEntityType$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable {
    readonly baseType: IReadOnlyEntityType | undefined;
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    findDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    findForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    findForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    findIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    findIndex(name: string): IReadOnlyIndex | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    findNavigation(name: string): IReadOnlyNavigation | undefined;
    findOwnership(): IReadOnlyForeignKey | undefined;
    findPrimaryKey(): IReadOnlyKey | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    findSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    findSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    getAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    getDiscriminatorValue(): unknown | undefined;
    getIsDiscriminatorMappingComplete(): boolean;
    getNavigationAccessMode(): PropertyAccessMode;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getQueryFilter(): LambdaExpression | undefined;
    getRootType(): IReadOnlyEntityType;
    getRootType(): IReadOnlyTypeBase;
    getSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    isAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getPropertyAccessMode(): PropertyAccessMode;
    isAbstract(): boolean;
}


export type IReadOnlyEntityType = IReadOnlyEntityType$instance;

export interface IReadOnlyEntityTypeMappingFragment$instance extends IReadOnlyAnnotatable {
    readonly entityType: IReadOnlyEntityType;
    readonly storeObject: StoreObjectIdentifier;
    readonly isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyEntityTypeMappingFragment$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyEntityTypeMappingFragment = IReadOnlyEntityTypeMappingFragment$instance;

export interface IReadOnlyForeignKey$instance extends IReadOnlyAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly properties: IReadOnlyList<IReadOnlyProperty>;
    readonly principalEntityType: IReadOnlyEntityType;
    readonly principalKey: IReadOnlyKey;
    readonly dependentToPrincipal: IReadOnlyNavigation | undefined;
    readonly principalToDependent: IReadOnlyNavigation | undefined;
    readonly isUnique: boolean;
    readonly isRequired: boolean;
    readonly isRequiredDependent: boolean;
    readonly isOwnership: boolean;
    readonly deleteBehavior: DeleteBehavior;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    getReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    getRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    isBaseLinking(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyForeignKey$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyForeignKey = IReadOnlyForeignKey$instance;

export interface IReadOnlyIndex$instance extends IReadOnlyAnnotatable {
    readonly properties: IReadOnlyList<IReadOnlyProperty>;
    readonly name: string;
    readonly isUnique: boolean;
    readonly isDescending: IReadOnlyList<System_Internal.Boolean>;
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyIndex$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyIndex = IReadOnlyIndex$instance;

export interface IReadOnlyKey$instance extends IReadOnlyAnnotatable {
    readonly properties: IReadOnlyList<IReadOnlyProperty>;
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    isPrimaryKey(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyKey$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyKey = IReadOnlyKey$instance;

export interface IReadOnlyModel$instance extends IReadOnlyAnnotatable {
    readonly modelId: Guid;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(name: string): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    findEntityType(type_: Type): IReadOnlyEntityType | undefined;
    findEntityTypes(type_: Type): IEnumerable<IReadOnlyEntityType>;
    findLeastDerivedEntityTypes(type_: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getEmbeddedDiscriminatorName(): string;
    getEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    getPropertyAccessMode(): PropertyAccessMode;
    isShared(type_: Type): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyModel$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyModel = IReadOnlyModel$instance;

export interface IReadOnlyNavigation$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly targetEntityType: IReadOnlyEntityType;
    readonly inverse: IReadOnlyNavigation;
    readonly foreignKey: IReadOnlyForeignKey;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyNavigation = IReadOnlyNavigation$instance;

export interface IReadOnlyNavigationBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly targetEntityType: IReadOnlyEntityType;
    readonly inverse: IReadOnlyNavigationBase;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
}


export type IReadOnlyNavigationBase = IReadOnlyNavigationBase$instance;

export interface IReadOnlyProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly isNullable: boolean;
    readonly valueGenerated: ValueGenerated;
    readonly isConcurrencyToken: boolean;
    readonly isPrimitiveCollection: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findContainingPrimaryKey(): IReadOnlyKey | undefined;
    findFirstPrincipal(): IReadOnlyProperty | undefined;
    getBeforeSaveBehavior(): PropertySaveBehavior;
    getContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    getElementType(): IReadOnlyElementType | undefined;
    getFieldName(): string | undefined;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    getPropertyAccessMode(): PropertyAccessMode;
    getProviderClrType(): Type | undefined;
    getTypeMapping(): CoreTypeMapping;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    getValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    isForeignKey(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    getAnnotations(): IEnumerable<IAnnotation>;
    isShadowProperty(): boolean;
}


export type IReadOnlyProperty = IReadOnlyProperty$instance;

export interface IReadOnlyPropertyBase$instance extends IReadOnlyAnnotatable {
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
}


export interface IReadOnlyPropertyBase$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyPropertyBase = IReadOnlyPropertyBase$instance;

export interface IReadOnlyRelationalPropertyOverrides$instance extends IReadOnlyAnnotatable {
    readonly property: IReadOnlyProperty;
    readonly storeObject: StoreObjectIdentifier;
    readonly columnName: string;
    readonly isColumnNameOverridden: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyRelationalPropertyOverrides$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyRelationalPropertyOverrides = IReadOnlyRelationalPropertyOverrides$instance;

export interface IReadOnlySequence$instance extends IReadOnlyAnnotatable {
    readonly name: string;
    readonly modelSchema: string | undefined;
    readonly schema: string;
    readonly model: IReadOnlyModel;
    readonly startValue: long;
    readonly incrementBy: int;
    readonly minValue: Nullable<System_Internal.Int64>;
    readonly maxValue: Nullable<System_Internal.Int64>;
    readonly type_: Type;
    readonly isCyclic: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlySequence$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlySequence = IReadOnlySequence$instance;

export interface IReadOnlyServiceProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly parameterBinding: ServiceParameterBinding;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyServiceProperty = IReadOnlyServiceProperty$instance;

export interface IReadOnlySkipNavigation$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly joinEntityType: IReadOnlyEntityType;
    readonly inverse: IReadOnlySkipNavigation;
    readonly foreignKey: IReadOnlyForeignKey;
    readonly isOnDependent: boolean;
    readonly declaringEntityType: IReadOnlyEntityType;
    readonly targetEntityType: IReadOnlyEntityType;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getFieldName(): string | undefined;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlySkipNavigation = IReadOnlySkipNavigation$instance;

export interface IReadOnlyStoredProcedure$instance extends IReadOnlyAnnotatable {
    readonly name: string;
    readonly schema: string;
    readonly entityType: IReadOnlyEntityType;
    readonly isRowsAffectedReturned: boolean;
    readonly parameters: IReadOnlyList<IReadOnlyStoredProcedureParameter>;
    readonly resultColumns: IReadOnlyList<IReadOnlyStoredProcedureResultColumn>;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    findResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    findRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    findRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getSchemaQualifiedName(): string | undefined;
    getStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedure$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedure = IReadOnlyStoredProcedure$instance;

export interface IReadOnlyStoredProcedureParameter$instance extends IReadOnlyAnnotatable {
    readonly storedProcedure: IReadOnlyStoredProcedure;
    readonly name: string;
    readonly propertyName: string;
    readonly direction: ParameterDirection;
    readonly forOriginalValue: Nullable<System_Internal.Boolean>;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedureParameter$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedureParameter = IReadOnlyStoredProcedureParameter$instance;

export interface IReadOnlyStoredProcedureResultColumn$instance extends IReadOnlyAnnotatable {
    readonly storedProcedure: IReadOnlyStoredProcedure;
    readonly name: string;
    readonly propertyName: string;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedureResultColumn$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedureResultColumn = IReadOnlyStoredProcedureResultColumn$instance;

export interface IReadOnlyStoreObjectDictionary_1$instance<T> {
    find(storeObject: StoreObjectIdentifier): T | undefined;
    getValues(): IEnumerable<T>;
}


export type IReadOnlyStoreObjectDictionary_1<T> = IReadOnlyStoreObjectDictionary_1$instance<T>;

export interface IReadOnlyTrigger$instance extends IReadOnlyAnnotatable {
    readonly modelName: string;
    readonly entityType: IReadOnlyEntityType;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyTrigger$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyTrigger = IReadOnlyTrigger$instance;

export interface IReadOnlyTypeBase$instance extends IReadOnlyAnnotatable {
    readonly model: IReadOnlyModel;
    readonly containingEntityType: IReadOnlyEntityType;
    readonly baseType: IReadOnlyTypeBase | undefined;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyTypeBase$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyTypeBase = IReadOnlyTypeBase$instance;

export interface IRelationalAnnotationProvider$instance {
    for_(checkConstraint: ICheckConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(foreignKey: IForeignKeyConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IFunctionColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(model: IRelationalModel, designTime: boolean): IEnumerable<IAnnotation>;
    for_(sequence: ISequence, designTime: boolean): IEnumerable<IAnnotation>;
    for_(sqlQuery: ISqlQuery, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: ISqlQueryColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(function_: IStoreFunction, designTime: boolean): IEnumerable<IAnnotation>;
    for_(parameter: IStoreFunctionParameter, designTime: boolean): IEnumerable<IAnnotation>;
    for_(storedProcedure: IStoreStoredProcedure, designTime: boolean): IEnumerable<IAnnotation>;
    for_(parameter: IStoreStoredProcedureParameter, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IStoreStoredProcedureResultColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(table: ITable, designTime: boolean): IEnumerable<IAnnotation>;
    for_(index: ITableIndex, designTime: boolean): IEnumerable<IAnnotation>;
    for_(trigger: ITrigger, designTime: boolean): IEnumerable<IAnnotation>;
    for_(constraint: IUniqueConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(view: IView, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IViewColumn, designTime: boolean): IEnumerable<IAnnotation>;
}


export type IRelationalAnnotationProvider = IRelationalAnnotationProvider$instance;

export interface IRelationalModel$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly model: IModel;
    readonly tables: IEnumerable<ITable>;
    readonly views: IEnumerable<IView>;
    readonly queries: IEnumerable<ISqlQuery>;
    readonly sequences: IEnumerable<ISequence>;
    readonly functions: IEnumerable<IStoreFunction>;
    readonly storedProcedures: IEnumerable<IStoreStoredProcedure>;
    readonly collation: string | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findDefaultTable(name: string): TableBase | undefined;
    findFunction(name: string, schema: string, parameters: IReadOnlyList<System_Internal.String>): IStoreFunction | undefined;
    findQuery(name: string): ISqlQuery | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    findSequence(name: string, schema: string): ISequence | undefined;
    findStoredProcedure(name: string, schema: string): IStoreStoredProcedure | undefined;
    findTable(name: string, schema: string): ITable | undefined;
    findView(name: string, schema: string): IView | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IRelationalModel = IRelationalModel$instance;

export interface IRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IAnnotatable {
    readonly property: IProperty;
    readonly storeObject: StoreObjectIdentifier;
    readonly columnName: string;
    readonly isColumnNameOverridden: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IRelationalPropertyOverrides = IRelationalPropertyOverrides$instance;

export interface ISequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IAnnotatable {
    readonly model: IModel;
    readonly name: string;
    readonly modelSchema: string | undefined;
    readonly schema: string;
    readonly startValue: long;
    readonly incrementBy: int;
    readonly minValue: Nullable<System_Internal.Int64>;
    readonly maxValue: Nullable<System_Internal.Int64>;
    readonly type_: Type;
    readonly isCyclic: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ISequence = ISequence$instance;

export interface IServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly declaringEntityType: IEntityType;
    readonly parameterBinding: ServiceParameterBinding;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IServiceProperty = IServiceProperty$instance;

export interface ISkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, INavigationBase, IPropertyBase, IAnnotatable {
    readonly declaringEntityType: IEntityType;
    readonly targetEntityType: IEntityType;
    readonly joinEntityType: IEntityType;
    readonly foreignKey: IForeignKey;
    readonly inverse: ISkipNavigation;
    readonly isOnDependent: boolean;
    readonly isEagerLoaded: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly name: string;
    readonly declaringType: IReadOnlyTypeBase;
    readonly clrType: Type;
    readonly sentinel: unknown | undefined;
    readonly isCollection: boolean;
    readonly propertyInfo: PropertyInfo | undefined;
    readonly fieldInfo: FieldInfo | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    isShadowProperty(): boolean;
    setIsLoadedWhenNoTracking(entity: unknown): void;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ISkipNavigation = ISkipNavigation$instance;

export interface ISqlQuery$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly entityTypeMappings: IEnumerable<ISqlQueryMapping>;
    readonly columns: IEnumerable<ISqlQueryColumn>;
    readonly sql: string;
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): ISqlQueryColumn | undefined;
    findColumn(name: string): ISqlQueryColumn | undefined;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQuery = ISqlQuery$instance;

export interface ISqlQueryColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly sqlQuery: ISqlQuery;
    readonly propertyMappings: IReadOnlyList<ISqlQueryColumnMapping>;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findColumnMapping(entityType: IReadOnlyEntityType): ISqlQueryColumnMapping | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryColumn = ISqlQueryColumn$instance;

export interface ISqlQueryColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly column: ISqlQueryColumn;
    readonly sqlQueryMapping: ISqlQueryMapping;
    readonly property: IProperty;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryColumnMapping = ISqlQueryColumnMapping$instance;

export interface ISqlQueryMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    isDefaultSqlQueryMapping: boolean;
    readonly sqlQuery: ISqlQuery;
    readonly columnMappings: IEnumerable<ISqlQueryColumnMapping>;
    readonly typeBase: ITypeBase;
    readonly table: ITableBase;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryMapping = ISqlQueryMapping$instance;

export interface IStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IAnnotatable {
    readonly name: string;
    readonly entityType: IEntityType;
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly parameters: IReadOnlyList<IStoredProcedureParameter>;
    readonly resultColumns: IReadOnlyList<IStoredProcedureResultColumn>;
    readonly schema: string;
    readonly isRowsAffectedReturned: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    findParameter(propertyName: string): IStoredProcedureParameter | undefined;
    findResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    findResultColumn(propertyName: string): IStoredProcedureResultColumn | undefined;
    findRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    findRowsAffectedParameter(): IStoredProcedureParameter | undefined;
    findRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    findRowsAffectedResultColumn(): IStoredProcedureResultColumn | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getSchemaQualifiedName(): string | undefined;
    getStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    getStoreIdentifier(): StoreObjectIdentifier;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedure = IStoredProcedure$instance;

export interface IStoredProcedureMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly storedProcedure: IStoredProcedure;
    readonly storedProcedureIdentifier: StoreObjectIdentifier;
    readonly tableMapping: ITableMapping;
    readonly parameterMappings: IEnumerable<IStoredProcedureParameterMapping>;
    readonly resultColumnMappings: IEnumerable<IStoredProcedureResultColumnMapping>;
    readonly typeBase: ITypeBase;
    readonly table: ITableBase;
    readonly columnMappings: IEnumerable<IColumnMappingBase>;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureMapping = IStoredProcedureMapping$instance;

export interface IStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IAnnotatable {
    readonly storedProcedure: IStoredProcedure;
    readonly storeParameter: IStoreStoredProcedureParameter;
    readonly name: string;
    readonly propertyName: string;
    readonly direction: ParameterDirection;
    readonly forOriginalValue: Nullable<System_Internal.Boolean>;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureParameter = IStoredProcedureParameter$instance;

export interface IStoredProcedureParameterMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storeParameter: IStoreStoredProcedureParameter;
    readonly parameter: IStoredProcedureParameter;
    readonly storedProcedureMapping: IStoredProcedureMapping;
    readonly property: IProperty;
    readonly column: IColumnBase;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureParameterMapping = IStoredProcedureParameterMapping$instance;

export interface IStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IAnnotatable {
    readonly storedProcedure: IStoredProcedure;
    readonly storeResultColumn: IStoreStoredProcedureResultColumn;
    readonly name: string;
    readonly propertyName: string;
    readonly forRowsAffected: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureResultColumn = IStoredProcedureResultColumn$instance;

export interface IStoredProcedureResultColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storeResultColumn: IStoreStoredProcedureResultColumn;
    readonly resultColumn: IStoredProcedureResultColumn;
    readonly storedProcedureMapping: IStoredProcedureMapping;
    readonly property: IProperty;
    readonly column: IColumnBase;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureResultColumnMapping = IStoredProcedureResultColumnMapping$instance;

export interface IStoreFunction$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly dbFunctions: IEnumerable<IDbFunction>;
    readonly isBuiltIn: boolean;
    readonly parameters: IEnumerable<IStoreFunctionParameter>;
    readonly returnType: string;
    readonly entityTypeMappings: IEnumerable<IFunctionMapping>;
    readonly columns: IEnumerable<IFunctionColumn>;
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): IFunctionColumn | undefined;
    findColumn(name: string): IFunctionColumn | undefined;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreFunction = IStoreFunction$instance;

export interface IStoreFunctionParameter$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly function_: IStoreFunction;
    readonly dbFunctionParameters: IEnumerable<IDbFunctionParameter>;
    readonly name: string;
    readonly storeType: string;
    readonly type_: string;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreFunctionParameter = IStoreFunctionParameter$instance;

export interface IStoreStoredProcedure$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storedProcedures: IEnumerable<IStoredProcedure>;
    readonly entityTypeMappings: IEnumerable<IStoredProcedureMapping>;
    readonly returnValue: IStoreStoredProcedureReturnValue | undefined;
    readonly parameters: IReadOnlyList<IStoreStoredProcedureParameter>;
    readonly resultColumns: IEnumerable<IStoreStoredProcedureResultColumn>;
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly columns: IEnumerable<IColumnBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findParameter(property: IProperty): IStoreStoredProcedureParameter | undefined;
    findParameter(name: string): IStoreStoredProcedureParameter | undefined;
    findResultColumn(property: IProperty): IStoreStoredProcedureResultColumn | undefined;
    findResultColumn(name: string): IStoreStoredProcedureResultColumn | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedure = IStoreStoredProcedure$instance;

export interface IStoreStoredProcedureParameter$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storedProcedure: IStoreStoredProcedure;
    readonly propertyMappings: IReadOnlyList<IStoredProcedureParameterMapping>;
    readonly direction: ParameterDirection;
    readonly position: int;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findParameterMapping(entityType: IReadOnlyEntityType): IStoredProcedureParameterMapping | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureParameter = IStoreStoredProcedureParameter$instance;

export interface IStoreStoredProcedureResultColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storedProcedure: IStoreStoredProcedure;
    readonly propertyMappings: IReadOnlyList<IStoredProcedureResultColumnMapping>;
    readonly position: int;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findColumnMapping(entityType: IReadOnlyEntityType): IStoredProcedureResultColumnMapping | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureResultColumn = IStoreStoredProcedureResultColumn$instance;

export interface IStoreStoredProcedureReturnValue$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly storedProcedure: IStoreStoredProcedure;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly propertyMappings: IReadOnlyList<IColumnMappingBase>;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureReturnValue = IStoreStoredProcedureReturnValue$instance;

export interface ITable$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly entityTypeMappings: IEnumerable<ITableMapping>;
    readonly columns: IEnumerable<IColumn>;
    readonly isExcludedFromMigrations: boolean;
    readonly foreignKeyConstraints: IEnumerable<IForeignKeyConstraint>;
    readonly referencingForeignKeyConstraints: IEnumerable<IForeignKeyConstraint>;
    readonly uniqueConstraints: IEnumerable<IUniqueConstraint>;
    readonly primaryKey: IPrimaryKeyConstraint | undefined;
    readonly indexes: IEnumerable<ITableIndex>;
    readonly checkConstraints: IEnumerable<ICheckConstraint>;
    readonly triggers: IEnumerable<ITrigger>;
    readonly comment: string | undefined;
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): IColumn | undefined;
    findColumn(name: string): IColumn | undefined;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITable = ITable$instance;

export interface ITableBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly entityTypeMappings: IEnumerable<ITableMappingBase>;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly columns: IEnumerable<IColumnBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableBase = ITableBase$instance;

export interface ITableIndex$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly mappedIndexes: IEnumerable<IIndex>;
    readonly table: ITable;
    readonly columns: IReadOnlyList<IColumn>;
    readonly isUnique: boolean;
    readonly isDescending: IReadOnlyList<System_Internal.Boolean>;
    readonly filter: string | undefined;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableIndex = ITableIndex$instance;

export interface ITableMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly table: ITable;
    readonly columnMappings: IEnumerable<IColumnMapping>;
    readonly insertStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly deleteStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly updateStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly typeBase: ITypeBase;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableMapping = ITableMapping$instance;

export interface ITableMappingBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly typeBase: ITypeBase;
    readonly table: ITableBase;
    readonly columnMappings: IEnumerable<IColumnMappingBase>;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableMappingBase = ITableMappingBase$instance;

export interface ITrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IAnnotatable {
    readonly entityType: IEntityType;
    readonly modelName: string;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ITrigger = ITrigger$instance;

export interface ITypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IAnnotatable {
    readonly model: IModel;
    readonly containingEntityType: IEntityType;
    readonly baseType: ITypeBase | undefined;
    readonly constructorBinding: InstantiationBinding | undefined;
    readonly name: string;
    readonly clrType: Type;
    readonly hasSharedClrType: boolean;
    readonly isPropertyBag: boolean;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    findComplexProperty(name: string): IComplexProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findDiscriminatorProperty(): IProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMember(name: string): IPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    findMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findProperty(memberInfo: MemberInfo): IProperty | undefined;
    findProperty(name: string): IProperty | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getDerivedTypes(): IEnumerable<ITypeBase>;
    getDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyTypeBase;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ITypeBase = ITypeBase$instance;

export interface ITypeMappingConfiguration$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly clrType: Type;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getProviderClrType(): Type | undefined;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getValueConverter(): ValueConverter | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type ITypeMappingConfiguration = ITypeMappingConfiguration$instance;

export interface IUniqueConstraint$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly name: string;
    readonly mappedKeys: IEnumerable<IKey>;
    readonly table: ITable;
    readonly columns: IReadOnlyList<IColumn>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getIsPrimaryKey(): boolean;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IUniqueConstraint = IUniqueConstraint$instance;

export interface IView$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly entityTypeMappings: IEnumerable<IViewMapping>;
    readonly columns: IEnumerable<IViewColumn>;
    readonly viewDefinitionSql: string | undefined;
    readonly name: string;
    readonly schema: string;
    readonly schemaQualifiedName: string;
    readonly model: IRelationalModel;
    readonly isShared: boolean;
    readonly complexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumn(property: IProperty): IColumnBase | undefined;
    findColumn(name: string): IColumnBase | undefined;
    findColumn(property: IProperty): IViewColumn | undefined;
    findColumn(name: string): IViewColumn | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isOptional(typeBase: ITypeBase): boolean;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IView = IView$instance;

export interface IViewColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly view: IView;
    readonly propertyMappings: IReadOnlyList<IViewColumnMapping>;
    readonly name: string;
    readonly storeType: string;
    readonly providerClrType: Type;
    readonly storeTypeMapping: RelationalTypeMapping;
    readonly isNullable: boolean;
    readonly table: ITableBase;
    readonly providerValueComparer: ValueComparer;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    findColumnMapping(entityType: IReadOnlyEntityType): IViewColumnMapping | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewColumn = IViewColumn$instance;

export interface IViewColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly column: IViewColumn;
    readonly viewMapping: IViewMapping;
    readonly property: IProperty;
    readonly typeMapping: RelationalTypeMapping;
    readonly tableMapping: ITableMappingBase;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewColumnMapping = IViewColumnMapping$instance;

export interface IViewMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly view: IView;
    readonly columnMappings: IEnumerable<IViewColumnMapping>;
    readonly typeBase: ITypeBase;
    readonly table: ITableBase;
    readonly isSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly isSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly includesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly item: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    toDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewMapping = IViewMapping$instance;

export interface MemberIdentity$instance {
    readonly memberInfo: MemberInfo | undefined;
    readonly name: string;
    equals(obj: unknown): boolean;
    equals(other: MemberIdentity): boolean;
    getHashCode(): int;
}


export const MemberIdentity: {
    new(name: string): MemberIdentity;
    new(memberInfo: MemberInfo): MemberIdentity;
    readonly none: MemberIdentity;
    create(memberInfo: MemberInfo): MemberIdentity;
    create(name: string): MemberIdentity;
};


export type MemberIdentity = MemberIdentity$instance;

export interface ParameterBindingInfo$instance {
    readonly instanceName: string;
    readonly materializationContextExpression: Expression;
    readonly queryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    readonly serviceInstances: List<ParameterExpression>;
    readonly structuralType: ITypeBase;
    getValueBufferIndex(property: IPropertyBase): int;
}


export const ParameterBindingInfo: {
    new(structuralType: ITypeBase, materializationContextExpression: Expression): ParameterBindingInfo;
    new(materializerSourceParameters: StructuralTypeMaterializerSourceParameters, materializationContextExpression: Expression): ParameterBindingInfo;
};


export type ParameterBindingInfo = ParameterBindingInfo$instance;

export interface StoreObjectIdentifier$instance {
    readonly name: string;
    readonly schema: string | undefined;
    readonly storeObjectType: StoreObjectType;
    compareTo(other: StoreObjectIdentifier): int;
    displayName(): string;
    equals(obj: unknown): boolean;
    equals(other: StoreObjectIdentifier): boolean;
    getHashCode(): int;
    toString(): string;
}


export const StoreObjectIdentifier: {
    new(): StoreObjectIdentifier;
    create(typeBase: IReadOnlyTypeBase, type_: StoreObjectType): Nullable<StoreObjectIdentifier>;
    dbFunction(modelName: string): StoreObjectIdentifier;
    deleteStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    insertStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    sqlQuery(entityType: IReadOnlyEntityType): StoreObjectIdentifier;
    sqlQuery(name: string): StoreObjectIdentifier;
    table(name: string, schema?: string): StoreObjectIdentifier;
    updateStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    view(name: string, schema?: string): StoreObjectIdentifier;
};


export type StoreObjectIdentifier = StoreObjectIdentifier$instance;

export interface AdHocMapper$instance {
    buildConventionSet(): ConventionSet;
    getOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export const AdHocMapper: {
    new(dependencies: AdHocMapperDependencies): AdHocMapper;
};


export interface __AdHocMapper$views {
    As_IAdHocMapper(): IAdHocMapper$instance;
}

export interface AdHocMapper$instance extends IAdHocMapper$instance {}

export type AdHocMapper = AdHocMapper$instance & __AdHocMapper$views;


export interface AdHocMapperDependencies$instance {
    model: IModel;
    modelCreationDependencies: ModelCreationDependencies;
    _Clone_$(): AdHocMapperDependencies;
    equals(obj: unknown): boolean;
    equals(other: AdHocMapperDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const AdHocMapperDependencies: {
    new(model: IModel, modelCreationDependencies: ModelCreationDependencies): AdHocMapperDependencies;
};


export type AdHocMapperDependencies = AdHocMapperDependencies$instance;

export interface ConstructorBinding$instance extends InstantiationBinding {
    readonly constructor_: ConstructorInfo;
    readonly runtimeType: Type;
    createConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    with_(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const ConstructorBinding: {
    new(constructor_: ConstructorInfo, parameterBindings: IReadOnlyList<ParameterBinding>): ConstructorBinding;
};


export type ConstructorBinding = ConstructorBinding$instance;

export interface ContextParameterBinding$instance extends ServiceParameterBinding {
    bindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ContextParameterBinding: {
    new(contextType: Type, serviceProperties: IPropertyBase[]): ContextParameterBinding;
};


export type ContextParameterBinding = ContextParameterBinding$instance;

export interface DefaultValueBinding$instance extends InstantiationBinding {
    readonly runtimeType: Type;
    createConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    with_(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const DefaultValueBinding: {
    new(runtimeType: Type): DefaultValueBinding;
};


export type DefaultValueBinding = DefaultValueBinding$instance;

export interface DependencyInjectionMethodParameterBinding$instance extends DependencyInjectionParameterBinding {
    readonly method: MethodInfo;
    readonly serviceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    bindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const DependencyInjectionMethodParameterBinding: {
    new(parameterType: Type, serviceType: Type, method: MethodInfo, serviceProperties: IPropertyBase[]): DependencyInjectionMethodParameterBinding;
};


export type DependencyInjectionMethodParameterBinding = DependencyInjectionMethodParameterBinding$instance;

export interface DependencyInjectionParameterBinding$instance extends ServiceParameterBinding {
    readonly serviceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    bindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const DependencyInjectionParameterBinding: {
    new(parameterType: Type, serviceType: Type, serviceProperties: IPropertyBase[]): DependencyInjectionParameterBinding;
};


export type DependencyInjectionParameterBinding = DependencyInjectionParameterBinding$instance;

export interface EntityTypeFullNameComparer$instance {
    compare(x: IReadOnlyEntityType, y: IReadOnlyEntityType): int;
    equals(x: IReadOnlyEntityType, y: IReadOnlyEntityType): boolean;
    getHashCode(obj: IReadOnlyEntityType): int;
}


export const EntityTypeFullNameComparer: {
    new(): EntityTypeFullNameComparer;
    readonly instance: EntityTypeFullNameComparer;
};


export type EntityTypeFullNameComparer = EntityTypeFullNameComparer$instance;

export interface EntityTypeParameterBinding$instance extends ServiceParameterBinding {
    bindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const EntityTypeParameterBinding: {
    new(serviceProperties: IPropertyBase[]): EntityTypeParameterBinding;
};


export type EntityTypeParameterBinding = EntityTypeParameterBinding$instance;

export interface FactoryMethodBinding$instance extends InstantiationBinding {
    readonly runtimeType: Type;
    createConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    with_(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const FactoryMethodBinding: {
    new(factoryMethod: MethodInfo, parameterBindings: IReadOnlyList<ParameterBinding>, runtimeType: Type): FactoryMethodBinding;
    new(factoryInstance: unknown, factoryMethod: MethodInfo, parameterBindings: IReadOnlyList<ParameterBinding>, runtimeType: Type): FactoryMethodBinding;
};


export type FactoryMethodBinding = FactoryMethodBinding$instance;

export interface ForeignKeyComparer$instance {
    compare(x: IReadOnlyForeignKey, y: IReadOnlyForeignKey): int;
    equals(x: IReadOnlyForeignKey, y: IReadOnlyForeignKey): boolean;
    getHashCode(obj: IReadOnlyForeignKey): int;
}


export const ForeignKeyComparer: {
    new(): ForeignKeyComparer;
    readonly instance: ForeignKeyComparer;
};


export type ForeignKeyComparer = ForeignKeyComparer$instance;

export interface IndexComparer$instance {
    compare(x: IReadOnlyIndex, y: IReadOnlyIndex): int;
    equals(x: IReadOnlyIndex, y: IReadOnlyIndex): boolean;
    getHashCode(obj: IReadOnlyIndex): int;
}


export const IndexComparer: {
    new(): IndexComparer;
    readonly instance: IndexComparer;
};


export type IndexComparer = IndexComparer$instance;

export interface InstantiationBinding$instance {
    readonly parameterBindings: IReadOnlyList<ParameterBinding>;
    readonly runtimeType: Type;
    createConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    with_(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const InstantiationBinding: {
};


export type InstantiationBinding = InstantiationBinding$instance;

export interface KeyComparer$instance {
    compare(x: IReadOnlyKey, y: IReadOnlyKey): int;
    equals(x: IReadOnlyKey, y: IReadOnlyKey): boolean;
    getHashCode(obj: IReadOnlyKey): int;
}


export const KeyComparer: {
    new(): KeyComparer;
    readonly instance: KeyComparer;
};


export type KeyComparer = KeyComparer$instance;

export interface LazyLoaderParameterBindingFactory$instance extends ServiceParameterBindingFactory$instance {
    bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    canBind(parameterType: Type, parameterName: string): boolean;
}


export const LazyLoaderParameterBindingFactory: {
    new(dependencies: LazyLoaderParameterBindingFactoryDependencies): LazyLoaderParameterBindingFactory;
};


export interface __LazyLoaderParameterBindingFactory$views {
    As_IParameterBindingFactory(): IParameterBindingFactory$instance;
}

export type LazyLoaderParameterBindingFactory = LazyLoaderParameterBindingFactory$instance & __LazyLoaderParameterBindingFactory$views;


export interface LazyLoaderParameterBindingFactoryDependencies$instance {
    _Clone_$(): LazyLoaderParameterBindingFactoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: LazyLoaderParameterBindingFactoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const LazyLoaderParameterBindingFactoryDependencies: {
    new(): LazyLoaderParameterBindingFactoryDependencies;
};


export type LazyLoaderParameterBindingFactoryDependencies = LazyLoaderParameterBindingFactoryDependencies$instance;

export interface ObjectArrayParameterBinding$instance extends ParameterBinding {
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ObjectArrayParameterBinding: {
    new(bindings: IReadOnlyList<ParameterBinding>): ObjectArrayParameterBinding;
};


export type ObjectArrayParameterBinding = ObjectArrayParameterBinding$instance;

export interface ParameterBinding$instance {
    readonly consumedProperties: IReadOnlyList<IPropertyBase>;
    readonly parameterType: Type;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ParameterBinding: {
};


export type ParameterBinding = ParameterBinding$instance;

export interface PropertyParameterBinding$instance extends ParameterBinding {
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    with_(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const PropertyParameterBinding: {
    new(property: IProperty): PropertyParameterBinding;
};


export type PropertyParameterBinding = PropertyParameterBinding$instance;

export interface RelationalAdHocMapper$instance extends AdHocMapper$instance {
    buildConventionSet(): ConventionSet;
    getOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export const RelationalAdHocMapper: {
    new(dependencies: AdHocMapperDependencies, relationalDependencies: RelationalAdHocMapperDependencies): RelationalAdHocMapper;
};


export interface __RelationalAdHocMapper$views {
    As_IAdHocMapper(): IAdHocMapper$instance;
}

export type RelationalAdHocMapper = RelationalAdHocMapper$instance & __RelationalAdHocMapper$views;


export interface RelationalAdHocMapperDependencies$instance {
    _Clone_$(): RelationalAdHocMapperDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalAdHocMapperDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalAdHocMapperDependencies: {
    new(): RelationalAdHocMapperDependencies;
};


export type RelationalAdHocMapperDependencies = RelationalAdHocMapperDependencies$instance;

export interface RelationalAnnotationProvider$instance {
    for_(model: IRelationalModel, designTime: boolean): IEnumerable<IAnnotation>;
    for_(table: ITable, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(view: IView, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IViewColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(sqlQuery: ISqlQuery, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: ISqlQueryColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(function_: IStoreFunction, designTime: boolean): IEnumerable<IAnnotation>;
    for_(parameter: IStoreFunctionParameter, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IFunctionColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(storedProcedure: IStoreStoredProcedure, designTime: boolean): IEnumerable<IAnnotation>;
    for_(parameter: IStoreStoredProcedureParameter, designTime: boolean): IEnumerable<IAnnotation>;
    for_(column: IStoreStoredProcedureResultColumn, designTime: boolean): IEnumerable<IAnnotation>;
    for_(foreignKey: IForeignKeyConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(index: ITableIndex, designTime: boolean): IEnumerable<IAnnotation>;
    for_(constraint: IUniqueConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(sequence: ISequence, designTime: boolean): IEnumerable<IAnnotation>;
    for_(checkConstraint: ICheckConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    for_(trigger: ITrigger, designTime: boolean): IEnumerable<IAnnotation>;
}


export const RelationalAnnotationProvider: {
    new(dependencies: RelationalAnnotationProviderDependencies): RelationalAnnotationProvider;
};


export interface __RelationalAnnotationProvider$views {
    As_IRelationalAnnotationProvider(): IRelationalAnnotationProvider$instance;
}

export type RelationalAnnotationProvider = RelationalAnnotationProvider$instance & __RelationalAnnotationProvider$views;


export interface RelationalAnnotationProviderDependencies$instance {
    _Clone_$(): RelationalAnnotationProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalAnnotationProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalAnnotationProviderDependencies: {
    new(): RelationalAnnotationProviderDependencies;
};


export type RelationalAnnotationProviderDependencies = RelationalAnnotationProviderDependencies$instance;

export interface RuntimeComplexProperty$instance extends RuntimePropertyBase$instance {
    readonly complexType: RuntimeComplexType;
    readonly debugView: DebugView;
    readonly declaringType: RuntimeTypeBase;
    readonly isCollection: boolean;
    readonly sentinel: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSetter(): IClrPropertySetter;
    getShadowIndex(): int;
    isShadowProperty(): boolean;
    toString(): string;
}


export const RuntimeComplexProperty: {
    new(name: string, clrType: Type, targetTypeName: string, targetType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringType: RuntimeTypeBase, propertyAccessMode: PropertyAccessMode, nullable: boolean, collection: boolean, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, propertyCount: int, complexPropertyCount: int): RuntimeComplexProperty;
};


export interface __RuntimeComplexProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IComplexProperty(): IComplexProperty$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyComplexProperty(): IReadOnlyComplexProperty$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeComplexProperty = RuntimeComplexProperty$instance & __RuntimeComplexProperty$views;


export interface RuntimeComplexType$instance extends RuntimeTypeBase$instance {
    readonly complexProperty: RuntimeComplexProperty;
    get constructorBinding(): InstantiationBinding | undefined;
    set constructorBinding(value: InstantiationBinding);
    readonly debugView: DebugView;
    get serviceOnlyConstructorBinding(): InstantiationBinding | undefined;
    set serviceOnlyConstructorBinding(value: InstantiationBinding);
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    calculateCounts(): PropertyCounts;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findComplexProperty(name: string): RuntimeComplexProperty | undefined;
    findComplexProperty(name: string): IComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDiscriminatorProperty(): IProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): RuntimePropertyBase | undefined;
    findMember(name: string): IPropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    findProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    findProperty(name: string): RuntimeProperty | undefined;
    findProperty(memberInfo: MemberInfo): IProperty | undefined;
    findProperty(name: string): IProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getConstructorBindingConfigurationSource(): Nullable<ConfigurationSource>;
    getDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    getDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getMembers(): IEnumerable<RuntimePropertyBase>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyTypeBase;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    setCounts(value: PropertyCounts): void;
    toString(): string;
}


export const RuntimeComplexType: {
    new(name: string, type_: Type, complexProperty: RuntimeComplexProperty, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, propertyCount: int, complexPropertyCount: int): RuntimeComplexType;
};


export interface __RuntimeComplexType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IComplexType(): IComplexType$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyComplexType(): IReadOnlyComplexType$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeComplexType = RuntimeComplexType$instance & __RuntimeComplexType$views;


export interface RuntimeDbFunction$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    readonly model: RuntimeModel;
    readonly modelName: string;
    readonly storeFunction: IStoreFunction;
    typeMapping: RelationalTypeMapping;
    addParameter(name: string, clrType: Type, propagatesNullability: boolean, storeType: string, typeMapping?: RelationalTypeMapping): RuntimeDbFunctionParameter;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeDbFunction: {
    new(modelName: string, model: RuntimeModel, returnType: Type, storeName: string, schema: string, storeType: string, methodInfo: MethodInfo, scalar: boolean, aggregate: boolean, nullable: boolean, builtIn: boolean, typeMapping: RelationalTypeMapping, translation: Func<IReadOnlyList<SqlExpression>, SqlExpression>): RuntimeDbFunction;
};


export interface __RuntimeDbFunction$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IDbFunction(): IDbFunction$instance;
    As_IReadOnlyDbFunction(): IReadOnlyDbFunction$instance;
}

export type RuntimeDbFunction = RuntimeDbFunction$instance & __RuntimeDbFunction$views;


export interface RuntimeDbFunctionParameter$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    readonly function_: RuntimeDbFunction;
    readonly name: string;
    typeMapping: RelationalTypeMapping;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeDbFunctionParameter: {
    new(function_: RuntimeDbFunction, name: string, clrType: Type, propagatesNullability: boolean, storeType: string, typeMapping: RelationalTypeMapping): RuntimeDbFunctionParameter;
};


export interface __RuntimeDbFunctionParameter$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IDbFunctionParameter(): IDbFunctionParameter$instance;
    As_IReadOnlyDbFunctionParameter(): IReadOnlyDbFunctionParameter$instance;
}

export type RuntimeDbFunctionParameter = RuntimeDbFunctionParameter$instance & __RuntimeDbFunctionParameter$views;


export interface RuntimeElementType$instance extends RuntimeAnnotatableBase {
    readonly clrType: Type;
    readonly collectionProperty: IProperty;
    readonly debugView: DebugView;
    readonly isNullable: boolean;
    typeMapping: CoreTypeMapping;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    findTypeMapping(): CoreTypeMapping | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getMaxLength(): Nullable<System_Internal.Int32>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPrecision(): Nullable<System_Internal.Int32>;
    getProviderClrType(): Type | undefined;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    getScale(): Nullable<System_Internal.Int32>;
    getValueComparer(): ValueComparer;
    getValueConverter(): ValueConverter | undefined;
    isUnicode(): Nullable<System_Internal.Boolean>;
    setComparer(valueComparer: ValueComparer): ValueComparer;
    setValueConverter(converter: ValueConverter): void;
    toString(): string;
}


export const RuntimeElementType: {
    new(clrType: Type, collectionProperty: RuntimeProperty, nullable: boolean, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueConverter: ValueConverter, valueComparer: ValueComparer, jsonValueReaderWriter: JsonValueReaderWriter, typeMapping: CoreTypeMapping): RuntimeElementType;
};


export interface __RuntimeElementType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IElementType(): IElementType$instance;
    As_IReadOnlyElementType(): IReadOnlyElementType$instance;
}

export type RuntimeElementType = RuntimeElementType$instance & __RuntimeElementType$views;


export interface RuntimeEntityType$instance extends RuntimeTypeBase$instance {
    get constructorBinding(): InstantiationBinding | undefined;
    set constructorBinding(value: InstantiationBinding);
    readonly debugView: DebugView;
    get serviceOnlyConstructorBinding(): InstantiationBinding | undefined;
    set serviceOnlyConstructorBinding(value: InstantiationBinding);
    addForeignKey(properties: IReadOnlyList<RuntimeProperty>, principalKey: RuntimeKey, principalEntityType: RuntimeEntityType, deleteBehavior?: DeleteBehavior, unique?: boolean, required?: boolean, requiredDependent?: boolean, ownership?: boolean): RuntimeForeignKey;
    addIndex(properties: IReadOnlyList<RuntimeProperty>, name?: string, unique?: boolean): RuntimeIndex;
    addKey(properties: IReadOnlyList<RuntimeProperty>): RuntimeKey;
    addNavigation(name: string, foreignKey: RuntimeForeignKey, onDependent: boolean, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, eagerLoaded?: boolean, lazyLoadingEnabled?: boolean): RuntimeNavigation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addServiceProperty(name: string, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, serviceType?: Type, propertyAccessMode?: PropertyAccessMode): RuntimeServiceProperty;
    addSkipNavigation(name: string, targetEntityType: RuntimeEntityType, foreignKey: RuntimeForeignKey, collection: boolean, onDependent: boolean, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, eagerLoaded?: boolean, lazyLoadingEnabled?: boolean): RuntimeSkipNavigation;
    addTrigger(modelName: string): RuntimeTrigger;
    annotationsToDebugString(indent?: int): string;
    calculateCounts(): PropertyCounts;
    displayName(): string;
    displayName(omitSharedType: boolean): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findComplexProperty(name: string): RuntimeComplexProperty | undefined;
    findComplexProperty(name: string): IComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    findComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    findComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    findDeclaredForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<RuntimeForeignKey>;
    findDeclaredTrigger(modelName: string): RuntimeTrigger | undefined;
    findDiscriminatorProperty(): IProperty | undefined;
    findDiscriminatorProperty(): IReadOnlyProperty | undefined;
    findForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): RuntimeForeignKey | undefined;
    findIndex(properties: IReadOnlyList<IReadOnlyProperty>): RuntimeIndex | undefined;
    findIndex(name: string): RuntimeIndex | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findKey(properties: IReadOnlyList<IReadOnlyProperty>): RuntimeKey | undefined;
    findMember(name: string): RuntimePropertyBase | undefined;
    findMember(name: string): IPropertyBase | undefined;
    findMember(name: string): IReadOnlyPropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    findNavigation(name: string): RuntimeNavigation | undefined;
    findNavigationsInHierarchy(name: string): IEnumerable<RuntimeNavigation>;
    findProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    findProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    findProperty(name: string): RuntimeProperty | undefined;
    findProperty(memberInfo: MemberInfo): IProperty | undefined;
    findProperty(name: string): IProperty | undefined;
    findProperty(name: string): IReadOnlyProperty | undefined;
    findProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    findServicePropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeServiceProperty>;
    findServiceProperty(name: string): RuntimeServiceProperty | undefined;
    findSkipNavigation(name: string): RuntimeSkipNavigation | undefined;
    findSkipNavigationsInHierarchy(name: string): IEnumerable<RuntimeSkipNavigation>;
    getAnnotations(): IEnumerable<IAnnotation>;
    getChangeTrackingStrategy(): ChangeTrackingStrategy;
    getConstructorBindingConfigurationSource(): Nullable<ConfigurationSource>;
    getDeclaredForeignKeys(): List<RuntimeForeignKey>;
    getDeclaredIndexes(): IEnumerable<RuntimeIndex>;
    getDeclaredKeys(): IEnumerable<RuntimeKey>;
    getDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    getDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    getDiscriminatorValue(): unknown | undefined;
    getForeignKeys(): IEnumerable<RuntimeForeignKey>;
    getIndexes(): IEnumerable<RuntimeIndex>;
    getKeys(): IEnumerable<RuntimeKey>;
    getMembers(): IEnumerable<RuntimePropertyBase>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getPropertyAccessMode(): PropertyAccessMode;
    getRootType(): IReadOnlyTypeBase;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    getSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    isAbstract(): boolean;
    isAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    reparent(model: RuntimeModel): void;
    setCounts(counts: PropertyCounts): void;
    setPrimaryKey(key: RuntimeKey): void;
    setRelationshipSnapshotFactory(factory: Func<IInternalEntry, ISnapshot>): void;
    toString(): string;
}


export const RuntimeEntityType: {
    new(name: string, type_: Type, sharedClrType: boolean, model: RuntimeModel, baseType: RuntimeEntityType, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, derivedTypesCount: int, propertyCount: int, complexPropertyCount: int, foreignKeyCount: int, navigationCount: int, skipNavigationCount: int, servicePropertyCount: int, unnamedIndexCount: int, namedIndexCount: int, keyCount: int, triggerCount: int): RuntimeEntityType;
};


export interface __RuntimeEntityType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IEntityType(): IEntityType$instance;
    As_IRuntimeEntityType(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeEntityType$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyEntityType(): IReadOnlyEntityType$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeEntityType = RuntimeEntityType$instance & __RuntimeEntityType$views;


export interface RuntimeEntityTypeMappingFragment$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    readonly entityType: RuntimeEntityType;
    readonly isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly storeObject: StoreObjectIdentifier;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeEntityTypeMappingFragment: {
    new(entityType: RuntimeEntityType, storeObject: StoreObjectIdentifier, isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>): RuntimeEntityTypeMappingFragment;
};


export interface __RuntimeEntityTypeMappingFragment$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IEntityTypeMappingFragment(): IEntityTypeMappingFragment$instance;
    As_IReadOnlyEntityTypeMappingFragment(): IReadOnlyEntityTypeMappingFragment$instance;
}

export type RuntimeEntityTypeMappingFragment = RuntimeEntityTypeMappingFragment$instance & __RuntimeEntityTypeMappingFragment$views;


export interface RuntimeForeignKey$instance extends RuntimeAnnotatableBase {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly principalEntityType: RuntimeEntityType;
    readonly principalKey: RuntimeKey;
    readonly properties: IReadOnlyList<RuntimeProperty>;
    get referencingSkipNavigations(): ISet<RuntimeSkipNavigation> | undefined;
    set referencingSkipNavigations(value: ISet<RuntimeSkipNavigation>);
    addNavigation(navigation: RuntimeNavigation, onDependent: boolean): void;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeForeignKey: {
    new(dependentProperties: IReadOnlyList<RuntimeProperty>, principalKey: RuntimeKey, dependentEntityType: RuntimeEntityType, principalEntityType: RuntimeEntityType, deleteBehavior: DeleteBehavior, unique: boolean, required: boolean, requiredDependent: boolean, ownership: boolean): RuntimeForeignKey;
};


export interface __RuntimeForeignKey$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IForeignKey(): IForeignKey$instance;
    As_IRuntimeForeignKey(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeForeignKey$instance;
    As_IReadOnlyForeignKey(): IReadOnlyForeignKey$instance;
}

export type RuntimeForeignKey = RuntimeForeignKey$instance & __RuntimeForeignKey$views;


export interface RuntimeIndex$instance extends RuntimeAnnotatableBase {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly name: string;
    readonly properties: IReadOnlyList<RuntimeProperty>;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeIndex: {
    new(properties: IReadOnlyList<RuntimeProperty>, declaringEntityType: RuntimeEntityType, name: string, unique: boolean): RuntimeIndex;
};


export interface __RuntimeIndex$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IIndex(): IIndex$instance;
    As_IReadOnlyIndex(): IReadOnlyIndex$instance;
}

export type RuntimeIndex = RuntimeIndex$instance & __RuntimeIndex$views;


export interface RuntimeKey$instance extends RuntimeAnnotatableBase {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly properties: IReadOnlyList<RuntimeProperty>;
    get referencingForeignKeys(): ISet<RuntimeForeignKey> | undefined;
    set referencingForeignKeys(value: ISet<RuntimeForeignKey>);
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    setIdentityMapFactory(factory: Func<System_Internal.Boolean, IIdentityMap>): void;
    setPrincipalKeyValueFactory<TKey>(factory: IPrincipalKeyValueFactory_1<TKey>): void;
    toString(): string;
}


export const RuntimeKey: {
    new(properties: IReadOnlyList<RuntimeProperty>): RuntimeKey;
};


export interface __RuntimeKey$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IKey(): IKey$instance;
    As_IRuntimeKey(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeKey$instance;
    As_IReadOnlyKey(): IReadOnlyKey$instance;
}

export type RuntimeKey = RuntimeKey$instance & __RuntimeKey$views;


export interface RuntimeModel$instance extends RuntimeAnnotatableBase {
    readonly debugView: DebugView;
    modelId: Guid;
    addEntityType(name: string, type_: Type, baseType?: RuntimeEntityType, sharedClrType?: boolean, changeTrackingStrategy?: ChangeTrackingStrategy, indexerPropertyInfo?: PropertyInfo, propertyBag?: boolean, discriminatorProperty?: string, discriminatorValue?: unknown, derivedTypesCount?: int, propertyCount?: int, complexPropertyCount?: int, navigationCount?: int, skipNavigationCount?: int, servicePropertyCount?: int, foreignKeyCount?: int, unnamedIndexCount?: int, namedIndexCount?: int, keyCount?: int, triggerCount?: int): RuntimeEntityType;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addTypeMappingConfiguration(clrType: Type, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerPropertyType?: Type, valueConverter?: ValueConverter): RuntimeTypeMappingConfiguration;
    annotationsToDebugString(indent?: int): string;
    finalizeModel(): IModel;
    findAdHocEntityType(clrType: Type): RuntimeEntityType | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findEntityType(name: string): RuntimeEntityType | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAdHocEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddAdHocEntityType(entityType: RuntimeEntityType): RuntimeEntityType;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    setSkipDetectChanges(skipDetectChanges: boolean): void;
}


export const RuntimeModel: {
    new(): RuntimeModel;
    new(skipDetectChanges: boolean, modelId: Guid, entityTypeCount: int, typeConfigurationCount: int): RuntimeModel;
};


export interface __RuntimeModel$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IModel(): IModel$instance;
    As_IRuntimeModel(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeModel$instance;
    As_IReadOnlyModel(): IReadOnlyModel$instance;
}

export type RuntimeModel = RuntimeModel$instance & __RuntimeModel$views;


export interface RuntimeNavigation$instance extends RuntimePropertyBase$instance {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly declaringType: RuntimeTypeBase;
    readonly foreignKey: RuntimeForeignKey;
    readonly isCollection: boolean;
    readonly sentinel: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSetter(): IClrPropertySetter;
    getShadowIndex(): int;
    isShadowProperty(): boolean;
    setCollectionAccessor<TEntity, TCollection extends IEnumerable<TElement>, TElement>(getCollection: Func<TEntity, TCollection>, setCollection: Action<TEntity, TCollection>, setCollectionForMaterialization: Action<TEntity, TCollection>, createAndSetCollection: Func<TEntity, Action<TEntity, TCollection>, TCollection>, createCollection: Func<TCollection>): void;
    toString(): string;
}


export const RuntimeNavigation: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, foreignKey: RuntimeForeignKey, propertyAccessMode: PropertyAccessMode, eagerLoaded: boolean, lazyLoadingEnabled: boolean): RuntimeNavigation;
};


export interface __RuntimeNavigation$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_INavigation(): INavigation$instance;
    As_INavigationBase(): INavigationBase$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyNavigation(): IReadOnlyNavigation$instance;
    As_IReadOnlyNavigationBase(): IReadOnlyNavigationBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeNavigation = RuntimeNavigation$instance & __RuntimeNavigation$views;


export interface RuntimeProperty$instance extends RuntimePropertyBase$instance {
    readonly debugView: DebugView;
    readonly declaringType: RuntimeTypeBase;
    foreignKeys: ISet<RuntimeForeignKey>;
    indexes: List<RuntimeIndex>;
    readonly isCollection: boolean;
    readonly isPrimitiveCollection: boolean;
    get keys(): List<RuntimeKey> | undefined;
    set keys(value: List<RuntimeKey>);
    get primaryKey(): RuntimeKey | undefined;
    set primaryKey(value: RuntimeKey);
    readonly sentinel: unknown | undefined;
    typeMapping: CoreTypeMapping;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getElementType(): IElementType | undefined;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    getJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    getKeyValueComparer(): ValueComparer;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSetter(): IClrPropertySetter;
    getShadowIndex(): int;
    getValueComparer(): ValueComparer;
    isShadowProperty(): boolean;
    setComparer(valueComparer: ValueComparer): ValueComparer;
    setElementType(clrType: Type, nullable?: boolean, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerClrType?: Type, valueConverter?: ValueConverter, valueComparer?: ValueComparer, jsonValueReaderWriter?: JsonValueReaderWriter, typeMapping?: CoreTypeMapping): RuntimeElementType;
    setKeyComparer(valueComparer: ValueComparer): ValueComparer;
    setProviderValueComparer(valueComparer: ValueComparer): ValueComparer;
    setSentinelFromProviderValue(providerValue: unknown): void;
    setValueConverter(converter: ValueConverter): void;
    toString(): string;
}


export const RuntimeProperty: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringType: RuntimeTypeBase, propertyAccessMode: PropertyAccessMode, nullable: boolean, concurrencyToken: boolean, valueGenerated: ValueGenerated, beforeSaveBehavior: PropertySaveBehavior, afterSaveBehavior: PropertySaveBehavior, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>, valueConverter: ValueConverter, valueComparer: ValueComparer, keyValueComparer: ValueComparer, providerValueComparer: ValueComparer, jsonValueReaderWriter: JsonValueReaderWriter, typeMapping: CoreTypeMapping, sentinel: unknown): RuntimeProperty;
};


export interface __RuntimeProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IProperty(): IProperty$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyProperty(): IReadOnlyProperty$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeProperty = RuntimeProperty$instance & __RuntimeProperty$views;


export interface RuntimePropertyBase$instance extends RuntimeAnnotatableBase {
    readonly declaringType: RuntimeTypeBase;
    readonly isCollection: boolean;
    readonly name: string;
    readonly sentinel: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    setAccessors<TProperty>(currentValueGetter: Func<IInternalEntry, TProperty>, preStoreGeneratedCurrentValueGetter: Func<IInternalEntry, TProperty>, originalValueGetter: Func<IInternalEntry, TProperty>, relationshipSnapshotGetter: Func<IInternalEntry, TProperty>): void;
    setCurrentValueComparer(comparer: IComparer<IUpdateEntry>): void;
    setGetter<TEntity, TValue>(getClrValue: Func<TEntity, TValue>, hasSentinel: Func<TEntity, System_Internal.Boolean>): void;
    setGetter<TEntity, TStructural, TValue>(getClrValueUsingContainingEntity: Func<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, hasSentinelUsingContainingEntity: Func<TEntity, IReadOnlyList<System_Internal.Int32>, System_Internal.Boolean>, getClrValue: Func<TStructural, TValue>, hasSentinel: Func<TStructural, System_Internal.Boolean>): void;
    setIndexedCollectionAccessor<TEntity, TCollection extends IList<TElement>, TElement>(get_: Func<TEntity, System_Internal.Int32, TElement>, set_: Action<TEntity, System_Internal.Int32, TElement>, setForMaterialization: Action<TEntity, System_Internal.Int32, TElement>, createCollection: Func<System_Internal.Int32, TCollection>): void;
    setMaterializationSetter<TEntity, TStructural, TValue>(setClrValueUsingContainingEntity: Action<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, setClrValue: Func<TStructural, TValue, TStructural>): void;
    setMaterializationSetter<TEntity, TValue>(setClrValue: Func<TEntity, TValue, TEntity>): void;
    setPropertyIndexes(index: int, originalValueIndex: int, shadowIndex: int, relationshipIndex: int, storeGenerationIndex: int): void;
    setSetter<TEntity, TStructural, TValue>(setClrValueUsingContainingEntity: Action<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, setClrValue: Func<TStructural, TValue, TStructural>): void;
    setSetter<TEntity, TValue>(setClrValue: Func<TEntity, TValue, TEntity>): void;
}


export const RuntimePropertyBase: {
};


export interface __RuntimePropertyBase$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimePropertyBase = RuntimePropertyBase$instance & __RuntimePropertyBase$views;


export interface RuntimeRelationalPropertyOverrides$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    readonly property: RuntimeProperty;
    readonly storeObject: StoreObjectIdentifier;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeRelationalPropertyOverrides: {
    new(property: RuntimeProperty, storeObject: StoreObjectIdentifier, columnNameOverridden: boolean, columnName: string): RuntimeRelationalPropertyOverrides;
};


export interface __RuntimeRelationalPropertyOverrides$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyRelationalPropertyOverrides(): IReadOnlyRelationalPropertyOverrides$instance;
    As_IRelationalPropertyOverrides(): IRelationalPropertyOverrides$instance;
}

export type RuntimeRelationalPropertyOverrides = RuntimeRelationalPropertyOverrides$instance & __RuntimeRelationalPropertyOverrides$views;


export interface RuntimeSequence$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    readonly model: RuntimeModel;
    readonly modelSchema: string | undefined;
    readonly name: string;
    readonly schema: string;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeSequence: {
    new(name: string, model: RuntimeModel, type_: Type, schema: string, startValue: long, incrementBy: int, cyclic: boolean, minValue: Nullable<System_Internal.Int64>, maxValue: Nullable<System_Internal.Int64>, modelSchemaIsNull: boolean): RuntimeSequence;
};


export interface __RuntimeSequence$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlySequence(): IReadOnlySequence$instance;
    As_ISequence(): ISequence$instance;
}

export type RuntimeSequence = RuntimeSequence$instance & __RuntimeSequence$views;


export interface RuntimeServiceProperty$instance extends RuntimePropertyBase$instance {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly declaringType: RuntimeTypeBase;
    readonly isCollection: boolean;
    parameterBinding: ServiceParameterBinding;
    readonly sentinel: unknown | undefined;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSetter(): IClrPropertySetter;
    getShadowIndex(): int;
    isShadowProperty(): boolean;
    toString(): string;
}


export const RuntimeServiceProperty: {
    new(name: string, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, serviceType: Type, declaringEntityType: RuntimeEntityType, propertyAccessMode: PropertyAccessMode): RuntimeServiceProperty;
};


export interface __RuntimeServiceProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
    As_IReadOnlyServiceProperty(): IReadOnlyServiceProperty$instance;
    As_IServiceProperty(): IServiceProperty$instance;
}

export type RuntimeServiceProperty = RuntimeServiceProperty$instance & __RuntimeServiceProperty$views;


export interface RuntimeSkipNavigation$instance extends RuntimePropertyBase$instance {
    readonly debugView: DebugView;
    readonly declaringEntityType: RuntimeEntityType;
    readonly declaringType: RuntimeTypeBase;
    inverse: RuntimeSkipNavigation;
    readonly isCollection: boolean;
    readonly sentinel: unknown | undefined;
    readonly targetEntityType: RuntimeEntityType;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): IAnnotation | undefined;
    findAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getCollectionAccessor(): IClrCollectionAccessor | undefined;
    getCurrentValueComparer(): IComparer<IUpdateEntry>;
    getFieldName(): string | undefined;
    getGetter(): IClrPropertyGetter;
    getIndex(): int;
    getIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    getMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getPropertyAccessMode(): PropertyAccessMode;
    getRuntimeAnnotations(): IEnumerable<IAnnotation>;
    getSetter(): IClrPropertySetter;
    getShadowIndex(): int;
    isShadowProperty(): boolean;
    setCollectionAccessor<TEntity, TCollection extends IEnumerable<TElement>, TElement>(getCollection: Func<TEntity, TCollection>, setCollection: Action<TEntity, TCollection>, setCollectionForMaterialization: Action<TEntity, TCollection>, createAndSetCollection: Func<TEntity, Action<TEntity, TCollection>, TCollection>, createCollection: Func<TCollection>): void;
    toString(): string;
}


export const RuntimeSkipNavigation: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringEntityType: RuntimeEntityType, targetEntityType: RuntimeEntityType, foreignKey: RuntimeForeignKey, collection: boolean, onDependent: boolean, propertyAccessMode: PropertyAccessMode, eagerLoaded: boolean, lazyLoadingEnabled: boolean): RuntimeSkipNavigation;
};


export interface __RuntimeSkipNavigation$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_INavigationBase(): INavigationBase$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IRuntimeSkipNavigation(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeSkipNavigation$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyNavigationBase(): IReadOnlyNavigationBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
    As_IReadOnlySkipNavigation(): IReadOnlySkipNavigation$instance;
    As_ISkipNavigation(): ISkipNavigation$instance;
}

export type RuntimeSkipNavigation = RuntimeSkipNavigation$instance & __RuntimeSkipNavigation$views;


export interface RuntimeStoredProcedure$instance extends AnnotatableBase {
    readonly debugView: DebugView;
    entityType: RuntimeEntityType;
    addParameter(name: string, direction: ParameterDirection, forRowsAffected: boolean, propertyName: string, forOriginalValue: Nullable<System_Internal.Boolean>): RuntimeStoredProcedureParameter;
    addResultColumn(name: string, forRowsAffected: boolean, propertyName: string): RuntimeStoredProcedureResultColumn;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<Annotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeStoredProcedure: {
    new(entityType: RuntimeEntityType, name: string, schema: string, rowsAffectedReturned: boolean): RuntimeStoredProcedure;
};


export interface __RuntimeStoredProcedure$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyStoredProcedure(): IReadOnlyStoredProcedure$instance;
    As_IStoredProcedure(): IStoredProcedure$instance;
}

export type RuntimeStoredProcedure = RuntimeStoredProcedure$instance & __RuntimeStoredProcedure$views;


export interface RuntimeTrigger$instance extends RuntimeAnnotatableBase {
    readonly debugView: DebugView;
    readonly entityType: IEntityType;
    readonly modelName: string;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    toString(): string;
}


export const RuntimeTrigger: {
    new(entityType: RuntimeEntityType, modelName: string): RuntimeTrigger;
};


export interface __RuntimeTrigger$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyTrigger(): IReadOnlyTrigger$instance;
    As_ITrigger(): ITrigger$instance;
}

export type RuntimeTrigger = RuntimeTrigger$instance & __RuntimeTrigger$views;


export interface RuntimeTypeBase$instance extends RuntimeAnnotatableBase {
    readonly baseType: RuntimeTypeBase | undefined;
    readonly clrType: Type;
    get constructorBinding(): InstantiationBinding | undefined;
    set constructorBinding(value: InstantiationBinding);
    readonly emptyShadowValuesFactory: Func<ISnapshot>;
    model: RuntimeModel;
    readonly name: string;
    readonly originalValuesFactory: Func<IInternalEntry, ISnapshot>;
    readonly shadowValuesFactory: Func<IDictionary<System_Internal.String, unknown | undefined>, ISnapshot>;
    readonly storeGeneratedValuesFactory: Func<ISnapshot>;
    readonly temporaryValuesFactory: Func<IInternalEntry, ISnapshot>;
    addComplexProperty(name: string, clrType: Type, targetTypeName: string, targetType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, nullable?: boolean, collection?: boolean, changeTrackingStrategy?: ChangeTrackingStrategy, indexerPropertyInfo?: PropertyInfo, propertyBag?: boolean, discriminatorProperty?: string, discriminatorValue?: unknown, propertyCount?: int, complexPropertyCount?: int): RuntimeComplexProperty;
    addProperty(name: string, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, nullable?: boolean, concurrencyToken?: boolean, valueGenerated?: ValueGenerated, beforeSaveBehavior?: PropertySaveBehavior, afterSaveBehavior?: PropertySaveBehavior, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerPropertyType?: Type, valueGeneratorFactory?: Func<IProperty, ITypeBase, ValueGenerator>, valueConverter?: ValueConverter, valueComparer?: ValueComparer, keyValueComparer?: ValueComparer, providerValueComparer?: ValueComparer, jsonValueReaderWriter?: JsonValueReaderWriter, typeMapping?: CoreTypeMapping, sentinel?: unknown): RuntimeProperty;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    calculateCounts(): PropertyCounts;
    finalizeType(): void;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findComplexPropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeComplexProperty>;
    findComplexProperty(name: string): RuntimeComplexProperty | undefined;
    findIndexerPropertyInfo(): PropertyInfo | undefined;
    findMember(name: string): RuntimePropertyBase | undefined;
    findMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    findProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    findPropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeProperty>;
    findProperty(name: string): RuntimeProperty | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    getDeclaredComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    getDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    getDeclaredProperties(): IEnumerable<RuntimeProperty>;
    getDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    getFlattenedComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    getFlattenedDeclaredProperties(): IEnumerable<RuntimeProperty>;
    getFlattenedProperties(): IEnumerable<RuntimeProperty>;
    getFlattenedValueGeneratingProperties(): IEnumerable<RuntimeProperty>;
    getMembers(): IEnumerable<RuntimePropertyBase>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
    getSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    setEmptyShadowValuesFactory(factory: Func<ISnapshot>): void;
    setOriginalValuesFactory(factory: Func<IInternalEntry, ISnapshot>): void;
    setShadowValuesFactory(factory: Func<IDictionary<System_Internal.String, unknown>, ISnapshot>): void;
    setStoreGeneratedValuesFactory(factory: Func<ISnapshot>): void;
    setTemporaryValuesFactory(factory: Func<IInternalEntry, ISnapshot>): void;
}


export const RuntimeTypeBase: {
    findIndexerProperty(type_: Type): PropertyInfo | undefined;
};


export interface __RuntimeTypeBase$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeTypeBase = RuntimeTypeBase$instance & __RuntimeTypeBase$views;


export interface RuntimeTypeMappingConfiguration$instance extends RuntimeAnnotatableBase {
    readonly clrType: Type;
    addRuntimeAnnotation(name: string, value: unknown): Annotation;
    addRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    annotationsToDebugString(indent?: int): string;
    findAnnotation(name: string): Annotation | undefined;
    findAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotation(name: string): Annotation | undefined;
    findRuntimeAnnotation(name: string): IAnnotation | undefined;
    findRuntimeAnnotationValue(name: string): unknown | undefined;
    getAnnotations(): IEnumerable<IAnnotation>;
    getOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    getRuntimeAnnotations(): IEnumerable<Annotation>;
}


export const RuntimeTypeMappingConfiguration: {
    new(clrType: Type, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueConverter: ValueConverter): RuntimeTypeMappingConfiguration;
};


export interface __RuntimeTypeMappingConfiguration$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_ITypeMappingConfiguration(): ITypeMappingConfiguration$instance;
}

export type RuntimeTypeMappingConfiguration = RuntimeTypeMappingConfiguration$instance & __RuntimeTypeMappingConfiguration$views;


export interface ServiceParameterBinding$instance extends ParameterBinding {
    readonly serviceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    readonly serviceType: Type;
    bindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    bindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
}


export const ServiceParameterBinding: {
};


export type ServiceParameterBinding = ServiceParameterBinding$instance;

export interface ServiceParameterBindingFactory$instance {
    bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    canBind(parameterType: Type, parameterName: string): boolean;
}


export const ServiceParameterBindingFactory: {
    new(serviceType: Type): ServiceParameterBindingFactory;
};


export interface __ServiceParameterBindingFactory$views {
    As_IParameterBindingFactory(): IParameterBindingFactory$instance;
}

export type ServiceParameterBindingFactory = ServiceParameterBindingFactory$instance & __ServiceParameterBindingFactory$views;


export interface SimpleModelFactory$instance {
    create(): IMutableModel;
}


export const SimpleModelFactory: {
    new(): SimpleModelFactory;
};


export type SimpleModelFactory = SimpleModelFactory$instance;

export interface StoreObjectDictionary_1$instance<T> {
    add(storeObject: StoreObjectIdentifier, value: T): void;
    find(storeObject: StoreObjectIdentifier): T | undefined;
    getValues(): IEnumerable<T>;
    remove(storeObject: StoreObjectIdentifier): T | undefined;
}


export const StoreObjectDictionary_1: {
    new<T>(): StoreObjectDictionary_1<T>;
};


export interface __StoreObjectDictionary_1$views<T> {
    As_IReadOnlyStoreObjectDictionary_1(): IReadOnlyStoreObjectDictionary_1$instance<T>;
}

export type StoreObjectDictionary_1<T> = StoreObjectDictionary_1$instance<T> & __StoreObjectDictionary_1$views<T>;


export interface TypeBaseNameComparer$instance {
    compare(x: IReadOnlyTypeBase, y: IReadOnlyTypeBase): int;
    equals(x: IReadOnlyTypeBase, y: IReadOnlyTypeBase): boolean;
    getHashCode(obj: IReadOnlyTypeBase): int;
}


export const TypeBaseNameComparer: {
    new(): TypeBaseNameComparer;
    readonly instance: TypeBaseNameComparer;
};


export type TypeBaseNameComparer = TypeBaseNameComparer$instance;

export abstract class ConfigurationSourceExtensions$instance {
    static max(left: ConfigurationSource, right: Nullable<ConfigurationSource>): ConfigurationSource;
    static max(left: Nullable<ConfigurationSource>, right: Nullable<ConfigurationSource>): Nullable<ConfigurationSource>;
    static overrides(newConfigurationSource: ConfigurationSource, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static overrides(newConfigurationSource: Nullable<ConfigurationSource>, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static overridesStrictly(newConfigurationSource: ConfigurationSource, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static overridesStrictly(newConfigurationSource: Nullable<ConfigurationSource>, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
}


export type ConfigurationSourceExtensions = ConfigurationSourceExtensions$instance;

export abstract class RelationalAnnotationNames$instance {
    static readonly allNames: ISet<System_Internal.String>;
    static readonly prefix: string;
    static readonly columnName: string;
    static readonly columnOrder: string;
    static readonly columnType: string;
    static readonly defaultValueSql: string;
    static readonly computedColumnSql: string;
    static readonly isStored: string;
    static readonly defaultValue: string;
    static readonly defaultConstraintName: string;
    static readonly useNamedDefaultConstraints: string;
    static readonly tableName: string;
    static readonly schema: string;
    static readonly viewName: string;
    static readonly viewSchema: string;
    static readonly functionName: string;
    static readonly deleteStoredProcedure: string;
    static readonly insertStoredProcedure: string;
    static readonly updateStoredProcedure: string;
    static readonly sqlQuery: string;
    static readonly comment: string;
    static readonly collation: string;
    static readonly defaultSchema: string;
    static readonly name: string;
    static readonly sequencePrefix: string;
    static readonly sequences: string;
    static readonly checkConstraints: string;
    static readonly filter: string;
    static readonly dbFunctions: string;
    static readonly maxIdentifierLength: string;
    static readonly isFixedLength: string;
    static readonly viewDefinitionSql: string;
    static readonly isTableExcludedFromMigrations: string;
    static readonly mappingStrategy: string;
    static readonly tpcMappingStrategy: string;
    static readonly tphMappingStrategy: string;
    static readonly tptMappingStrategy: string;
    static readonly relationalModel: string;
    static readonly relationalModelFactory: string;
    static readonly defaultMappings: string;
    static readonly defaultColumnMappings: string;
    static readonly tableMappings: string;
    static readonly tableColumnMappings: string;
    static readonly viewMappings: string;
    static readonly viewColumnMappings: string;
    static readonly functionMappings: string;
    static readonly functionColumnMappings: string;
    static readonly insertStoredProcedureMappings: string;
    static readonly insertStoredProcedureResultColumnMappings: string;
    static readonly insertStoredProcedureParameterMappings: string;
    static readonly deleteStoredProcedureMappings: string;
    static readonly deleteStoredProcedureParameterMappings: string;
    static readonly updateStoredProcedureMappings: string;
    static readonly updateStoredProcedureResultColumnMappings: string;
    static readonly updateStoredProcedureParameterMappings: string;
    static readonly sqlQueryMappings: string;
    static readonly sqlQueryColumnMappings: string;
    static readonly foreignKeyMappings: string;
    static readonly tableIndexMappings: string;
    static readonly uniqueConstraintMappings: string;
    static readonly mappingFragments: string;
    static readonly relationalOverrides: string;
    static readonly modelDependencies: string;
    static readonly fieldValueGetter: string;
    static readonly containerColumnName: string;
    static readonly containerColumnType: string;
    static readonly containerColumnTypeMapping: string;
    static readonly jsonPropertyName: string;
    static readonly storeType: string;
}


export type RelationalAnnotationNames = RelationalAnnotationNames$instance;

