// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Metadata
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IDependentsMap, IIdentityMap, IInternalEntry, ISnapshot } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { IDependentKeyValueFactory, IDependentKeyValueFactory_1, IPrincipalKeyValueFactory, IPrincipalKeyValueFactory_1, ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { QualifiedName } from "../../Microsoft.EntityFrameworkCore.Design.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { AnnotatableBase, Annotation, DebugView, IAnnotatable, IAnnotation, IReadOnlyAnnotatable, MetadataDebugStringOptions, RuntimeAnnotatableBase, RuntimeModelDependencies } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { ICollectionLoader } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import type { IConventionAnnotatableBuilder, IConventionCheckConstraintBuilder, IConventionComplexPropertyBuilder, IConventionComplexTypeBuilder, IConventionDbFunctionBuilder, IConventionDbFunctionParameterBuilder, IConventionElementTypeBuilder, IConventionEntityTypeBuilder, IConventionEntityTypeMappingFragmentBuilder, IConventionForeignKeyBuilder, IConventionIndexBuilder, IConventionKeyBuilder, IConventionModelBuilder, IConventionNavigationBuilder, IConventionPropertyBuilder, IConventionRelationalPropertyOverridesBuilder, IConventionSequenceBuilder, IConventionServicePropertyBuilder, IConventionSkipNavigationBuilder, IConventionStoredProcedureBuilder, IConventionStoredProcedureParameterBuilder, IConventionStoredProcedureResultColumnBuilder, IConventionTriggerBuilder, IConventionTypeBaseBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Builders/internal/index.js";
import type { ConventionSet, IConventionBatch } from "../../Microsoft.EntityFrameworkCore.Metadata.Conventions/internal/index.js";
import type { IRuntimeEntityType, IRuntimeTypeBase, PropertyAccessors, PropertyCounts, PropertyIndexes, RuntimeStoredProcedureParameter, RuntimeStoredProcedureResultColumn, TableBase } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import type { ReferentialAction } from "../../Microsoft.EntityFrameworkCore.Migrations/internal/index.js";
import type { SqlExpression } from "../../Microsoft.EntityFrameworkCore.Query.SqlExpressions/internal/index.js";
import type { IStructuralTypeMaterializerSource, StructuralTypeMaterializerSourceParameters } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { JsonValueReaderWriter } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { ValueConverter } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { CoreTypeMapping, MaterializationContext, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { IUpdateEntry } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { ValueGenerator } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import type { ChangeTrackingStrategy, DeleteBehavior, ModelCreationDependencies, PropertyAccessMode, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IComparer, IDictionary, IEnumerable, IEqualityComparer, IList, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList, ISet, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ParameterDirection } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Enum, Func, Guid, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression, ParameterExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, ParameterInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection.js";

export enum ConfigurationSource {
    Explicit = 0,
    DataAnnotation = 1,
    Convention = 2
}


export enum PropertySaveBehavior {
    Save = 0,
    Ignore = 1,
    Throw = 2
}


export enum StoreObjectType {
    Table = 0,
    View = 1,
    SqlQuery = 2,
    Function = 3,
    InsertStoredProcedure = 4,
    DeleteStoredProcedure = 5,
    UpdateStoredProcedure = 6
}


export enum ValueGenerated {
    Never = 0,
    OnAdd = 1,
    OnUpdate = 2,
    OnUpdateSometimes = 4,
    OnAddOrUpdate = 3
}


export interface IAdHocMapper$instance {
    GetOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export type IAdHocMapper = IAdHocMapper$instance;

export interface ICheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IAnnotatable {
    readonly EntityType: IEntityType;
    readonly ModelName: string;
    readonly Name: string | undefined;
    readonly Sql: string;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDefaultName(): string | undefined;
    GetName(storeObject: StoreObjectIdentifier): string | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ICheckConstraint = ICheckConstraint$instance;

export interface IClrCollectionAccessor$instance {
    readonly CollectionType: Type;
    Add(entity: unknown, value: unknown, forMaterialization: boolean): boolean;
    Contains(entity: unknown, value: unknown): boolean;
    Create(): unknown;
    GetOrCreate(entity: unknown, forMaterialization: boolean): unknown;
}


export type IClrCollectionAccessor = IClrCollectionAccessor$instance;

export interface IClrIndexedCollectionAccessor$instance {
    Create(capacity: int): unknown;
    Get(entity: unknown, index: int): unknown | undefined;
    Set(entity: unknown, index: int, value: unknown, forMaterialization: boolean): void;
}


export type IClrIndexedCollectionAccessor = IClrIndexedCollectionAccessor$instance;

export interface IClrPropertyGetter$instance {
    GetClrValueUsingContainingEntity(entity: unknown, indices: IReadOnlyList<System_Internal.Int32>): unknown | undefined;
    GetClrValueUsingContainingEntity(entity: unknown): unknown | undefined;
    HasSentinelValueUsingContainingEntity(entity: unknown, indices: IReadOnlyList<System_Internal.Int32>): boolean;
    HasSentinelValueUsingContainingEntity(entity: unknown): boolean;
}


export type IClrPropertyGetter = IClrPropertyGetter$instance;

export interface IClrPropertySetter$instance {
    SetClrValue(instance: unknown, value: unknown): unknown;
    SetClrValueUsingContainingEntity(instance: unknown, indices: IReadOnlyList<System_Internal.Int32>, value: unknown): void;
    SetClrValueUsingContainingEntity(instance: unknown, value: unknown): void;
}


export type IClrPropertySetter = IClrPropertySetter$instance;

export interface IColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Table: ITable;
    readonly PropertyMappings: IReadOnlyList<IColumnMapping>;
    readonly MaxLength: Nullable<System_Internal.Int32>;
    readonly Precision: Nullable<System_Internal.Int32>;
    readonly Scale: Nullable<System_Internal.Int32>;
    readonly IsUnicode: Nullable<System_Internal.Boolean>;
    readonly IsFixedLength: Nullable<System_Internal.Boolean>;
    readonly IsRowVersion: boolean;
    readonly Order: Nullable<System_Internal.Int32>;
    readonly DefaultValue: unknown | undefined;
    readonly DefaultValueSql: string | undefined;
    readonly ComputedColumnSql: string | undefined;
    readonly IsStored: Nullable<System_Internal.Boolean>;
    readonly Comment: string | undefined;
    readonly Collation: string | undefined;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMapping | undefined;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    TryGetDefaultValue(defaultValue: unknown): boolean;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumn = IColumn$instance;

export interface IColumnBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly PropertyMappings: IReadOnlyList<IColumnMappingBase>;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnBase = IColumnBase$instance;

export interface IColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Column: IColumn;
    readonly TableMapping: ITableMapping;
    readonly Property: IProperty;
    readonly TypeMapping: RelationalTypeMapping;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnMapping = IColumnMapping$instance;

export interface IColumnMappingBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Property: IProperty;
    readonly Column: IColumnBase;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IColumnMappingBase = IColumnMappingBase$instance;

export interface IComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly ComplexType: IComplexType;
    readonly IsNullable: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IComplexProperty = IComplexProperty$instance;

export interface IComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, ITypeBase, IAnnotatable {
    readonly ComplexProperty: IComplexProperty;
    readonly BaseType: IComplexType | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    readonly ConstructorBinding: InstantiationBinding | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindComplexProperty(name: string): IComplexProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindDiscriminatorProperty(): IProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMember(name: string): IPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IProperty | undefined;
    FindProperty(name: string): IProperty | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IComplexType>;
    GetDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDerivedTypes(): IEnumerable<ITypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyComplexType;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsContainedBy(type: Type): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindComplexProperty2(name: string): IComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindDiscriminatorProperty2(): IProperty | undefined;
    FindMember2(name: string): IPropertyBase | undefined;
    FindProperty2(name: string): IProperty | undefined;
    FindProperty3(memberInfo: MemberInfo): IProperty | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRootType2(): IReadOnlyTypeBase;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IComplexType = IComplexType$instance;

export interface IConstructorBindingFactory$instance {
    GetBindings(entityType: IConventionEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    GetBindings(entityType: IMutableEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    GetBindings(complexType: IReadOnlyComplexType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    GetBindings(entityType: IReadOnlyEntityType, constructorBinding: InstantiationBinding, serviceOnlyBinding: InstantiationBinding): void;
    TryBindConstructor(entityType: IConventionEntityType, constructor: ConstructorInfo, binding: InstantiationBinding, unboundParameters: IEnumerable<ParameterInfo>): boolean;
    TryBindConstructor(entityType: IMutableEntityType, constructor: ConstructorInfo, binding: InstantiationBinding, unboundParameters: IEnumerable<ParameterInfo>): boolean;
}


export type IConstructorBindingFactory = IConstructorBindingFactory$instance;

export interface IConventionAnnotatable$instance extends IReadOnlyAnnotatable {
    readonly Builder: IConventionAnnotatableBuilder;
    readonly IsInModel: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IConventionAnnotatable = IConventionAnnotatable$instance;

export interface IConventionAnnotation$instance extends IAnnotation {
    readonly Name: string;
    readonly Value: unknown | undefined;
    GetConfigurationSource(): ConfigurationSource;
}


export interface IConventionAnnotation$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotation$instance {}

export type IConventionAnnotation = IConventionAnnotation$instance;

export interface IConventionCheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionCheckConstraintBuilder;
    readonly EntityType: IConventionEntityType;
    readonly ModelName: string;
    readonly Name: string | undefined;
    readonly Sql: string;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetDefaultName(): string | undefined;
    GetName(storeObject: StoreObjectIdentifier): string | undefined;
    GetNameConfigurationSource(): Nullable<ConfigurationSource>;
    SetName(name: string, fromDataAnnotation?: boolean): string | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionCheckConstraint = IConventionCheckConstraint$instance;

export interface IConventionComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly Builder: IConventionComplexPropertyBuilder;
    readonly ComplexType: IConventionComplexType;
    readonly IsNullable: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldName(): string | undefined;
    GetIsNullableConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionComplexProperty = IConventionComplexProperty$instance;

export interface IConventionComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionTypeBase, IConventionAnnotatable {
    readonly Builder: IConventionComplexTypeBuilder;
    readonly ComplexProperty: IConventionComplexProperty;
    readonly BaseType: IConventionComplexType | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    AddProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    FindComplexProperty(name: string): IConventionComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IConventionProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IConventionPropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    FindProperty(name: string): IConventionProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IConventionComplexType>;
    GetDerivedTypes(): IEnumerable<IConventionTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IConventionComplexType;
    GetRootType(): IConventionTypeBase;
    GetRootType(): IReadOnlyComplexType;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsContainedBy(type: Type): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    RemoveIgnored(memberName: string): string | undefined;
    RemoveProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    SetBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
    SetDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    SetDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    FindComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    FindMember2(name: string): IReadOnlyPropertyBase | undefined;
    FindProperty2(name: string): IReadOnlyProperty | undefined;
    FindProperty3(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetRootType2(): IReadOnlyTypeBase;
    RemoveDiscriminatorValue(): unknown | undefined;
}


export type IConventionComplexType = IConventionComplexType$instance;

export interface IConventionDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Model: IConventionModel;
    readonly Builder: IConventionDbFunctionBuilder;
    readonly Parameters: IReadOnlyList<IConventionDbFunctionParameter>;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly ModelName: string;
    readonly MethodInfo: MethodInfo | undefined;
    readonly IsBuiltIn: boolean;
    readonly IsScalar: boolean;
    readonly IsAggregate: boolean;
    readonly IsNullable: boolean;
    readonly StoreType: string | undefined;
    readonly ReturnType: Type;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly Translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetNameConfigurationSource(): Nullable<ConfigurationSource>;
    SetIsBuiltIn(builtIn: boolean, fromDataAnnotation?: boolean): boolean;
    SetName(name: string, fromDataAnnotation?: boolean): string | undefined;
    SetTranslation(translation: Func<IReadOnlyList<SqlExpression>, SqlExpression>, fromDataAnnotation?: boolean): Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    SetTypeMapping(typeMapping: RelationalTypeMapping, fromDataAnnotation?: boolean): RelationalTypeMapping | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionDbFunction = IConventionDbFunction$instance;

export interface IConventionDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Function: IConventionDbFunction;
    readonly Builder: IConventionDbFunctionParameterBuilder;
    readonly Name: string;
    readonly ClrType: Type;
    readonly StoreType: string;
    readonly PropagatesNullability: boolean;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetStoreTypeConfigurationSource(): Nullable<ConfigurationSource>;
    SetStoreType(storeType: string, fromDataAnnotation?: boolean): string | undefined;
    SetTypeMapping(typeMapping: RelationalTypeMapping, fromDataAnnotation?: boolean): RelationalTypeMapping | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionDbFunctionParameter = IConventionDbFunctionParameter$instance;

export interface IConventionElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly CollectionProperty: IConventionProperty;
    readonly Builder: IConventionElementTypeBuilder;
    readonly ClrType: Type;
    readonly IsNullable: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetIsNullableConfigurationSource(): Nullable<ConfigurationSource>;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    SetIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    SetTypeMapping(typeMapping: CoreTypeMapping, fromDataAnnotation?: boolean): CoreTypeMapping | undefined;
    SetValueComparer(comparer: ValueComparer, fromDataAnnotation?: boolean): ValueComparer | undefined;
    SetValueConverter(converter: ValueConverter, fromDataAnnotation?: boolean): ValueConverter | undefined;
    SetValueConverter(converterType: Type, fromDataAnnotation?: boolean): Type | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
}


export type IConventionElementType = IConventionElementType$instance;

export interface IConventionEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionTypeBase, IConventionAnnotatable {
    readonly Builder: IConventionEntityTypeBuilder;
    readonly BaseType: IConventionEntityType | undefined;
    readonly IsKeyless: boolean;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddForeignKey(property: IConventionProperty, principalKey: IConventionKey, principalEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    AddForeignKey(properties: IReadOnlyList<IConventionProperty>, principalKey: IConventionKey, principalEntityType: IConventionEntityType, setComponentConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    AddIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    AddIndex(property: IConventionProperty, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    AddIndex(property: IConventionProperty, name: string, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    AddIndex(properties: IReadOnlyList<IConventionProperty>, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    AddIndex(properties: IReadOnlyList<IConventionProperty>, name: string, fromDataAnnotation?: boolean): IConventionIndex | undefined;
    AddProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddServiceProperty(memberInfo: MemberInfo, serviceType?: Type, fromDataAnnotation?: boolean): IConventionServiceProperty;
    AddSkipNavigation(name: string, navigationType: Type, memberInfo: MemberInfo, targetEntityType: IConventionEntityType, collection: boolean, onDependent: boolean, fromDataAnnotation?: boolean): IConventionSkipNavigation | undefined;
    AddTrigger(name: string, fromDataAnnotation?: boolean): IConventionTrigger | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IConventionEntityType | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    FindComplexProperty(name: string): IConventionComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    FindDeclaredTrigger(name: string): IConventionTrigger | undefined;
    FindDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    FindDiscriminatorProperty(): IConventionProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IConventionForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IConventionForeignKey | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IConventionForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IConventionForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    FindIndex(property: IReadOnlyProperty): IConventionIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IConventionIndex | undefined;
    FindIndex(name: string): IConventionIndex | undefined;
    FindIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    FindIndex(name: string): IReadOnlyIndex | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindKey(property: IReadOnlyProperty): IConventionKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IConventionKey | undefined;
    FindKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    FindMember(name: string): IConventionPropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    FindNavigation(memberInfo: MemberInfo): IConventionNavigation | undefined;
    FindNavigation(name: string): IConventionNavigation | undefined;
    FindNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    FindNavigation(name: string): IReadOnlyNavigation | undefined;
    FindOwnership(): IConventionForeignKey | undefined;
    FindOwnership(): IReadOnlyForeignKey | undefined;
    FindPrimaryKey(): IConventionKey | undefined;
    FindPrimaryKey(): IReadOnlyKey | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    FindProperty(name: string): IConventionProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindServiceProperty(name: string): IConventionServiceProperty | undefined;
    FindServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IConventionSkipNavigation | undefined;
    FindSkipNavigation(name: string): IConventionSkipNavigation | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    FindSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    GetAllBaseTypes(): IEnumerable<IConventionEntityType>;
    GetAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetConfigurationSource(): ConfigurationSource;
    GetDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    GetDiscriminatorValue(): unknown | undefined;
    GetIsDiscriminatorMappingComplete(): boolean;
    GetNavigationAccessMode(): PropertyAccessMode;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetQueryFilter(): LambdaExpression | undefined;
    GetQueryFilterConfigurationSource(): Nullable<ConfigurationSource>;
    GetQueryFilterConfigurationSource(filterKey: string): Nullable<ConfigurationSource>;
    GetRootType(): IConventionEntityType;
    GetRootType(): IConventionTypeBase;
    GetRootType(): IReadOnlyEntityType;
    GetRootType(): IReadOnlyTypeBase;
    GetSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    IsAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    RemoveForeignKey(foreignKey: IReadOnlyForeignKey): IConventionForeignKey | undefined;
    RemoveForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IConventionKey, principalEntityType: IConventionEntityType): IConventionForeignKey | undefined;
    RemoveIgnored(memberName: string): string | undefined;
    RemoveIndex(index: IReadOnlyIndex): IConventionIndex | undefined;
    RemoveKey(key: IReadOnlyKey): IConventionKey | undefined;
    RemoveProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    RemoveServiceProperty(property: IReadOnlyServiceProperty): IConventionServiceProperty | undefined;
    RemoveSkipNavigation(navigation: IReadOnlySkipNavigation): IConventionSkipNavigation | undefined;
    SetBaseType(entityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    SetBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    SetDiscriminatorMappingComplete(complete: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    SetDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    SetDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    SetPrimaryKey(property: IConventionProperty, fromDataAnnotation?: boolean): IConventionKey | undefined;
    SetPrimaryKey(properties: IReadOnlyList<IConventionProperty>, fromDataAnnotation?: boolean): IConventionKey | undefined;
    SetQueryFilter(queryFilter: LambdaExpression, fromDataAnnotation?: boolean): LambdaExpression | undefined;
    SetQueryFilter(filterKey: string, filter: LambdaExpression, fromDataAnnotation?: boolean): IQueryFilter | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    FindComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    FindIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    FindMember2(name: string): IReadOnlyPropertyBase | undefined;
    FindProperty2(name: string): IReadOnlyProperty | undefined;
    FindProperty3(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetDerivedTypes(): IEnumerable<IConventionTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType2(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    RemoveDiscriminatorValue(): unknown | undefined;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
}


export type IConventionEntityType = IConventionEntityType$instance;

export interface IConventionEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly EntityType: IConventionEntityType;
    readonly Builder: IConventionEntityTypeMappingFragmentBuilder;
    readonly StoreObject: StoreObjectIdentifier;
    readonly IsTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetIsTableExcludedFromMigrationsConfigurationSource(): Nullable<ConfigurationSource>;
    SetIsTableExcludedFromMigrations(excluded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionEntityTypeMappingFragment = IConventionEntityTypeMappingFragment$instance;

export interface IConventionForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionForeignKeyBuilder;
    readonly Properties: IReadOnlyList<IConventionProperty>;
    readonly PrincipalKey: IConventionKey;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly PrincipalEntityType: IConventionEntityType;
    readonly DependentToPrincipal: IConventionNavigation | undefined;
    readonly PrincipalToDependent: IConventionNavigation | undefined;
    readonly IsUnique: boolean;
    readonly IsRequired: boolean;
    readonly IsRequiredDependent: boolean;
    readonly IsOwnership: boolean;
    readonly DeleteBehavior: DeleteBehavior;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetConfigurationSource(): ConfigurationSource;
    GetNavigation(pointsToPrincipal: boolean): IConventionNavigation | undefined;
    GetNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    GetPropertiesConfigurationSource(): Nullable<ConfigurationSource>;
    GetReferencingSkipNavigations(): IEnumerable<IConventionSkipNavigation>;
    GetReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IConventionEntityType;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    IsBaseLinking(): boolean;
    SetDependentToPrincipal(property: MemberInfo, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    SetDependentToPrincipal(name: string, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    SetIsUnique(unique: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    SetProperties(properties: IReadOnlyList<IConventionProperty>, principalKey: IConventionKey, fromDataAnnotation?: boolean): IReadOnlyList<IConventionProperty>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
}


export type IConventionForeignKey = IConventionForeignKey$instance;

export interface IConventionIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionIndexBuilder;
    readonly Properties: IReadOnlyList<IConventionProperty>;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly Name: string | undefined;
    readonly IsUnique: boolean;
    readonly IsDescending: IReadOnlyList<System_Internal.Boolean> | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetIsUniqueConfigurationSource(): Nullable<ConfigurationSource>;
    SetIsDescending(descending: IReadOnlyList<System_Internal.Boolean>, fromDataAnnotation?: boolean): IReadOnlyList<System_Internal.Boolean> | undefined;
    SetIsUnique(unique: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionIndex = IConventionIndex$instance;

export interface IConventionKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionKeyBuilder;
    readonly Properties: IReadOnlyList<IConventionProperty>;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetConfigurationSource(): ConfigurationSource;
    GetReferencingForeignKeys(): IEnumerable<IConventionForeignKey>;
    GetReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    IsPrimaryKey(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
}


export type IConventionKey = IConventionKey$instance;

export interface IConventionModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionModelBuilder;
    readonly ModelId: Guid;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AddEntityType(name: string, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    AddEntityType(name: string, definingNavigationName: string, definingEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    AddEntityType(name: string, clrType: Type, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    AddEntityType(type: Type, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    AddEntityType(type: Type, definingNavigationName: string, definingEntityType: IConventionEntityType, fromDataAnnotation?: boolean): IConventionEntityType | undefined;
    AddIgnored(type: Type, fromDataAnnotation?: boolean): string | undefined;
    AddShared(type: Type, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    DelayConventions(): IConventionBatch;
    FinalizeModel(): IModel;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IConventionEntityType): IConventionEntityType | undefined;
    FindEntityType(name: string): IConventionEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IConventionEntityType): IConventionEntityType | undefined;
    FindEntityType(type: Type): IConventionEntityType | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(name: string): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type): IReadOnlyEntityType | undefined;
    FindEntityTypes(type: Type): IEnumerable<IConventionEntityType>;
    FindEntityTypes(type: Type): IEnumerable<IReadOnlyEntityType>;
    FindIgnoredConfigurationSource(typeName: string): Nullable<ConfigurationSource>;
    FindIsSharedConfigurationSource(type: Type): Nullable<ConfigurationSource>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IConventionEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetEmbeddedDiscriminatorName(): string;
    GetEntityTypes(): IEnumerable<IConventionEntityType>;
    GetEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetPropertyAccessModeConfigurationSource(): Nullable<ConfigurationSource>;
    IsIgnored(typeName: string): boolean;
    IsOwned(type: Type): boolean;
    RemoveEntityType(entityType: IConventionEntityType): IConventionEntityType | undefined;
    RemoveIgnored(typeName: string): string | undefined;
    RemoveOwned(type: Type): string | undefined;
    RemoveShared(type: Type): Type | undefined;
    SetEmbeddedDiscriminatorName(name: string, fromDataAnnotation?: boolean): string | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    IsShared(type: Type): boolean;
}


export type IConventionModel = IConventionModel$instance;

export interface IConventionNavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionNavigationBase, IConventionPropertyBase, IConventionAnnotatable {
    readonly Builder: IConventionNavigationBuilder;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly TargetEntityType: IConventionEntityType;
    readonly ForeignKey: IConventionForeignKey;
    readonly Inverse: IConventionNavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldName(): string | undefined;
    GetInverseConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetInverse(inverse: MemberInfo, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    SetInverse(inverseName: string, fromDataAnnotation?: boolean): IConventionNavigation | undefined;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    GetIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionNavigation = IConventionNavigation$instance;

export interface IConventionNavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly TargetEntityType: IConventionEntityType;
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly Inverse: IReadOnlyNavigationBase;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly Builder: IConventionAnnotatableBuilder;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldName(): string | undefined;
    GetIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionNavigationBase = IConventionNavigationBase$instance;

export interface IConventionProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly Builder: IConventionPropertyBuilder;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly IsNullable: boolean;
    readonly ValueGenerated: ValueGenerated;
    readonly IsConcurrencyToken: boolean;
    readonly IsPrimitiveCollection: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindContainingPrimaryKey(): IConventionKey | undefined;
    FindContainingPrimaryKey(): IReadOnlyKey | undefined;
    FindFirstPrincipal(): IConventionProperty | undefined;
    FindFirstPrincipal(): IReadOnlyProperty | undefined;
    GetBeforeSaveBehavior(): PropertySaveBehavior;
    GetConfigurationSource(): ConfigurationSource;
    GetContainingForeignKeys(): IEnumerable<IConventionForeignKey>;
    GetContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    GetElementType(): IConventionElementType | undefined;
    GetElementType(): IReadOnlyElementType | undefined;
    GetFieldName(): string | undefined;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetPrincipals(): IReadOnlyList<IConventionProperty>;
    GetPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetProviderClrType(): Type | undefined;
    GetTypeConfigurationSource(): Nullable<ConfigurationSource>;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    GetValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    IsImplicitlyCreated(): boolean;
    SetElementType(elementType: Type, fromDataAnnotation?: boolean): IConventionElementType | undefined;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetIsNullable(nullable: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    SetSentinel(sentinel: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    SetTypeMapping(typeMapping: CoreTypeMapping, fromDataAnnotation?: boolean): CoreTypeMapping | undefined;
    SetValueComparer(comparer: ValueComparer, fromDataAnnotation?: boolean): ValueComparer | undefined;
    SetValueConverter(converter: ValueConverter, fromDataAnnotation?: boolean): ValueConverter | undefined;
    SetValueGeneratorFactory(valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>, fromDataAnnotation?: boolean): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    SetValueGeneratorFactory(valueGeneratorFactory: Type, fromDataAnnotation?: boolean): Type | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    IsForeignKey(): boolean;
    IsShadowProperty(): boolean;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionProperty = IConventionProperty$instance;

export interface IConventionPropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly DeclaringType: IConventionTypeBase;
    readonly Name: string;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly Builder: IConventionAnnotatableBuilder;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionPropertyBase = IConventionPropertyBase$instance;

export interface IConventionRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Property: IConventionProperty;
    readonly Builder: IConventionRelationalPropertyOverridesBuilder;
    readonly StoreObject: StoreObjectIdentifier;
    readonly ColumnName: string | undefined;
    readonly IsColumnNameOverridden: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetColumnNameConfigurationSource(): Nullable<ConfigurationSource>;
    GetConfigurationSource(): ConfigurationSource;
    RemoveColumnNameOverride(fromDataAnnotation?: boolean): boolean;
    SetColumnName(name: string, fromDataAnnotation?: boolean): string | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionRelationalPropertyOverrides = IConventionRelationalPropertyOverrides$instance;

export interface IConventionSequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Model: IConventionModel;
    readonly Builder: IConventionSequenceBuilder;
    readonly Name: string;
    readonly ModelSchema: string | undefined;
    readonly Schema: string | undefined;
    readonly StartValue: long;
    readonly IncrementBy: int;
    readonly MinValue: Nullable<System_Internal.Int64>;
    readonly MaxValue: Nullable<System_Internal.Int64>;
    readonly Type: Type;
    readonly IsCyclic: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetStartValueConfigurationSource(): Nullable<ConfigurationSource>;
    SetStartValue(startValue: Nullable<System_Internal.Int64>, fromDataAnnotation?: boolean): Nullable<System_Internal.Int64>;
    SetType(type: Type, fromDataAnnotation?: boolean): Type | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionSequence = IConventionSequence$instance;

export interface IConventionServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionPropertyBase, IConventionAnnotatable {
    readonly Builder: IConventionServicePropertyBuilder;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly ParameterBinding: ServiceParameterBinding;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldName(): string | undefined;
    GetParameterBindingConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetParameterBinding(parameterBinding: ServiceParameterBinding, fromDataAnnotation?: boolean): ServiceParameterBinding | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
}


export type IConventionServiceProperty = IConventionServiceProperty$instance;

export interface IConventionSkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IConventionNavigationBase, IConventionPropertyBase, IConventionAnnotatable {
    readonly Builder: IConventionSkipNavigationBuilder;
    readonly DeclaringEntityType: IConventionEntityType;
    readonly TargetEntityType: IConventionEntityType;
    readonly JoinEntityType: IConventionEntityType;
    readonly ForeignKey: IConventionForeignKey;
    readonly Inverse: IConventionSkipNavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetFieldName(): string | undefined;
    GetForeignKeyConfigurationSource(): Nullable<ConfigurationSource>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetField(fieldName: string, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetFieldInfo(fieldInfo: FieldInfo, fromDataAnnotation?: boolean): FieldInfo | undefined;
    SetForeignKey(foreignKey: IConventionForeignKey, fromDataAnnotation?: boolean): IConventionForeignKey | undefined;
    SetInverse(inverse: IConventionSkipNavigation, fromDataAnnotation?: boolean): IConventionSkipNavigation | undefined;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>, fromDataAnnotation?: boolean): Nullable<System_Internal.Boolean>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetFieldInfoConfigurationSource(): Nullable<ConfigurationSource>;
    GetIsEagerLoadedConfigurationSource(): Nullable<ConfigurationSource>;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>, fromDataAnnotation?: boolean): Nullable<PropertyAccessMode>;
}


export type IConventionSkipNavigation = IConventionSkipNavigation$instance;

export interface IConventionStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly EntityType: IConventionEntityType;
    readonly Builder: IConventionStoredProcedureBuilder;
    readonly Parameters: IReadOnlyList<IConventionStoredProcedureParameter>;
    readonly ResultColumns: IReadOnlyList<IConventionStoredProcedureResultColumn>;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly IsRowsAffectedReturned: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AddParameter(propertyName: string, fromDataAnnotation?: boolean): IConventionStoredProcedureParameter | undefined;
    AddResultColumn(propertyName: string, fromDataAnnotation?: boolean): IConventionStoredProcedureResultColumn | undefined;
    AddRowsAffectedParameter(fromDataAnnotation?: boolean): IConventionStoredProcedureParameter | undefined;
    AddRowsAffectedResultColumn(fromDataAnnotation?: boolean): IConventionStoredProcedureResultColumn | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindParameter(propertyName: string): IConventionStoredProcedureParameter | undefined;
    FindParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    FindResultColumn(propertyName: string): IConventionStoredProcedureResultColumn | undefined;
    FindResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    FindRowsAffectedParameter(): IConventionStoredProcedureParameter | undefined;
    FindRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    FindRowsAffectedResultColumn(): IConventionStoredProcedureResultColumn | undefined;
    FindRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    GetNameConfigurationSource(): Nullable<ConfigurationSource>;
    GetSchemaQualifiedName(): string | undefined;
    SetIsRowsAffectedReturned(rowsAffectedReturned: boolean, fromDataAnnotation?: boolean): boolean;
    SetName(name: string, fromDataAnnotation?: boolean): string | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetStoreIdentifier(): Nullable<StoreObjectIdentifier>;
}


export type IConventionStoredProcedure = IConventionStoredProcedure$instance;

export interface IConventionStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly StoredProcedure: IConventionStoredProcedure;
    readonly Builder: IConventionStoredProcedureParameterBuilder;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly Direction: ParameterDirection;
    readonly ForOriginalValue: Nullable<System_Internal.Boolean>;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetNameConfigurationSource(): Nullable<ConfigurationSource>;
    SetDirection(direction: ParameterDirection, fromDataAnnotation?: boolean): ParameterDirection;
    SetName(name: string, fromDataAnnotation?: boolean): string;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionStoredProcedureParameter = IConventionStoredProcedureParameter$instance;

export interface IConventionStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly StoredProcedure: IConventionStoredProcedure;
    readonly Builder: IConventionStoredProcedureResultColumnBuilder;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetNameConfigurationSource(): Nullable<ConfigurationSource>;
    SetName(name: string, fromDataAnnotation?: boolean): string | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionStoredProcedureResultColumn = IConventionStoredProcedureResultColumn$instance;

export interface IConventionTrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Builder: IConventionTriggerBuilder;
    readonly EntityType: IConventionEntityType;
    readonly ModelName: string;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetConfigurationSource(): ConfigurationSource;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
}


export type IConventionTrigger = IConventionTrigger$instance;

export interface IConventionTypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IConventionAnnotatable {
    readonly Model: IConventionModel;
    readonly Builder: IConventionTypeBaseBuilder;
    readonly ContainingEntityType: IConventionEntityType;
    readonly BaseType: IConventionTypeBase | undefined;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    readonly IsInModel: boolean;
    AddAnnotation(name: string, value: unknown, fromDataAnnotation?: boolean): IConventionAnnotation;
    AddAnnotations(annotations: IEnumerable<IConventionAnnotation>, fromDataAnnotation?: boolean): void;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean, fromDataAnnotation?: boolean): IConventionComplexProperty | undefined;
    AddIgnored(memberName: string, fromDataAnnotation?: boolean): string | undefined;
    AddProperty(memberInfo: MemberInfo, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo, setTypeConfigurationSource?: boolean, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): IConventionAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IConventionComplexProperty | undefined;
    FindComplexProperty(name: string): IConventionComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IConventionProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIgnoredConfigurationSource(memberName: string): Nullable<ConfigurationSource>;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IConventionPropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IConventionPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IConventionProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IConventionProperty | undefined;
    FindProperty(name: string): IConventionProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IConventionTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorPropertyConfigurationSource(): Nullable<ConfigurationSource>;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IConventionTypeBase;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IConventionComplexProperty): IConventionComplexProperty | undefined;
    RemoveDiscriminatorValue(): unknown | undefined;
    RemoveIgnored(memberName: string): string | undefined;
    RemoveProperty(property: IReadOnlyProperty): IConventionProperty | undefined;
    SetBaseType(structuralType: IConventionTypeBase, fromDataAnnotation?: boolean): IConventionTypeBase | undefined;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>, fromDataAnnotation?: boolean): Nullable<ChangeTrackingStrategy>;
    SetDiscriminatorProperty(property: IReadOnlyProperty, fromDataAnnotation?: boolean): IConventionProperty | undefined;
    SetDiscriminatorValue(value: unknown, fromDataAnnotation?: boolean): unknown | undefined;
    FindAnnotation2(name: string): IConventionAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetAnnotations(): IEnumerable<IConventionAnnotation>;
    GetDiscriminatorValue(): unknown | undefined;
}


export type IConventionTypeBase = IConventionTypeBase$instance;

export interface IDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IAnnotatable {
    readonly Model: IModel;
    readonly Parameters: IReadOnlyList<IDbFunctionParameter>;
    readonly StoreFunction: IStoreFunction;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly ModelName: string;
    readonly MethodInfo: MethodInfo | undefined;
    readonly IsBuiltIn: boolean;
    readonly IsScalar: boolean;
    readonly IsAggregate: boolean;
    readonly IsNullable: boolean;
    readonly StoreType: string | undefined;
    readonly ReturnType: Type;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly Translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IDbFunction = IDbFunction$instance;

export interface IDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IAnnotatable {
    readonly StoreType: string;
    readonly Function: IDbFunction;
    readonly StoreFunctionParameter: IStoreFunctionParameter;
    readonly Name: string;
    readonly ClrType: Type;
    readonly PropagatesNullability: boolean;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IDbFunctionParameter = IDbFunctionParameter$instance;

export interface IDesignTimeModel$instance {
    readonly Model: IModel;
}


export type IDesignTimeModel = IDesignTimeModel$instance;

export interface IElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IAnnotatable {
    readonly CollectionProperty: IProperty;
    readonly ClrType: Type;
    readonly IsNullable: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IElementType = IElementType$instance;

export interface IEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, ITypeBase, IAnnotatable {
    readonly BaseType: IEntityType | undefined;
    readonly ServiceOnlyConstructorBinding: InstantiationBinding | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    readonly ConstructorBinding: InstantiationBinding | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindClosestCommonParent(otherEntityType: IEntityType): IEntityType | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindComplexProperty(name: string): IComplexProperty | undefined;
    FindDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    FindDeclaredTrigger(name: string): ITrigger | undefined;
    FindDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindDiscriminatorProperty(): IProperty | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IForeignKey | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    FindIndex(property: IReadOnlyProperty): IIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IIndex | undefined;
    FindIndex(name: string): IIndex | undefined;
    FindIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    FindIndex(name: string): IReadOnlyIndex | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindKey(property: IReadOnlyProperty): IKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IKey | undefined;
    FindKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMember(name: string): IPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    FindNavigation(memberInfo: MemberInfo): INavigation | undefined;
    FindNavigation(name: string): INavigation | undefined;
    FindNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    FindNavigation(name: string): IReadOnlyNavigation | undefined;
    FindOwnership(): IForeignKey | undefined;
    FindOwnership(): IReadOnlyForeignKey | undefined;
    FindPrimaryKey(): IKey | undefined;
    FindPrimaryKey(): IReadOnlyKey | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IProperty | undefined;
    FindProperty(name: string): IProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    FindServiceProperty(name: string): IServiceProperty | undefined;
    FindServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): ISkipNavigation | undefined;
    FindSkipNavigation(name: string): ISkipNavigation | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    FindSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    GetAllBaseTypes(): IEnumerable<IEntityType>;
    GetAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    GetDiscriminatorValue(): unknown | undefined;
    GetIsDiscriminatorMappingComplete(): boolean;
    GetNavigationAccessMode(): PropertyAccessMode;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetQueryFilter(): LambdaExpression | undefined;
    GetRootType(): IEntityType;
    GetRootType(): IReadOnlyEntityType;
    GetRootType(): IReadOnlyTypeBase;
    GetSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    IsAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindComplexProperty2(name: string): IComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindDiscriminatorProperty2(): IProperty | undefined;
    FindMember2(name: string): IPropertyBase | undefined;
    FindProperty2(name: string): IProperty | undefined;
    FindProperty3(memberInfo: MemberInfo): IProperty | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDerivedTypes(): IEnumerable<ITypeBase>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType2(): IReadOnlyTypeBase;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsAbstract(): boolean;
}


export type IEntityType = IEntityType$instance;

export interface IEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IAnnotatable {
    readonly EntityType: IEntityType;
    readonly StoreObject: StoreObjectIdentifier;
    readonly IsTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IEntityTypeMappingFragment = IEntityTypeMappingFragment$instance;

export interface IForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IAnnotatable {
    readonly Properties: IReadOnlyList<IProperty>;
    readonly PrincipalKey: IKey;
    readonly DeclaringEntityType: IEntityType;
    readonly PrincipalEntityType: IEntityType;
    readonly DependentToPrincipal: INavigation | undefined;
    readonly PrincipalToDependent: INavigation | undefined;
    readonly IsUnique: boolean;
    readonly IsRequired: boolean;
    readonly IsRequiredDependent: boolean;
    readonly IsOwnership: boolean;
    readonly DeleteBehavior: DeleteBehavior;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetDependentKeyValueFactory<TKey>(): IDependentKeyValueFactory_1<TKey>;
    GetDependentKeyValueFactory(): IDependentKeyValueFactory;
    GetNavigation(pointsToPrincipal: boolean): INavigation | undefined;
    GetNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetReferencingSkipNavigations(): IEnumerable<ISkipNavigation>;
    GetReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IEntityType;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    IsBaseLinking(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IForeignKey = IForeignKey$instance;

export interface IForeignKeyConstraint$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly MappedForeignKeys: IEnumerable<IForeignKey>;
    readonly Table: ITable;
    readonly PrincipalTable: ITable;
    readonly Columns: IReadOnlyList<IColumn>;
    readonly PrincipalColumns: IReadOnlyList<IColumn>;
    readonly PrincipalUniqueConstraint: IUniqueConstraint;
    readonly OnDeleteAction: ReferentialAction;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IForeignKeyConstraint = IForeignKeyConstraint$instance;

export interface IFunctionColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Function: IStoreFunction;
    readonly PropertyMappings: IReadOnlyList<IFunctionColumnMapping>;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindColumnMapping(entityType: IReadOnlyEntityType): IFunctionColumnMapping | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionColumn = IFunctionColumn$instance;

export interface IFunctionColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Column: IFunctionColumn;
    readonly FunctionMapping: IFunctionMapping;
    readonly Property: IProperty;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionColumnMapping = IFunctionColumnMapping$instance;

export interface IFunctionMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly IsDefaultFunctionMapping: boolean;
    readonly StoreFunction: IStoreFunction;
    readonly DbFunction: IDbFunction;
    readonly ColumnMappings: IEnumerable<IFunctionColumnMapping>;
    readonly TypeBase: ITypeBase;
    readonly Table: ITableBase;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IFunctionMapping = IFunctionMapping$instance;

export interface IIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IAnnotatable {
    readonly Properties: IReadOnlyList<IProperty>;
    readonly DeclaringEntityType: IEntityType;
    readonly Name: string | undefined;
    readonly IsUnique: boolean;
    readonly IsDescending: IReadOnlyList<System_Internal.Boolean> | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetNullableValueFactory<TKey>(): IDependentKeyValueFactory_1<TKey>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IIndex = IIndex$instance;

export interface IKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IAnnotatable {
    readonly Properties: IReadOnlyList<IProperty>;
    readonly DeclaringEntityType: IEntityType;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetKeyType(): Type;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPrincipalKeyValueFactory<TKey>(): IPrincipalKeyValueFactory_1<TKey>;
    GetPrincipalKeyValueFactory(): IPrincipalKeyValueFactory;
    GetReferencingForeignKeys(): IEnumerable<IForeignKey>;
    GetReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    IsPrimaryKey(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IKey = IKey$instance;

export interface IMetadataReference_1$instance<T> extends IDisposable {
    readonly Object: T;
}


export interface IMetadataReference_1$instance<T> extends System_Internal.IDisposable {}

export type IMetadataReference_1<T> = IMetadataReference_1$instance<T>;

export interface IModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IAnnotatable {
    get ModelDependencies(): RuntimeModelDependencies | undefined;
    set ModelDependencies(value: RuntimeModelDependencies | undefined);
    readonly ModelId: Guid;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IEntityType): IEntityType | undefined;
    FindEntityType(name: string): IEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IEntityType): IEntityType | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(name: string): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type): IReadOnlyEntityType | undefined;
    FindEntityTypes(type: Type): IEnumerable<IEntityType>;
    FindEntityTypes(type: Type): IEnumerable<IReadOnlyEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    FindRuntimeEntityType(type: Type): IEntityType | undefined;
    FindTypeMappingConfiguration(scalarType: Type): ITypeMappingConfiguration | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetEmbeddedDiscriminatorName(): string;
    GetEntityTypes(): IEnumerable<IEntityType>;
    GetEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    GetModelDependencies(): RuntimeModelDependencies;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsIndexerMethod(methodInfo: MethodInfo): boolean;
    IsShared(type: Type): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IModel = IModel$instance;

export interface IMutableAnnotatable$instance extends IReadOnlyAnnotatable {
    [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    FindAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableAnnotatable = IMutableAnnotatable$instance;

export interface IMutableCheckConstraint$instance extends IReadOnlyCheckConstraint, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly EntityType: IMutableEntityType;
    get Name(): string | undefined;
    set Name(value: string | undefined);
    readonly ModelName: string;
    readonly Sql: string;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDefaultName(): string | undefined;
    GetName(storeObject: StoreObjectIdentifier): string | undefined;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableCheckConstraint = IMutableCheckConstraint$instance;

export interface IMutableComplexProperty$instance extends IReadOnlyComplexProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly ComplexType: IMutableComplexType;
    IsNullable: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableComplexProperty = IMutableComplexProperty$instance;

export interface IMutableComplexType$instance extends IReadOnlyComplexType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableTypeBase, IMutableAnnotatable {
    readonly ComplexProperty: IMutableComplexProperty;
    readonly BaseType: IMutableComplexType | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddIgnored(memberName: string): string | undefined;
    AddProperty(memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type): IMutableProperty;
    AddProperty(name: string): IMutableProperty;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    FindComplexProperty(name: string): IMutableComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IMutableProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IMutablePropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IMutableComplexType>;
    GetDerivedTypes(): IEnumerable<IMutableTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IMutableComplexType;
    GetRootType(): IMutableTypeBase;
    GetRootType(): IReadOnlyComplexType;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsContainedBy(type: Type): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    RemoveDiscriminatorValue(): void;
    RemoveProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
    SetDiscriminatorProperty(property: IReadOnlyProperty): void;
    SetDiscriminatorValue(value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    FindMember2(name: string): IReadOnlyPropertyBase | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRootType2(): IReadOnlyTypeBase;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableComplexType = IMutableComplexType$instance;

export interface IMutableDbFunction$instance extends IReadOnlyDbFunction, IReadOnlyAnnotatable, IMutableAnnotatable {
    Name: string;
    get Schema(): string | undefined;
    set Schema(value: string | undefined);
    IsBuiltIn: boolean;
    IsNullable: boolean;
    get StoreType(): string | undefined;
    set StoreType(value: string | undefined);
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping | undefined);
    readonly Model: IMutableModel;
    readonly Parameters: IReadOnlyList<IMutableDbFunctionParameter>;
    get Translation(): Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    set Translation(value: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined);
    readonly ModelName: string;
    readonly MethodInfo: MethodInfo | undefined;
    readonly IsScalar: boolean;
    readonly IsAggregate: boolean;
    readonly ReturnType: Type;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableDbFunction = IMutableDbFunction$instance;

export interface IMutableDbFunctionParameter$instance extends IReadOnlyDbFunctionParameter, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Function: IMutableDbFunction;
    StoreType: string;
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping | undefined);
    readonly Name: string;
    readonly ClrType: Type;
    readonly PropagatesNullability: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableDbFunctionParameter = IMutableDbFunctionParameter$instance;

export interface IMutableElementType$instance extends IReadOnlyElementType, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly CollectionProperty: IMutableProperty;
    IsNullable: boolean;
    readonly ClrType: Type;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetMaxLength(maxLength: Nullable<System_Internal.Int32>): void;
    SetTypeMapping(typeMapping: CoreTypeMapping): void;
    SetValueComparer(comparer: ValueComparer): void;
    SetValueConverter(converter: ValueConverter): void;
    SetValueConverter(converterType: Type): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableElementType = IMutableElementType$instance;

export interface IMutableEntityType$instance extends IReadOnlyEntityType, IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableTypeBase, IMutableAnnotatable {
    get BaseType(): IMutableEntityType | undefined;
    set BaseType(value: IMutableEntityType | undefined);
    IsKeyless: boolean;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddData(data: IEnumerable<unknown>): void;
    AddForeignKey(property: IMutableProperty, principalKey: IMutableKey, principalEntityType: IMutableEntityType): IMutableForeignKey;
    AddForeignKey(properties: IReadOnlyList<IMutableProperty>, principalKey: IMutableKey, principalEntityType: IMutableEntityType): IMutableForeignKey;
    AddIgnored(memberName: string): string | undefined;
    AddIndex(property: IMutableProperty, name: string): IMutableIndex;
    AddIndex(property: IMutableProperty): IMutableIndex;
    AddIndex(properties: IReadOnlyList<IMutableProperty>, name: string): IMutableIndex;
    AddIndex(properties: IReadOnlyList<IMutableProperty>): IMutableIndex;
    AddProperty(memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type): IMutableProperty;
    AddProperty(name: string): IMutableProperty;
    AddServiceProperty(memberInfo: MemberInfo, serviceType?: Type): IMutableServiceProperty;
    AddSkipNavigation(name: string, memberInfo: MemberInfo, targetEntityType: IMutableEntityType, collection: boolean, onDependent: boolean): IMutableSkipNavigation;
    AddSkipNavigation(name: string, navigationType: Type, memberInfo: MemberInfo, targetEntityType: IMutableEntityType, collection: boolean, onDependent: boolean): IMutableSkipNavigation;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IMutableEntityType | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    FindComplexProperty(name: string): IMutableComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    FindDeclaredTrigger(name: string): IMutableTrigger | undefined;
    FindDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    FindDiscriminatorProperty(): IMutableProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IMutableForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IMutableForeignKey | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IMutableForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IMutableForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    FindIndex(property: IReadOnlyProperty): IMutableIndex | undefined;
    FindIndex(name: string): IMutableIndex | undefined;
    FindIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    FindIndex(name: string): IReadOnlyIndex | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindKey(property: IReadOnlyProperty): IMutableKey | undefined;
    FindKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    FindMember(name: string): IMutablePropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    FindNavigation(memberInfo: MemberInfo): IMutableNavigation | undefined;
    FindNavigation(name: string): IMutableNavigation | undefined;
    FindNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    FindNavigation(name: string): IReadOnlyNavigation | undefined;
    FindOwnership(): IMutableForeignKey | undefined;
    FindOwnership(): IReadOnlyForeignKey | undefined;
    FindPrimaryKey(): IMutableKey | undefined;
    FindPrimaryKey(): IReadOnlyKey | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindServiceProperty(name: string): IMutableServiceProperty | undefined;
    FindServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IMutableSkipNavigation | undefined;
    FindSkipNavigation(name: string): IMutableSkipNavigation | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    FindSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    GetAllBaseTypes(): IEnumerable<IMutableEntityType>;
    GetAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    GetDiscriminatorValue(): unknown | undefined;
    GetIsDiscriminatorMappingComplete(): boolean;
    GetNavigationAccessMode(): PropertyAccessMode;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetQueryFilter(): LambdaExpression | undefined;
    GetRootType(): IMutableEntityType;
    GetRootType(): IMutableTypeBase;
    GetRootType(): IReadOnlyEntityType;
    GetRootType(): IReadOnlyTypeBase;
    GetSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    IsAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    RemoveDiscriminatorValue(): void;
    RemoveForeignKey(foreignKey: IReadOnlyForeignKey): IMutableForeignKey | undefined;
    RemoveIndex(index: IReadOnlyIndex): IMutableIndex | undefined;
    RemoveKey(key: IReadOnlyKey): IMutableKey | undefined;
    RemoveProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    RemoveServiceProperty(property: IReadOnlyServiceProperty): IMutableServiceProperty | undefined;
    RemoveSkipNavigation(navigation: IReadOnlySkipNavigation): IMutableSkipNavigation | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetDiscriminatorMappingComplete(complete: Nullable<System_Internal.Boolean>): void;
    SetDiscriminatorProperty(property: IReadOnlyProperty): void;
    SetDiscriminatorValue(value: unknown): void;
    SetPrimaryKey(property: IMutableProperty): IMutableKey | undefined;
    SetPrimaryKey(properties: IReadOnlyList<IMutableProperty>): IMutableKey | undefined;
    SetQueryFilter(queryFilter: LambdaExpression): void;
    SetQueryFilter(filterKey: string, filter: LambdaExpression): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    FindComplexProperty2(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty3(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty2(): IReadOnlyProperty | undefined;
    FindMember2(name: string): IReadOnlyPropertyBase | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDerivedTypes(): IEnumerable<IMutableTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType2(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
}


export type IMutableEntityType = IMutableEntityType$instance;

export interface IMutableEntityTypeMappingFragment$instance extends IReadOnlyEntityTypeMappingFragment, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly EntityType: IMutableEntityType;
    IsTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly StoreObject: StoreObjectIdentifier;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableEntityTypeMappingFragment = IMutableEntityTypeMappingFragment$instance;

export interface IMutableForeignKey$instance extends IReadOnlyForeignKey, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Properties: IReadOnlyList<IMutableProperty>;
    readonly PrincipalKey: IMutableKey;
    readonly DeclaringEntityType: IMutableEntityType;
    readonly PrincipalEntityType: IMutableEntityType;
    IsUnique: boolean;
    IsRequired: boolean;
    IsRequiredDependent: boolean;
    IsOwnership: boolean;
    DeleteBehavior: DeleteBehavior;
    readonly DependentToPrincipal: IMutableNavigation | undefined;
    readonly PrincipalToDependent: IMutableNavigation | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetNavigation(pointsToPrincipal: boolean): IMutableNavigation | undefined;
    GetNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    GetReferencingSkipNavigations(): IEnumerable<IMutableSkipNavigation>;
    GetReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IMutableEntityType;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    IsBaseLinking(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetDependentToPrincipal(property: MemberInfo): IMutableNavigation | undefined;
    SetDependentToPrincipal(name: string): IMutableNavigation | undefined;
    SetProperties(properties: IReadOnlyList<IMutableProperty>, principalKey: IMutableKey): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableForeignKey = IMutableForeignKey$instance;

export interface IMutableIndex$instance extends IReadOnlyIndex, IReadOnlyAnnotatable, IMutableAnnotatable {
    IsUnique: boolean;
    get IsDescending(): IReadOnlyList<System_Internal.Boolean> | undefined;
    set IsDescending(value: IReadOnlyList<System_Internal.Boolean> | undefined);
    readonly Properties: IReadOnlyList<IMutableProperty>;
    readonly DeclaringEntityType: IMutableEntityType;
    readonly Name: string | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableIndex = IMutableIndex$instance;

export interface IMutableKey$instance extends IReadOnlyKey, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Properties: IReadOnlyList<IMutableProperty>;
    readonly DeclaringEntityType: IMutableEntityType;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetReferencingForeignKeys(): IEnumerable<IMutableForeignKey>;
    GetReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    IsPrimaryKey(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableKey = IMutableKey$instance;

export interface IMutableModel$instance extends IReadOnlyModel, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly ModelId: Guid;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AddEntityType(name: string, definingNavigationName: string, definingEntityType: IMutableEntityType): IMutableEntityType;
    AddEntityType(name: string, type: Type): IMutableEntityType;
    AddEntityType(name: string): IMutableEntityType;
    AddEntityType(type: Type, definingNavigationName: string, definingEntityType: IMutableEntityType): IMutableEntityType;
    AddEntityType(type: Type): IMutableEntityType;
    AddIgnored(typeName: string): string;
    AddShared(type: Type): void;
    AnnotationsToDebugString(indent?: int): string;
    DelayConventions(): IConventionBatch;
    FinalizeModel(): IModel;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(name: string): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type): IReadOnlyEntityType | undefined;
    FindEntityTypes(type: Type): IEnumerable<IMutableEntityType>;
    FindEntityTypes(type: Type): IEnumerable<IReadOnlyEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IMutableEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetEmbeddedDiscriminatorName(): string;
    GetEntityTypes(): IEnumerable<IMutableEntityType>;
    GetEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsIgnored(typeName: string): boolean;
    IsOwned(type: Type): boolean;
    RemoveEntityType(entityType: IMutableEntityType): IMutableEntityType | undefined;
    RemoveOwned(type: Type): string | undefined;
    RemoveShared(type: Type): Type | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetEmbeddedDiscriminatorName(name: string): void;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    IsShared(type: Type): boolean;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableModel = IMutableModel$instance;

export interface IMutableNavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableNavigationBase, IMutablePropertyBase, IMutableAnnotatable {
    readonly DeclaringEntityType: IMutableEntityType;
    readonly TargetEntityType: IMutableEntityType;
    readonly ForeignKey: IMutableForeignKey;
    readonly Inverse: IMutableNavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetInverse(inverse: MemberInfo): IMutableNavigation | undefined;
    SetInverse(inverseName: string): IMutableNavigation | undefined;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableNavigation = IMutableNavigation$instance;

export interface IMutableNavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly TargetEntityType: IReadOnlyEntityType;
    readonly Inverse: IReadOnlyNavigationBase;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableNavigationBase = IMutableNavigationBase$instance;

export interface IMutableProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly DeclaringEntityType: IMutableEntityType;
    IsNullable: boolean;
    ValueGenerated: ValueGenerated;
    IsConcurrencyToken: boolean;
    get Sentinel(): unknown | undefined;
    set Sentinel(value: unknown | undefined);
    readonly IsPrimitiveCollection: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindContainingPrimaryKey(): IMutableKey | undefined;
    FindContainingPrimaryKey(): IReadOnlyKey | undefined;
    FindFirstPrincipal(): IMutableProperty | undefined;
    FindFirstPrincipal(): IReadOnlyProperty | undefined;
    GetBeforeSaveBehavior(): PropertySaveBehavior;
    GetContainingForeignKeys(): IEnumerable<IMutableForeignKey>;
    GetContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    GetElementType(): IMutableElementType | undefined;
    GetElementType(): IReadOnlyElementType | undefined;
    GetFieldName(): string | undefined;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetPrincipals(): IReadOnlyList<IMutableProperty>;
    GetPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    GetValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    IsForeignKey(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetMaxLength(maxLength: Nullable<System_Internal.Int32>): void;
    SetTypeMapping(typeMapping: CoreTypeMapping): void;
    SetValueComparer(comparer: ValueComparer): void;
    SetValueConverter(converter: ValueConverter): void;
    SetValueGeneratorFactory(valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>): void;
    SetValueGeneratorFactory(valueGeneratorFactory: Type): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    IsShadowProperty(): boolean;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableProperty = IMutableProperty$instance;

export interface IMutablePropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly DeclaringType: IMutableTypeBase;
    get FieldInfo(): FieldInfo | undefined;
    set FieldInfo(value: FieldInfo | undefined);
    readonly Name: string;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutablePropertyBase = IMutablePropertyBase$instance;

export interface IMutableRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Property: IMutableProperty;
    get ColumnName(): string | undefined;
    set ColumnName(value: string | undefined);
    readonly StoreObject: StoreObjectIdentifier;
    readonly IsColumnNameOverridden: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    RemoveColumnNameOverride(): void;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableRelationalPropertyOverrides = IMutableRelationalPropertyOverrides$instance;

export interface IMutableSequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Model: IMutableModel;
    StartValue: long;
    IncrementBy: int;
    MinValue: Nullable<System_Internal.Int64>;
    MaxValue: Nullable<System_Internal.Int64>;
    Type: Type;
    IsCyclic: boolean;
    readonly Name: string;
    readonly ModelSchema: string | undefined;
    readonly Schema: string | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableSequence = IMutableSequence$instance;

export interface IMutableServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutablePropertyBase, IMutableAnnotatable {
    readonly DeclaringEntityType: IMutableEntityType;
    ParameterBinding: ServiceParameterBinding;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableServiceProperty = IMutableServiceProperty$instance;

export interface IMutableSkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IMutableNavigationBase, IMutablePropertyBase, IMutableAnnotatable {
    readonly DeclaringEntityType: IMutableEntityType;
    readonly TargetEntityType: IMutableEntityType;
    readonly JoinEntityType: IMutableEntityType;
    readonly ForeignKey: IMutableForeignKey;
    readonly Inverse: IMutableSkipNavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetAnnotation(name: string, value: unknown): void;
    SetField(fieldName: string): void;
    SetForeignKey(foreignKey: IMutableForeignKey): void;
    SetInverse(inverse: IMutableSkipNavigation): IMutableSkipNavigation | undefined;
    SetIsEagerLoaded(eagerLoaded: Nullable<System_Internal.Boolean>): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
    SetPropertyAccessMode(propertyAccessMode: Nullable<PropertyAccessMode>): void;
}


export type IMutableSkipNavigation = IMutableSkipNavigation$instance;

export interface IMutableStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IMutableAnnotatable {
    Name: string;
    get Schema(): string | undefined;
    set Schema(value: string | undefined);
    readonly EntityType: IMutableEntityType;
    IsRowsAffectedReturned: boolean;
    readonly Parameters: IReadOnlyList<IMutableStoredProcedureParameter>;
    readonly ResultColumns: IReadOnlyList<IMutableStoredProcedureResultColumn>;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindParameter(propertyName: string): IMutableStoredProcedureParameter | undefined;
    FindParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    FindResultColumn(propertyName: string): IMutableStoredProcedureResultColumn | undefined;
    FindResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    FindRowsAffectedParameter(): IMutableStoredProcedureParameter | undefined;
    FindRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    FindRowsAffectedResultColumn(): IMutableStoredProcedureResultColumn | undefined;
    FindRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetSchemaQualifiedName(): string | undefined;
    GetStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedure = IMutableStoredProcedure$instance;

export interface IMutableStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly StoredProcedure: IMutableStoredProcedure;
    Name: string;
    Direction: ParameterDirection;
    readonly PropertyName: string | undefined;
    readonly ForOriginalValue: Nullable<System_Internal.Boolean>;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedureParameter = IMutableStoredProcedureParameter$instance;

export interface IMutableStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly StoredProcedure: IMutableStoredProcedure;
    Name: string;
    readonly PropertyName: string | undefined;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableStoredProcedureResultColumn = IMutableStoredProcedureResultColumn$instance;

export interface IMutableTrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly EntityType: IMutableEntityType;
    readonly ModelName: string;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    SetAnnotation(name: string, value: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableTrigger = IMutableTrigger$instance;

export interface IMutableTypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IMutableAnnotatable {
    readonly Model: IMutableModel;
    readonly ContainingEntityType: IMutableEntityType;
    get BaseType(): IMutableTypeBase | undefined;
    set BaseType(value: IMutableTypeBase | undefined);
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AddAnnotation(name: string, value: unknown): IAnnotation;
    AddAnnotations(annotations: IEnumerable<IAnnotation>): void;
    AddComplexProperty(memberInfo: MemberInfo, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, memberInfo: MemberInfo, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddComplexProperty(name: string, propertyType: Type, complexType: Type, complexTypeName?: string, collection?: boolean): IMutableComplexProperty;
    AddIgnored(memberName: string): string | undefined;
    AddProperty(memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type, memberInfo: MemberInfo): IMutableProperty;
    AddProperty(name: string, propertyType: Type): IMutableProperty;
    AddProperty(name: string): IMutableProperty;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IMutableComplexProperty | undefined;
    FindComplexProperty(name: string): IMutableComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IMutableProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IMutablePropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IMutablePropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IMutableProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IMutableTypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IMutableTypeBase;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsIgnored(memberName: string): boolean;
    RemoveComplexProperty(property: IReadOnlyComplexProperty): IMutableComplexProperty | undefined;
    RemoveDiscriminatorValue(): void;
    RemoveProperty(property: IReadOnlyProperty): IMutableProperty | undefined;
    SetAnnotation(name: string, value: unknown): void;
    SetChangeTrackingStrategy(changeTrackingStrategy: Nullable<ChangeTrackingStrategy>): void;
    SetDiscriminatorProperty(property: IReadOnlyProperty): void;
    SetDiscriminatorValue(value: unknown): void;
    GetAnnotations(): IEnumerable<IAnnotation>;
    RemoveAnnotation(name: string): IAnnotation | undefined;
}


export type IMutableTypeBase = IMutableTypeBase$instance;

export interface INavigation$instance extends IReadOnlyNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, INavigationBase, IPropertyBase, IAnnotatable {
    readonly DeclaringEntityType: IEntityType;
    readonly TargetEntityType: IEntityType;
    readonly ForeignKey: IForeignKey;
    readonly Inverse: INavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetIsLoadedWhenNoTracking(entity: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type INavigation = INavigation$instance;

export interface INavigationBase$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly DeclaringEntityType: IEntityType;
    readonly TargetEntityType: IEntityType;
    readonly Inverse: INavigationBase;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetIsLoadedWhenNoTracking(entity: unknown): void;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type INavigationBase = INavigationBase$instance;

export interface IParameterBindingFactories$instance {
    FindFactory(parameterType: Type, parameterName: string): IParameterBindingFactory | undefined;
}


export type IParameterBindingFactories = IParameterBindingFactories$instance;

export interface IParameterBindingFactory$instance {
    Bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    CanBind(parameterType: Type, parameterName: string): boolean;
}


export type IParameterBindingFactory = IParameterBindingFactory$instance;

export interface IPrimaryKeyConstraint$instance extends IUniqueConstraint, IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly MappedKeys: IEnumerable<IKey>;
    readonly Table: ITable;
    readonly Columns: IReadOnlyList<IColumn>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetIsPrimaryKey(): boolean;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IPrimaryKeyConstraint = IPrimaryKeyConstraint$instance;

export interface IProperty$instance extends IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly DeclaringEntityType: IEntityType;
    readonly IsNullable: boolean;
    readonly ValueGenerated: ValueGenerated;
    readonly IsConcurrencyToken: boolean;
    readonly IsPrimitiveCollection: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    CreateKeyEqualityComparer<TProperty>(): IEqualityComparer<TProperty>;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindContainingPrimaryKey(): IKey | undefined;
    FindContainingPrimaryKey(): IReadOnlyKey | undefined;
    FindFirstPrincipal(): IProperty | undefined;
    FindFirstPrincipal(): IReadOnlyProperty | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetBeforeSaveBehavior(): PropertySaveBehavior;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetContainingForeignKeys(): IEnumerable<IForeignKey>;
    GetContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetElementType(): IElementType | undefined;
    GetElementType(): IReadOnlyElementType | undefined;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPrincipals(): IReadOnlyList<IProperty>;
    GetPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    GetValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    IsForeignKey(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsShadowProperty(): boolean;
}


export type IProperty = IProperty$instance;

export interface IPropertyBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable, IAnnotatable {
    readonly DeclaringType: ITypeBase;
    readonly Name: string;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IPropertyBase = IPropertyBase$instance;

export interface IPropertyParameterBindingFactory$instance {
    FindParameter(complexType: IComplexType, parameterType: Type, parameterName: string): ParameterBinding | undefined;
    FindParameter(entityType: IEntityType, parameterType: Type, parameterName: string): ParameterBinding | undefined;
}


export type IPropertyParameterBindingFactory = IPropertyParameterBindingFactory$instance;

export interface IQueryFilter$instance {
    readonly Expression: LambdaExpression;
    readonly Key: string | undefined;
    readonly IsAnonymous: boolean;
}


export type IQueryFilter = IQueryFilter$instance;

export interface IReadOnlyCheckConstraint$instance extends IReadOnlyAnnotatable {
    readonly ModelName: string;
    readonly Name: string | undefined;
    readonly EntityType: IReadOnlyEntityType;
    readonly Sql: string;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDefaultName(): string | undefined;
    GetName(storeObject: StoreObjectIdentifier): string | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyCheckConstraint$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyCheckConstraint = IReadOnlyCheckConstraint$instance;

export interface IReadOnlyComplexProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly ComplexType: IReadOnlyComplexType;
    readonly IsNullable: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyComplexProperty = IReadOnlyComplexProperty$instance;

export interface IReadOnlyComplexType$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable {
    readonly ComplexProperty: IReadOnlyComplexProperty;
    readonly BaseType: IReadOnlyComplexType | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IReadOnlyComplexType>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyComplexType;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    IsContainedBy(type: Type): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IReadOnlyComplexType = IReadOnlyComplexType$instance;

export interface IReadOnlyDbFunction$instance extends IReadOnlyAnnotatable {
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly ModelName: string;
    readonly Model: IReadOnlyModel;
    readonly MethodInfo: MethodInfo | undefined;
    readonly IsBuiltIn: boolean;
    readonly IsScalar: boolean;
    readonly IsAggregate: boolean;
    readonly IsNullable: boolean;
    readonly StoreType: string | undefined;
    readonly ReturnType: Type;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly Parameters: IReadOnlyList<IReadOnlyDbFunctionParameter>;
    readonly Translation: Func<IReadOnlyList<SqlExpression>, SqlExpression> | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyDbFunction$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyDbFunction = IReadOnlyDbFunction$instance;

export interface IReadOnlyDbFunctionParameter$instance extends IReadOnlyAnnotatable {
    readonly Function: IReadOnlyDbFunction;
    readonly Name: string;
    readonly ClrType: Type;
    readonly StoreType: string;
    readonly PropagatesNullability: boolean;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyDbFunctionParameter$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyDbFunctionParameter = IReadOnlyDbFunctionParameter$instance;

export interface IReadOnlyElementType$instance extends IReadOnlyAnnotatable {
    readonly CollectionProperty: IReadOnlyProperty;
    readonly ClrType: Type;
    readonly IsNullable: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyElementType$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyElementType = IReadOnlyElementType$instance;

export interface IReadOnlyEntityType$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable {
    readonly BaseType: IReadOnlyEntityType | undefined;
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindClosestCommonParent(otherEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDeclaredQueryFilter(filterKey: string): IQueryFilter | undefined;
    FindDeclaredTrigger(name: string): IReadOnlyTrigger | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindForeignKey(property: IReadOnlyProperty, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): IReadOnlyForeignKey | undefined;
    FindForeignKeys(property: IReadOnlyProperty): IEnumerable<IReadOnlyForeignKey>;
    FindForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<IReadOnlyForeignKey>;
    FindIndex(property: IReadOnlyProperty): IReadOnlyIndex | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyIndex | undefined;
    FindIndex(name: string): IReadOnlyIndex | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindKey(property: IReadOnlyProperty): IReadOnlyKey | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): IReadOnlyKey | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindNavigation(memberInfo: MemberInfo): IReadOnlyNavigation | undefined;
    FindNavigation(name: string): IReadOnlyNavigation | undefined;
    FindOwnership(): IReadOnlyForeignKey | undefined;
    FindPrimaryKey(): IReadOnlyKey | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindServiceProperty(name: string): IReadOnlyServiceProperty | undefined;
    FindSkipNavigation(memberInfo: MemberInfo): IReadOnlySkipNavigation | undefined;
    FindSkipNavigation(name: string): IReadOnlySkipNavigation | undefined;
    GetAllBaseTypes(): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDeclaredQueryFilters(): IReadOnlyCollection<IQueryFilter>;
    GetDiscriminatorValue(): unknown | undefined;
    GetIsDiscriminatorMappingComplete(): boolean;
    GetNavigationAccessMode(): PropertyAccessMode;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetQueryFilter(): LambdaExpression | undefined;
    GetRootType(): IReadOnlyEntityType;
    GetRootType(): IReadOnlyTypeBase;
    GetSeedData(providerValues?: boolean): IEnumerable<IDictionary<System_Internal.String, unknown | undefined>>;
    IsAssignableFrom(derivedType: IReadOnlyEntityType): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsAbstract(): boolean;
}


export type IReadOnlyEntityType = IReadOnlyEntityType$instance;

export interface IReadOnlyEntityTypeMappingFragment$instance extends IReadOnlyAnnotatable {
    readonly EntityType: IReadOnlyEntityType;
    readonly StoreObject: StoreObjectIdentifier;
    readonly IsTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyEntityTypeMappingFragment$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyEntityTypeMappingFragment = IReadOnlyEntityTypeMappingFragment$instance;

export interface IReadOnlyForeignKey$instance extends IReadOnlyAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly Properties: IReadOnlyList<IReadOnlyProperty>;
    readonly PrincipalEntityType: IReadOnlyEntityType;
    readonly PrincipalKey: IReadOnlyKey;
    readonly DependentToPrincipal: IReadOnlyNavigation | undefined;
    readonly PrincipalToDependent: IReadOnlyNavigation | undefined;
    readonly IsUnique: boolean;
    readonly IsRequired: boolean;
    readonly IsRequiredDependent: boolean;
    readonly IsOwnership: boolean;
    readonly DeleteBehavior: DeleteBehavior;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetNavigation(pointsToPrincipal: boolean): IReadOnlyNavigation | undefined;
    GetReferencingSkipNavigations(): IEnumerable<IReadOnlySkipNavigation>;
    GetRelatedEntityType(entityType: IReadOnlyEntityType): IReadOnlyEntityType;
    IsBaseLinking(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyForeignKey$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyForeignKey = IReadOnlyForeignKey$instance;

export interface IReadOnlyIndex$instance extends IReadOnlyAnnotatable {
    readonly Properties: IReadOnlyList<IReadOnlyProperty>;
    readonly Name: string | undefined;
    readonly IsUnique: boolean;
    readonly IsDescending: IReadOnlyList<System_Internal.Boolean> | undefined;
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyIndex$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyIndex = IReadOnlyIndex$instance;

export interface IReadOnlyKey$instance extends IReadOnlyAnnotatable {
    readonly Properties: IReadOnlyList<IReadOnlyProperty>;
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetReferencingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    IsPrimaryKey(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyKey$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyKey = IReadOnlyKey$instance;

export interface IReadOnlyModel$instance extends IReadOnlyAnnotatable {
    readonly ModelId: Guid;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindEntityType(name: string, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(name: string): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type, definingNavigationName: string, definingEntityType: IReadOnlyEntityType): IReadOnlyEntityType | undefined;
    FindEntityType(type: Type): IReadOnlyEntityType | undefined;
    FindEntityTypes(type: Type): IEnumerable<IReadOnlyEntityType>;
    FindLeastDerivedEntityTypes(type: Type, condition?: Func<IReadOnlyEntityType, System_Internal.Boolean>): IEnumerable<IReadOnlyEntityType>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetEmbeddedDiscriminatorName(): string;
    GetEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShared(type: Type): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyModel$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyModel = IReadOnlyModel$instance;

export interface IReadOnlyNavigation$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly TargetEntityType: IReadOnlyEntityType;
    readonly Inverse: IReadOnlyNavigation;
    readonly ForeignKey: IReadOnlyForeignKey;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyNavigation = IReadOnlyNavigation$instance;

export interface IReadOnlyNavigationBase$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly TargetEntityType: IReadOnlyEntityType;
    readonly Inverse: IReadOnlyNavigationBase;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
}


export type IReadOnlyNavigationBase = IReadOnlyNavigationBase$instance;

export interface IReadOnlyProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly IsNullable: boolean;
    readonly ValueGenerated: ValueGenerated;
    readonly IsConcurrencyToken: boolean;
    readonly IsPrimitiveCollection: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindContainingPrimaryKey(): IReadOnlyKey | undefined;
    FindFirstPrincipal(): IReadOnlyProperty | undefined;
    GetBeforeSaveBehavior(): PropertySaveBehavior;
    GetContainingForeignKeys(): IEnumerable<IReadOnlyForeignKey>;
    GetElementType(): IReadOnlyElementType | undefined;
    GetFieldName(): string | undefined;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetPrincipals(): IReadOnlyList<IReadOnlyProperty>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetProviderClrType(): Type | undefined;
    GetTypeMapping(): CoreTypeMapping;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    GetValueGeneratorFactory(): Func<IProperty, ITypeBase, ValueGenerator> | undefined;
    IsForeignKey(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    GetAnnotations(): IEnumerable<IAnnotation>;
    IsShadowProperty(): boolean;
}


export type IReadOnlyProperty = IReadOnlyProperty$instance;

export interface IReadOnlyPropertyBase$instance extends IReadOnlyAnnotatable {
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
}


export interface IReadOnlyPropertyBase$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyPropertyBase = IReadOnlyPropertyBase$instance;

export interface IReadOnlyRelationalPropertyOverrides$instance extends IReadOnlyAnnotatable {
    readonly Property: IReadOnlyProperty;
    readonly StoreObject: StoreObjectIdentifier;
    readonly ColumnName: string | undefined;
    readonly IsColumnNameOverridden: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyRelationalPropertyOverrides$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyRelationalPropertyOverrides = IReadOnlyRelationalPropertyOverrides$instance;

export interface IReadOnlySequence$instance extends IReadOnlyAnnotatable {
    readonly Name: string;
    readonly ModelSchema: string | undefined;
    readonly Schema: string | undefined;
    readonly Model: IReadOnlyModel;
    readonly StartValue: long;
    readonly IncrementBy: int;
    readonly MinValue: Nullable<System_Internal.Int64>;
    readonly MaxValue: Nullable<System_Internal.Int64>;
    readonly Type: Type;
    readonly IsCyclic: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlySequence$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlySequence = IReadOnlySequence$instance;

export interface IReadOnlyServiceProperty$instance extends IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly ParameterBinding: ServiceParameterBinding;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlyServiceProperty = IReadOnlyServiceProperty$instance;

export interface IReadOnlySkipNavigation$instance extends IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable {
    readonly JoinEntityType: IReadOnlyEntityType;
    readonly Inverse: IReadOnlySkipNavigation;
    readonly ForeignKey: IReadOnlyForeignKey;
    readonly IsOnDependent: boolean;
    readonly DeclaringEntityType: IReadOnlyEntityType;
    readonly TargetEntityType: IReadOnlyEntityType;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetFieldName(): string | undefined;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export type IReadOnlySkipNavigation = IReadOnlySkipNavigation$instance;

export interface IReadOnlyStoredProcedure$instance extends IReadOnlyAnnotatable {
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly EntityType: IReadOnlyEntityType;
    readonly IsRowsAffectedReturned: boolean;
    readonly Parameters: IReadOnlyList<IReadOnlyStoredProcedureParameter>;
    readonly ResultColumns: IReadOnlyList<IReadOnlyStoredProcedureResultColumn>;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    FindResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    FindRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    FindRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetSchemaQualifiedName(): string | undefined;
    GetStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedure$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedure = IReadOnlyStoredProcedure$instance;

export interface IReadOnlyStoredProcedureParameter$instance extends IReadOnlyAnnotatable {
    readonly StoredProcedure: IReadOnlyStoredProcedure;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly Direction: ParameterDirection;
    readonly ForOriginalValue: Nullable<System_Internal.Boolean>;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedureParameter$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedureParameter = IReadOnlyStoredProcedureParameter$instance;

export interface IReadOnlyStoredProcedureResultColumn$instance extends IReadOnlyAnnotatable {
    readonly StoredProcedure: IReadOnlyStoredProcedure;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyStoredProcedureResultColumn$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyStoredProcedureResultColumn = IReadOnlyStoredProcedureResultColumn$instance;

export interface IReadOnlyStoreObjectDictionary_1$instance<T> {
    Find(storeObject: StoreObjectIdentifier): T | undefined;
    GetValues(): IEnumerable<T>;
}


export type IReadOnlyStoreObjectDictionary_1<T> = IReadOnlyStoreObjectDictionary_1$instance<T>;

export interface IReadOnlyTrigger$instance extends IReadOnlyAnnotatable {
    readonly ModelName: string;
    readonly EntityType: IReadOnlyEntityType;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
}


export interface IReadOnlyTrigger$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyTrigger = IReadOnlyTrigger$instance;

export interface IReadOnlyTypeBase$instance extends IReadOnlyAnnotatable {
    readonly Model: IReadOnlyModel;
    readonly ContainingEntityType: IReadOnlyEntityType;
    readonly BaseType: IReadOnlyTypeBase | undefined;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export interface IReadOnlyTypeBase$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance {}

export type IReadOnlyTypeBase = IReadOnlyTypeBase$instance;

export interface IRelationalAnnotationProvider$instance {
    For(checkConstraint: ICheckConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(foreignKey: IForeignKeyConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IFunctionColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(model: IRelationalModel, designTime: boolean): IEnumerable<IAnnotation>;
    For(sequence: ISequence, designTime: boolean): IEnumerable<IAnnotation>;
    For(sqlQuery: ISqlQuery, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: ISqlQueryColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(function_: IStoreFunction, designTime: boolean): IEnumerable<IAnnotation>;
    For(parameter: IStoreFunctionParameter, designTime: boolean): IEnumerable<IAnnotation>;
    For(storedProcedure: IStoreStoredProcedure, designTime: boolean): IEnumerable<IAnnotation>;
    For(parameter: IStoreStoredProcedureParameter, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IStoreStoredProcedureResultColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(table: ITable, designTime: boolean): IEnumerable<IAnnotation>;
    For(index: ITableIndex, designTime: boolean): IEnumerable<IAnnotation>;
    For(trigger: ITrigger, designTime: boolean): IEnumerable<IAnnotation>;
    For(constraint: IUniqueConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(view: IView, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IViewColumn, designTime: boolean): IEnumerable<IAnnotation>;
}


export type IRelationalAnnotationProvider = IRelationalAnnotationProvider$instance;

export interface IRelationalModel$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Model: IModel;
    readonly Tables: IEnumerable<ITable>;
    readonly Views: IEnumerable<IView>;
    readonly Queries: IEnumerable<ISqlQuery>;
    readonly Sequences: IEnumerable<ISequence>;
    readonly Functions: IEnumerable<IStoreFunction>;
    readonly StoredProcedures: IEnumerable<IStoreStoredProcedure>;
    readonly Collation: string | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindDefaultTable(name: string): TableBase | undefined;
    FindFunction(name: string, schema: string, parameters: IReadOnlyList<System_Internal.String>): IStoreFunction | undefined;
    FindQuery(name: string): ISqlQuery | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    FindSequence(name: string, schema: string): ISequence | undefined;
    FindStoredProcedure(name: string, schema: string): IStoreStoredProcedure | undefined;
    FindTable(name: string, schema: string): ITable | undefined;
    FindView(name: string, schema: string): IView | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IRelationalModel = IRelationalModel$instance;

export interface IRelationalPropertyOverrides$instance extends IReadOnlyRelationalPropertyOverrides, IReadOnlyAnnotatable, IAnnotatable {
    readonly Property: IProperty;
    readonly StoreObject: StoreObjectIdentifier;
    readonly ColumnName: string | undefined;
    readonly IsColumnNameOverridden: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IRelationalPropertyOverrides = IRelationalPropertyOverrides$instance;

export interface ISequence$instance extends IReadOnlySequence, IReadOnlyAnnotatable, IAnnotatable {
    readonly Model: IModel;
    readonly Name: string;
    readonly ModelSchema: string | undefined;
    readonly Schema: string | undefined;
    readonly StartValue: long;
    readonly IncrementBy: int;
    readonly MinValue: Nullable<System_Internal.Int64>;
    readonly MaxValue: Nullable<System_Internal.Int64>;
    readonly Type: Type;
    readonly IsCyclic: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ISequence = ISequence$instance;

export interface IServiceProperty$instance extends IReadOnlyServiceProperty, IReadOnlyPropertyBase, IReadOnlyAnnotatable, IPropertyBase, IAnnotatable {
    readonly DeclaringEntityType: IEntityType;
    readonly ParameterBinding: ServiceParameterBinding;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IServiceProperty = IServiceProperty$instance;

export interface ISkipNavigation$instance extends IReadOnlySkipNavigation, IReadOnlyNavigationBase, IReadOnlyPropertyBase, IReadOnlyAnnotatable, INavigationBase, IPropertyBase, IAnnotatable {
    readonly DeclaringEntityType: IEntityType;
    readonly TargetEntityType: IEntityType;
    readonly JoinEntityType: IEntityType;
    readonly ForeignKey: IForeignKey;
    readonly Inverse: ISkipNavigation;
    readonly IsOnDependent: boolean;
    readonly IsEagerLoaded: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly Name: string;
    readonly DeclaringType: IReadOnlyTypeBase;
    readonly ClrType: Type;
    readonly Sentinel: unknown | undefined;
    readonly IsCollection: boolean;
    readonly PropertyInfo: PropertyInfo | undefined;
    readonly FieldInfo: FieldInfo | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    IsShadowProperty(): boolean;
    SetIsLoadedWhenNoTracking(entity: unknown): void;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ISkipNavigation = ISkipNavigation$instance;

export interface ISqlQuery$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly EntityTypeMappings: IEnumerable<ISqlQueryMapping>;
    readonly Columns: IEnumerable<ISqlQueryColumn>;
    readonly Sql: string;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): ISqlQueryColumn | undefined;
    FindColumn(name: string): ISqlQueryColumn | undefined;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQuery = ISqlQuery$instance;

export interface ISqlQueryColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly SqlQuery: ISqlQuery;
    readonly PropertyMappings: IReadOnlyList<ISqlQueryColumnMapping>;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindColumnMapping(entityType: IReadOnlyEntityType): ISqlQueryColumnMapping | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryColumn = ISqlQueryColumn$instance;

export interface ISqlQueryColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Column: ISqlQueryColumn;
    readonly SqlQueryMapping: ISqlQueryMapping;
    readonly Property: IProperty;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryColumnMapping = ISqlQueryColumnMapping$instance;

export interface ISqlQueryMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    IsDefaultSqlQueryMapping: boolean;
    readonly SqlQuery: ISqlQuery;
    readonly ColumnMappings: IEnumerable<ISqlQueryColumnMapping>;
    readonly TypeBase: ITypeBase;
    readonly Table: ITableBase;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ISqlQueryMapping = ISqlQueryMapping$instance;

export interface IStoredProcedure$instance extends IReadOnlyStoredProcedure, IReadOnlyAnnotatable, IAnnotatable {
    readonly Name: string;
    readonly EntityType: IEntityType;
    readonly StoreStoredProcedure: IStoreStoredProcedure;
    readonly Parameters: IReadOnlyList<IStoredProcedureParameter>;
    readonly ResultColumns: IReadOnlyList<IStoredProcedureResultColumn>;
    readonly Schema: string | undefined;
    readonly IsRowsAffectedReturned: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindParameter(propertyName: string): IReadOnlyStoredProcedureParameter | undefined;
    FindParameter(propertyName: string): IStoredProcedureParameter | undefined;
    FindResultColumn(propertyName: string): IReadOnlyStoredProcedureResultColumn | undefined;
    FindResultColumn(propertyName: string): IStoredProcedureResultColumn | undefined;
    FindRowsAffectedParameter(): IReadOnlyStoredProcedureParameter | undefined;
    FindRowsAffectedParameter(): IStoredProcedureParameter | undefined;
    FindRowsAffectedResultColumn(): IReadOnlyStoredProcedureResultColumn | undefined;
    FindRowsAffectedResultColumn(): IStoredProcedureResultColumn | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetSchemaQualifiedName(): string | undefined;
    GetStoreIdentifier(): Nullable<StoreObjectIdentifier>;
    GetStoreIdentifier(): StoreObjectIdentifier;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedure = IStoredProcedure$instance;

export interface IStoredProcedureMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoreStoredProcedure: IStoreStoredProcedure;
    readonly StoredProcedure: IStoredProcedure;
    readonly StoredProcedureIdentifier: StoreObjectIdentifier;
    readonly TableMapping: ITableMapping | undefined;
    readonly ParameterMappings: IEnumerable<IStoredProcedureParameterMapping>;
    readonly ResultColumnMappings: IEnumerable<IStoredProcedureResultColumnMapping>;
    readonly TypeBase: ITypeBase;
    readonly Table: ITableBase;
    readonly ColumnMappings: IEnumerable<IColumnMappingBase>;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureMapping = IStoredProcedureMapping$instance;

export interface IStoredProcedureParameter$instance extends IReadOnlyStoredProcedureParameter, IReadOnlyAnnotatable, IAnnotatable {
    readonly StoredProcedure: IStoredProcedure;
    readonly StoreParameter: IStoreStoredProcedureParameter;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly Direction: ParameterDirection;
    readonly ForOriginalValue: Nullable<System_Internal.Boolean>;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureParameter = IStoredProcedureParameter$instance;

export interface IStoredProcedureParameterMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoreParameter: IStoreStoredProcedureParameter;
    readonly Parameter: IStoredProcedureParameter;
    readonly StoredProcedureMapping: IStoredProcedureMapping;
    readonly Property: IProperty;
    readonly Column: IColumnBase;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureParameterMapping = IStoredProcedureParameterMapping$instance;

export interface IStoredProcedureResultColumn$instance extends IReadOnlyStoredProcedureResultColumn, IReadOnlyAnnotatable, IAnnotatable {
    readonly StoredProcedure: IStoredProcedure;
    readonly StoreResultColumn: IStoreStoredProcedureResultColumn;
    readonly Name: string;
    readonly PropertyName: string | undefined;
    readonly ForRowsAffected: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureResultColumn = IStoredProcedureResultColumn$instance;

export interface IStoredProcedureResultColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoreResultColumn: IStoreStoredProcedureResultColumn;
    readonly ResultColumn: IStoredProcedureResultColumn;
    readonly StoredProcedureMapping: IStoredProcedureMapping;
    readonly Property: IProperty;
    readonly Column: IColumnBase;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoredProcedureResultColumnMapping = IStoredProcedureResultColumnMapping$instance;

export interface IStoreFunction$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly DbFunctions: IEnumerable<IDbFunction>;
    readonly IsBuiltIn: boolean;
    readonly Parameters: IEnumerable<IStoreFunctionParameter>;
    readonly ReturnType: string | undefined;
    readonly EntityTypeMappings: IEnumerable<IFunctionMapping>;
    readonly Columns: IEnumerable<IFunctionColumn>;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): IFunctionColumn | undefined;
    FindColumn(name: string): IFunctionColumn | undefined;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreFunction = IStoreFunction$instance;

export interface IStoreFunctionParameter$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Function: IStoreFunction;
    readonly DbFunctionParameters: IEnumerable<IDbFunctionParameter>;
    readonly Name: string;
    readonly StoreType: string;
    readonly Type: string;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreFunctionParameter = IStoreFunctionParameter$instance;

export interface IStoreStoredProcedure$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoredProcedures: IEnumerable<IStoredProcedure>;
    readonly EntityTypeMappings: IEnumerable<IStoredProcedureMapping>;
    readonly ReturnValue: IStoreStoredProcedureReturnValue | undefined;
    readonly Parameters: IReadOnlyList<IStoreStoredProcedureParameter>;
    readonly ResultColumns: IEnumerable<IStoreStoredProcedureResultColumn>;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly Columns: IEnumerable<IColumnBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindParameter(property: IProperty): IStoreStoredProcedureParameter | undefined;
    FindParameter(name: string): IStoreStoredProcedureParameter | undefined;
    FindResultColumn(property: IProperty): IStoreStoredProcedureResultColumn | undefined;
    FindResultColumn(name: string): IStoreStoredProcedureResultColumn | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedure = IStoreStoredProcedure$instance;

export interface IStoreStoredProcedureParameter$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoredProcedure: IStoreStoredProcedure;
    readonly PropertyMappings: IReadOnlyList<IStoredProcedureParameterMapping>;
    readonly Direction: ParameterDirection;
    readonly Position: int;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindParameterMapping(entityType: IReadOnlyEntityType): IStoredProcedureParameterMapping | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureParameter = IStoreStoredProcedureParameter$instance;

export interface IStoreStoredProcedureResultColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoredProcedure: IStoreStoredProcedure;
    readonly PropertyMappings: IReadOnlyList<IStoredProcedureResultColumnMapping>;
    readonly Position: int;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindColumnMapping(entityType: IReadOnlyEntityType): IStoredProcedureResultColumnMapping | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureResultColumn = IStoreStoredProcedureResultColumn$instance;

export interface IStoreStoredProcedureReturnValue$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly StoredProcedure: IStoreStoredProcedure;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly PropertyMappings: IReadOnlyList<IColumnMappingBase>;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IStoreStoredProcedureReturnValue = IStoreStoredProcedureReturnValue$instance;

export interface ITable$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly EntityTypeMappings: IEnumerable<ITableMapping>;
    readonly Columns: IEnumerable<IColumn>;
    readonly IsExcludedFromMigrations: boolean;
    readonly ForeignKeyConstraints: IEnumerable<IForeignKeyConstraint>;
    readonly ReferencingForeignKeyConstraints: IEnumerable<IForeignKeyConstraint>;
    readonly UniqueConstraints: IEnumerable<IUniqueConstraint>;
    readonly PrimaryKey: IPrimaryKeyConstraint | undefined;
    readonly Indexes: IEnumerable<ITableIndex>;
    readonly CheckConstraints: IEnumerable<ICheckConstraint>;
    readonly Triggers: IEnumerable<ITrigger>;
    readonly Comment: string | undefined;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): IColumn | undefined;
    FindColumn(name: string): IColumn | undefined;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITable = ITable$instance;

export interface ITableBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly EntityTypeMappings: IEnumerable<ITableMappingBase>;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly Columns: IEnumerable<IColumnBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableBase = ITableBase$instance;

export interface ITableIndex$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly MappedIndexes: IEnumerable<IIndex>;
    readonly Table: ITable;
    readonly Columns: IReadOnlyList<IColumn>;
    readonly IsUnique: boolean;
    readonly IsDescending: IReadOnlyList<System_Internal.Boolean> | undefined;
    readonly Filter: string | undefined;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableIndex = ITableIndex$instance;

export interface ITableMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Table: ITable;
    readonly ColumnMappings: IEnumerable<IColumnMapping>;
    readonly InsertStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly DeleteStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly UpdateStoredProcedureMapping: IStoredProcedureMapping | undefined;
    readonly TypeBase: ITypeBase;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableMapping = ITableMapping$instance;

export interface ITableMappingBase$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly TypeBase: ITypeBase;
    readonly Table: ITableBase;
    readonly ColumnMappings: IEnumerable<IColumnMappingBase>;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITableMappingBase = ITableMappingBase$instance;

export interface ITrigger$instance extends IReadOnlyTrigger, IReadOnlyAnnotatable, IAnnotatable {
    readonly EntityType: IEntityType;
    readonly ModelName: string;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ITrigger = ITrigger$instance;

export interface ITypeBase$instance extends IReadOnlyTypeBase, IReadOnlyAnnotatable, IAnnotatable {
    readonly Model: IModel;
    readonly ContainingEntityType: IEntityType;
    readonly BaseType: ITypeBase | undefined;
    readonly ConstructorBinding: InstantiationBinding | undefined;
    readonly Name: string;
    readonly ClrType: Type;
    readonly HasSharedClrType: boolean;
    readonly IsPropertyBag: boolean;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindComplexProperty(name: string): IComplexProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindDiscriminatorProperty(): IProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMember(name: string): IPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<IPropertyBase>;
    FindMembersInHierarchy(name: string): IEnumerable<IReadOnlyPropertyBase>;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IReadOnlyProperty> | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IProperty | undefined;
    FindProperty(name: string): IProperty | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetDerivedTypes(): IEnumerable<ITypeBase>;
    GetDerivedTypes(): IEnumerable<IReadOnlyTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyTypeBase;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
}


export type ITypeBase = ITypeBase$instance;

export interface ITypeMappingConfiguration$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly ClrType: Type;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetProviderClrType(): Type | undefined;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetValueConverter(): ValueConverter | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type ITypeMappingConfiguration = ITypeMappingConfiguration$instance;

export interface IUniqueConstraint$instance extends IAnnotatable, IReadOnlyAnnotatable {
    readonly Name: string;
    readonly MappedKeys: IEnumerable<IKey>;
    readonly Table: ITable;
    readonly Columns: IReadOnlyList<IColumn>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetIsPrimaryKey(): boolean;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IUniqueConstraint = IUniqueConstraint$instance;

export interface IView$instance extends ITableBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly EntityTypeMappings: IEnumerable<IViewMapping>;
    readonly Columns: IEnumerable<IViewColumn>;
    readonly ViewDefinitionSql: string | undefined;
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly SchemaQualifiedName: string;
    readonly Model: IRelationalModel;
    readonly IsShared: boolean;
    readonly ComplexTypeMappings: IEnumerable<ITableMappingBase>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumn(property: IProperty): IColumnBase | undefined;
    FindColumn(name: string): IColumnBase | undefined;
    FindColumn(property: IProperty): IViewColumn | undefined;
    FindColumn(name: string): IViewColumn | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRowInternalForeignKeys(entityType: IEntityType): IEnumerable<IForeignKey>;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsOptional(typeBase: ITypeBase): boolean;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IView = IView$instance;

export interface IViewColumn$instance extends IColumnBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly View: IView;
    readonly PropertyMappings: IReadOnlyList<IViewColumnMapping>;
    readonly Name: string;
    readonly StoreType: string;
    readonly ProviderClrType: Type;
    readonly StoreTypeMapping: RelationalTypeMapping;
    readonly IsNullable: boolean;
    readonly Table: ITableBase;
    readonly ProviderValueComparer: ValueComparer;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindColumnMapping(entityType: IReadOnlyEntityType): IColumnMappingBase | undefined;
    FindColumnMapping(entityType: IReadOnlyEntityType): IViewColumnMapping | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewColumn = IViewColumn$instance;

export interface IViewColumnMapping$instance extends IColumnMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly Column: IViewColumn;
    readonly ViewMapping: IViewMapping;
    readonly Property: IProperty;
    readonly TypeMapping: RelationalTypeMapping;
    readonly TableMapping: ITableMappingBase;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewColumnMapping = IViewColumnMapping$instance;

export interface IViewMapping$instance extends ITableMappingBase, IAnnotatable, IReadOnlyAnnotatable {
    readonly View: IView;
    readonly ColumnMappings: IEnumerable<IViewColumnMapping>;
    readonly TypeBase: ITypeBase;
    readonly Table: ITableBase;
    readonly IsSharedTablePrincipal: Nullable<System_Internal.Boolean>;
    readonly IsSplitEntityTypePrincipal: Nullable<System_Internal.Boolean>;
    readonly IncludesDerivedTypes: Nullable<System_Internal.Boolean>;
    readonly [name: string]: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    ToDebugString(options?: MetadataDebugStringOptions, indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
}


export type IViewMapping = IViewMapping$instance;

export interface MemberIdentity$instance {
    readonly MemberInfo: MemberInfo | undefined;
    readonly Name: string | undefined;
    Equals(obj: unknown): boolean;
    Equals(other: MemberIdentity): boolean;
    GetHashCode(): int;
}


export const MemberIdentity: {
    new(name: string): MemberIdentity;
    new(memberInfo: MemberInfo): MemberIdentity;
    readonly None: MemberIdentity;
    Create(memberInfo: MemberInfo): MemberIdentity;
    Create(name: string): MemberIdentity;
};


export type MemberIdentity = MemberIdentity$instance;

export interface ParameterBindingInfo$instance {
    readonly InstanceName: string;
    readonly MaterializationContextExpression: Expression;
    readonly QueryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    readonly ServiceInstances: List<ParameterExpression>;
    readonly StructuralType: ITypeBase;
    GetValueBufferIndex(property: IPropertyBase): int;
}


export const ParameterBindingInfo: {
    new(structuralType: ITypeBase, materializationContextExpression: Expression): ParameterBindingInfo;
    new(materializerSourceParameters: StructuralTypeMaterializerSourceParameters, materializationContextExpression: Expression): ParameterBindingInfo;
};


export type ParameterBindingInfo = ParameterBindingInfo$instance;

export interface StoreObjectIdentifier$instance {
    readonly Name: string;
    readonly Schema: string | undefined;
    readonly StoreObjectType: StoreObjectType;
    CompareTo(other: StoreObjectIdentifier): int;
    DisplayName(): string;
    Equals(obj: unknown): boolean;
    Equals(other: StoreObjectIdentifier): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const StoreObjectIdentifier: {
    new(): StoreObjectIdentifier;
    Create(typeBase: IReadOnlyTypeBase, type: StoreObjectType): Nullable<StoreObjectIdentifier>;
    DbFunction(modelName: string): StoreObjectIdentifier;
    DeleteStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    InsertStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    SqlQuery(entityType: IReadOnlyEntityType): StoreObjectIdentifier;
    SqlQuery(name: string): StoreObjectIdentifier;
    Table(name: string, schema?: string): StoreObjectIdentifier;
    UpdateStoredProcedure(name: string, schema?: string): StoreObjectIdentifier;
    View(name: string, schema?: string): StoreObjectIdentifier;
};


export type StoreObjectIdentifier = StoreObjectIdentifier$instance;

export interface AdHocMapper$instance {
    readonly Dependencies: AdHocMapperDependencies;
    BuildConventionSet(): ConventionSet;
    GetOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export const AdHocMapper: {
    new(dependencies: AdHocMapperDependencies): AdHocMapper;
};


export interface __AdHocMapper$views {
    As_IAdHocMapper(): IAdHocMapper$instance;
}

export interface AdHocMapper$instance extends IAdHocMapper$instance {}

export type AdHocMapper = AdHocMapper$instance & __AdHocMapper$views;


export interface AdHocMapperDependencies$instance {
    Model: IModel;
    ModelCreationDependencies: ModelCreationDependencies;
    _Clone_$(): AdHocMapperDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: AdHocMapperDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const AdHocMapperDependencies: {
    new(model: IModel, modelCreationDependencies: ModelCreationDependencies): AdHocMapperDependencies;
};


export type AdHocMapperDependencies = AdHocMapperDependencies$instance;

export interface ConstructorBinding$instance extends InstantiationBinding {
    readonly Constructor: ConstructorInfo;
    readonly RuntimeType: Type;
    CreateConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    With(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const ConstructorBinding: {
    new(constructor: ConstructorInfo, parameterBindings: IReadOnlyList<ParameterBinding>): ConstructorBinding;
};


export type ConstructorBinding = ConstructorBinding$instance;

export interface ContextParameterBinding$instance extends ServiceParameterBinding {
    BindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ContextParameterBinding: {
    new(contextType: Type, serviceProperties: IPropertyBase[]): ContextParameterBinding;
};


export type ContextParameterBinding = ContextParameterBinding$instance;

export interface DefaultValueBinding$instance extends InstantiationBinding {
    readonly RuntimeType: Type;
    CreateConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    With(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const DefaultValueBinding: {
    new(runtimeType: Type): DefaultValueBinding;
};


export type DefaultValueBinding = DefaultValueBinding$instance;

export interface DependencyInjectionMethodParameterBinding$instance extends DependencyInjectionParameterBinding {
    readonly Method: MethodInfo;
    readonly ServiceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    BindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const DependencyInjectionMethodParameterBinding: {
    new(parameterType: Type, serviceType: Type, method: MethodInfo, serviceProperties: IPropertyBase[]): DependencyInjectionMethodParameterBinding;
};


export type DependencyInjectionMethodParameterBinding = DependencyInjectionMethodParameterBinding$instance;

export interface DependencyInjectionParameterBinding$instance extends ServiceParameterBinding {
    readonly ServiceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    BindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const DependencyInjectionParameterBinding: {
    new(parameterType: Type, serviceType: Type, serviceProperties: IPropertyBase[]): DependencyInjectionParameterBinding;
};


export type DependencyInjectionParameterBinding = DependencyInjectionParameterBinding$instance;

export interface EntityTypeFullNameComparer$instance {
    Compare(x: IReadOnlyEntityType, y: IReadOnlyEntityType): int;
    Equals(x: IReadOnlyEntityType, y: IReadOnlyEntityType): boolean;
    GetHashCode(obj: IReadOnlyEntityType): int;
}


export const EntityTypeFullNameComparer: {
    readonly Instance: EntityTypeFullNameComparer;
};


export type EntityTypeFullNameComparer = EntityTypeFullNameComparer$instance;

export interface EntityTypeParameterBinding$instance extends ServiceParameterBinding {
    BindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const EntityTypeParameterBinding: {
    new(serviceProperties: IPropertyBase[]): EntityTypeParameterBinding;
};


export type EntityTypeParameterBinding = EntityTypeParameterBinding$instance;

export interface FactoryMethodBinding$instance extends InstantiationBinding {
    readonly RuntimeType: Type;
    CreateConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    With(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const FactoryMethodBinding: {
    new(factoryMethod: MethodInfo, parameterBindings: IReadOnlyList<ParameterBinding>, runtimeType: Type): FactoryMethodBinding;
    new(factoryInstance: unknown, factoryMethod: MethodInfo, parameterBindings: IReadOnlyList<ParameterBinding>, runtimeType: Type): FactoryMethodBinding;
};


export type FactoryMethodBinding = FactoryMethodBinding$instance;

export interface ForeignKeyComparer$instance {
    Compare(x: IReadOnlyForeignKey, y: IReadOnlyForeignKey): int;
    Equals(x: IReadOnlyForeignKey, y: IReadOnlyForeignKey): boolean;
    GetHashCode(obj: IReadOnlyForeignKey): int;
}


export const ForeignKeyComparer: {
    readonly Instance: ForeignKeyComparer;
};


export type ForeignKeyComparer = ForeignKeyComparer$instance;

export interface IndexComparer$instance {
    Compare(x: IReadOnlyIndex, y: IReadOnlyIndex): int;
    Equals(x: IReadOnlyIndex, y: IReadOnlyIndex): boolean;
    GetHashCode(obj: IReadOnlyIndex): int;
}


export const IndexComparer: {
    readonly Instance: IndexComparer;
};


export type IndexComparer = IndexComparer$instance;

export interface InstantiationBinding$instance {
    readonly ParameterBindings: IReadOnlyList<ParameterBinding>;
    readonly RuntimeType: Type;
    CreateConstructorExpression(bindingInfo: ParameterBindingInfo): Expression;
    With(parameterBindings: IReadOnlyList<ParameterBinding>): InstantiationBinding;
}


export const InstantiationBinding: (abstract new(parameterBindings: IReadOnlyList<ParameterBinding>) => InstantiationBinding) & {
};


export type InstantiationBinding = InstantiationBinding$instance;

export interface KeyComparer$instance {
    Compare(x: IReadOnlyKey, y: IReadOnlyKey): int;
    Equals(x: IReadOnlyKey, y: IReadOnlyKey): boolean;
    GetHashCode(obj: IReadOnlyKey): int;
}


export const KeyComparer: {
    readonly Instance: KeyComparer;
};


export type KeyComparer = KeyComparer$instance;

export interface LazyLoaderParameterBindingFactory$instance extends ServiceParameterBindingFactory$instance {
    readonly Dependencies: LazyLoaderParameterBindingFactoryDependencies;
    Bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    CanBind(parameterType: Type, parameterName: string): boolean;
}


export const LazyLoaderParameterBindingFactory: {
    new(dependencies: LazyLoaderParameterBindingFactoryDependencies): LazyLoaderParameterBindingFactory;
};


export interface __LazyLoaderParameterBindingFactory$views {
    As_IParameterBindingFactory(): IParameterBindingFactory$instance;
}

export type LazyLoaderParameterBindingFactory = LazyLoaderParameterBindingFactory$instance & __LazyLoaderParameterBindingFactory$views;


export interface LazyLoaderParameterBindingFactoryDependencies$instance {
    _Clone_$(): LazyLoaderParameterBindingFactoryDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: LazyLoaderParameterBindingFactoryDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const LazyLoaderParameterBindingFactoryDependencies: {
    new(): LazyLoaderParameterBindingFactoryDependencies;
};


export type LazyLoaderParameterBindingFactoryDependencies = LazyLoaderParameterBindingFactoryDependencies$instance;

export interface ObjectArrayParameterBinding$instance extends ParameterBinding {
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ObjectArrayParameterBinding: {
    new(bindings: IReadOnlyList<ParameterBinding>): ObjectArrayParameterBinding;
};


export type ObjectArrayParameterBinding = ObjectArrayParameterBinding$instance;

export interface ParameterBinding$instance {
    readonly ConsumedProperties: IReadOnlyList<IPropertyBase>;
    readonly ParameterType: Type;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const ParameterBinding: (abstract new(parameterType: Type, consumedProperties: IPropertyBase[]) => ParameterBinding) & {
};


export type ParameterBinding = ParameterBinding$instance;

export interface PropertyParameterBinding$instance extends ParameterBinding {
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    With(consumedProperties: IPropertyBase[]): ParameterBinding;
}


export const PropertyParameterBinding: {
    new(property: IProperty): PropertyParameterBinding;
};


export type PropertyParameterBinding = PropertyParameterBinding$instance;

export interface RelationalAdHocMapper$instance extends AdHocMapper$instance {
    readonly RelationalDependencies: RelationalAdHocMapperDependencies;
    BuildConventionSet(): ConventionSet;
    GetOrAddEntityType(clrType: Type): RuntimeEntityType;
}


export const RelationalAdHocMapper: {
    new(dependencies: AdHocMapperDependencies, relationalDependencies: RelationalAdHocMapperDependencies): RelationalAdHocMapper;
};


export interface __RelationalAdHocMapper$views {
    As_IAdHocMapper(): IAdHocMapper$instance;
}

export type RelationalAdHocMapper = RelationalAdHocMapper$instance & __RelationalAdHocMapper$views;


export interface RelationalAdHocMapperDependencies$instance {
    _Clone_$(): RelationalAdHocMapperDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalAdHocMapperDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalAdHocMapperDependencies: {
    new(): RelationalAdHocMapperDependencies;
};


export type RelationalAdHocMapperDependencies = RelationalAdHocMapperDependencies$instance;

export interface RelationalAnnotationProvider$instance {
    readonly Dependencies: RelationalAnnotationProviderDependencies;
    For(model: IRelationalModel, designTime: boolean): IEnumerable<IAnnotation>;
    For(table: ITable, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(view: IView, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IViewColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(sqlQuery: ISqlQuery, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: ISqlQueryColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(function_: IStoreFunction, designTime: boolean): IEnumerable<IAnnotation>;
    For(parameter: IStoreFunctionParameter, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IFunctionColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(storedProcedure: IStoreStoredProcedure, designTime: boolean): IEnumerable<IAnnotation>;
    For(parameter: IStoreStoredProcedureParameter, designTime: boolean): IEnumerable<IAnnotation>;
    For(column: IStoreStoredProcedureResultColumn, designTime: boolean): IEnumerable<IAnnotation>;
    For(foreignKey: IForeignKeyConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(index: ITableIndex, designTime: boolean): IEnumerable<IAnnotation>;
    For(constraint: IUniqueConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(sequence: ISequence, designTime: boolean): IEnumerable<IAnnotation>;
    For(checkConstraint: ICheckConstraint, designTime: boolean): IEnumerable<IAnnotation>;
    For(trigger: ITrigger, designTime: boolean): IEnumerable<IAnnotation>;
}


export const RelationalAnnotationProvider: {
    new(dependencies: RelationalAnnotationProviderDependencies): RelationalAnnotationProvider;
};


export interface __RelationalAnnotationProvider$views {
    As_IRelationalAnnotationProvider(): IRelationalAnnotationProvider$instance;
}

export type RelationalAnnotationProvider = RelationalAnnotationProvider$instance & __RelationalAnnotationProvider$views;


export interface RelationalAnnotationProviderDependencies$instance {
    _Clone_$(): RelationalAnnotationProviderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalAnnotationProviderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalAnnotationProviderDependencies: {
    new(): RelationalAnnotationProviderDependencies;
};


export type RelationalAnnotationProviderDependencies = RelationalAnnotationProviderDependencies$instance;

export interface RuntimeComplexProperty$instance extends RuntimePropertyBase$instance {
    readonly ClrType: Type;
    readonly ComplexType: RuntimeComplexType;
    readonly DebugView: DebugView;
    readonly DeclaringType: RuntimeTypeBase;
    readonly IsCollection: boolean;
    readonly Sentinel: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSetter(): IClrPropertySetter;
    GetShadowIndex(): int;
    IsShadowProperty(): boolean;
    ToString(): string;
}


export const RuntimeComplexProperty: {
    new(name: string, clrType: Type, targetTypeName: string, targetType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringType: RuntimeTypeBase, propertyAccessMode: PropertyAccessMode, nullable: boolean, collection: boolean, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, propertyCount: int, complexPropertyCount: int): RuntimeComplexProperty;
};


export interface __RuntimeComplexProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IComplexProperty(): IComplexProperty$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyComplexProperty(): IReadOnlyComplexProperty$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeComplexProperty = RuntimeComplexProperty$instance & __RuntimeComplexProperty$views;


export interface RuntimeComplexType$instance extends RuntimeTypeBase$instance {
    readonly ComplexProperty: RuntimeComplexProperty;
    get ConstructorBinding(): InstantiationBinding | undefined;
    set ConstructorBinding(value: InstantiationBinding | undefined);
    readonly DebugView: DebugView;
    get ServiceOnlyConstructorBinding(): InstantiationBinding | undefined;
    set ServiceOnlyConstructorBinding(value: InstantiationBinding | undefined);
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    CalculateCounts(): PropertyCounts;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindComplexProperty(name: string): RuntimeComplexProperty | undefined;
    FindComplexProperty(name: string): IComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDiscriminatorProperty(): IProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): RuntimePropertyBase | undefined;
    FindMember(name: string): IPropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    FindProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    FindProperty(name: string): RuntimeProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IProperty | undefined;
    FindProperty(name: string): IProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetConstructorBindingConfigurationSource(): Nullable<ConfigurationSource>;
    GetDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    GetDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetMembers(): IEnumerable<RuntimePropertyBase>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyTypeBase;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    SetCounts(value: PropertyCounts): void;
    ToString(): string;
}


export const RuntimeComplexType: {
    new(name: string, type: Type, complexProperty: RuntimeComplexProperty, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, propertyCount: int, complexPropertyCount: int): RuntimeComplexType;
};


export interface __RuntimeComplexType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IComplexType(): IComplexType$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyComplexType(): IReadOnlyComplexType$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeComplexType = RuntimeComplexType$instance & __RuntimeComplexType$views;


export interface RuntimeDbFunction$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    readonly Model: RuntimeModel;
    readonly ModelName: string;
    readonly StoreFunction: IStoreFunction;
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping | undefined);
    AddParameter(name: string, clrType: Type, propagatesNullability: boolean, storeType: string, typeMapping?: RelationalTypeMapping): RuntimeDbFunctionParameter;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeDbFunction: {
    new(modelName: string, model: RuntimeModel, returnType: Type, storeName: string, schema: string, storeType: string, methodInfo: MethodInfo, scalar: boolean, aggregate: boolean, nullable: boolean, builtIn: boolean, typeMapping: RelationalTypeMapping, translation: Func<IReadOnlyList<SqlExpression>, SqlExpression>): RuntimeDbFunction;
};


export interface __RuntimeDbFunction$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IDbFunction(): IDbFunction$instance;
    As_IReadOnlyDbFunction(): IReadOnlyDbFunction$instance;
}

export type RuntimeDbFunction = RuntimeDbFunction$instance & __RuntimeDbFunction$views;


export interface RuntimeDbFunctionParameter$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    readonly Function: RuntimeDbFunction;
    readonly Name: string;
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping | undefined);
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeDbFunctionParameter: {
    new(function_: RuntimeDbFunction, name: string, clrType: Type, propagatesNullability: boolean, storeType: string, typeMapping: RelationalTypeMapping): RuntimeDbFunctionParameter;
};


export interface __RuntimeDbFunctionParameter$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IDbFunctionParameter(): IDbFunctionParameter$instance;
    As_IReadOnlyDbFunctionParameter(): IReadOnlyDbFunctionParameter$instance;
}

export type RuntimeDbFunctionParameter = RuntimeDbFunctionParameter$instance & __RuntimeDbFunctionParameter$views;


export interface RuntimeElementType$instance extends RuntimeAnnotatableBase {
    readonly ClrType: Type;
    readonly CollectionProperty: IProperty;
    readonly DebugView: DebugView;
    readonly IsNullable: boolean;
    TypeMapping: CoreTypeMapping;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    FindTypeMapping(): CoreTypeMapping | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetMaxLength(): Nullable<System_Internal.Int32>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPrecision(): Nullable<System_Internal.Int32>;
    GetProviderClrType(): Type | undefined;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    GetScale(): Nullable<System_Internal.Int32>;
    GetValueComparer(): ValueComparer;
    GetValueConverter(): ValueConverter | undefined;
    IsUnicode(): Nullable<System_Internal.Boolean>;
    SetComparer(valueComparer: ValueComparer): ValueComparer;
    SetValueConverter(converter: ValueConverter): void;
    ToString(): string;
}


export const RuntimeElementType: {
    new(clrType: Type, collectionProperty: RuntimeProperty, nullable: boolean, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueConverter: ValueConverter, valueComparer: ValueComparer, jsonValueReaderWriter: JsonValueReaderWriter, typeMapping: CoreTypeMapping): RuntimeElementType;
};


export interface __RuntimeElementType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IElementType(): IElementType$instance;
    As_IReadOnlyElementType(): IReadOnlyElementType$instance;
}

export type RuntimeElementType = RuntimeElementType$instance & __RuntimeElementType$views;


export interface RuntimeEntityType$instance extends RuntimeTypeBase$instance {
    get ConstructorBinding(): InstantiationBinding | undefined;
    set ConstructorBinding(value: InstantiationBinding | undefined);
    readonly DebugView: DebugView;
    get ServiceOnlyConstructorBinding(): InstantiationBinding | undefined;
    set ServiceOnlyConstructorBinding(value: InstantiationBinding | undefined);
    AddForeignKey(properties: IReadOnlyList<RuntimeProperty>, principalKey: RuntimeKey, principalEntityType: RuntimeEntityType, deleteBehavior?: DeleteBehavior, unique?: boolean, required?: boolean, requiredDependent?: boolean, ownership?: boolean): RuntimeForeignKey;
    AddIndex(properties: IReadOnlyList<RuntimeProperty>, name?: string, unique?: boolean): RuntimeIndex;
    AddKey(properties: IReadOnlyList<RuntimeProperty>): RuntimeKey;
    AddNavigation(name: string, foreignKey: RuntimeForeignKey, onDependent: boolean, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, eagerLoaded?: boolean, lazyLoadingEnabled?: boolean): RuntimeNavigation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddServiceProperty(name: string, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, serviceType?: Type, propertyAccessMode?: PropertyAccessMode): RuntimeServiceProperty;
    AddSkipNavigation(name: string, targetEntityType: RuntimeEntityType, foreignKey: RuntimeForeignKey, collection: boolean, onDependent: boolean, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, eagerLoaded?: boolean, lazyLoadingEnabled?: boolean): RuntimeSkipNavigation;
    AddTrigger(modelName: string): RuntimeTrigger;
    AnnotationsToDebugString(indent?: int): string;
    CalculateCounts(): PropertyCounts;
    DisplayName(): string;
    DisplayName(omitSharedType: boolean): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindComplexProperty(name: string): RuntimeComplexProperty | undefined;
    FindComplexProperty(name: string): IComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IComplexProperty | undefined;
    FindComplexProperty(name: string): IReadOnlyComplexProperty | undefined;
    FindComplexProperty(memberInfo: MemberInfo): IReadOnlyComplexProperty | undefined;
    FindDeclaredForeignKeys(properties: IReadOnlyList<IReadOnlyProperty>): IEnumerable<RuntimeForeignKey>;
    FindDeclaredTrigger(modelName: string): RuntimeTrigger | undefined;
    FindDiscriminatorProperty(): IProperty | undefined;
    FindDiscriminatorProperty(): IReadOnlyProperty | undefined;
    FindForeignKey(properties: IReadOnlyList<IReadOnlyProperty>, principalKey: IReadOnlyKey, principalEntityType: IReadOnlyEntityType): RuntimeForeignKey | undefined;
    FindIndex(properties: IReadOnlyList<IReadOnlyProperty>): RuntimeIndex | undefined;
    FindIndex(name: string): RuntimeIndex | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindKey(properties: IReadOnlyList<IReadOnlyProperty>): RuntimeKey | undefined;
    FindMember(name: string): RuntimePropertyBase | undefined;
    FindMember(name: string): IPropertyBase | undefined;
    FindMember(name: string): IReadOnlyPropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    FindNavigation(name: string): RuntimeNavigation | undefined;
    FindNavigationsInHierarchy(name: string): IEnumerable<RuntimeNavigation>;
    FindProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    FindProperties(propertyNames: IReadOnlyList<System_Internal.String>): IReadOnlyList<IProperty> | undefined;
    FindProperty(name: string): RuntimeProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IProperty | undefined;
    FindProperty(name: string): IProperty | undefined;
    FindProperty(name: string): IReadOnlyProperty | undefined;
    FindProperty(memberInfo: MemberInfo): IReadOnlyProperty | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    FindServicePropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeServiceProperty>;
    FindServiceProperty(name: string): RuntimeServiceProperty | undefined;
    FindSkipNavigation(name: string): RuntimeSkipNavigation | undefined;
    FindSkipNavigationsInHierarchy(name: string): IEnumerable<RuntimeSkipNavigation>;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetChangeTrackingStrategy(): ChangeTrackingStrategy;
    GetConstructorBindingConfigurationSource(): Nullable<ConfigurationSource>;
    GetDeclaredForeignKeys(): List<RuntimeForeignKey>;
    GetDeclaredIndexes(): IEnumerable<RuntimeIndex>;
    GetDeclaredKeys(): IEnumerable<RuntimeKey>;
    GetDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    GetDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    GetDiscriminatorValue(): unknown | undefined;
    GetForeignKeys(): IEnumerable<RuntimeForeignKey>;
    GetIndexes(): IEnumerable<RuntimeIndex>;
    GetKeys(): IEnumerable<RuntimeKey>;
    GetMembers(): IEnumerable<RuntimePropertyBase>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRootType(): IReadOnlyTypeBase;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    GetSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    IsAbstract(): boolean;
    IsAssignableFrom(derivedType: IReadOnlyTypeBase): boolean;
    Reparent(model: RuntimeModel): void;
    SetCounts(counts: PropertyCounts): void;
    SetPrimaryKey(key: RuntimeKey): void;
    SetRelationshipSnapshotFactory(factory: Func<IInternalEntry, ISnapshot>): void;
    ToString(): string;
}


export const RuntimeEntityType: {
    new(name: string, type: Type, sharedClrType: boolean, model: RuntimeModel, baseType: RuntimeEntityType, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, derivedTypesCount: int, propertyCount: int, complexPropertyCount: int, foreignKeyCount: int, navigationCount: int, skipNavigationCount: int, servicePropertyCount: int, unnamedIndexCount: int, namedIndexCount: int, keyCount: int, triggerCount: int): RuntimeEntityType;
};


export interface __RuntimeEntityType$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IEntityType(): IEntityType$instance;
    As_IRuntimeEntityType(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeEntityType$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyEntityType(): IReadOnlyEntityType$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeEntityType = RuntimeEntityType$instance & __RuntimeEntityType$views;


export interface RuntimeEntityTypeMappingFragment$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    readonly EntityType: RuntimeEntityType;
    readonly IsTableExcludedFromMigrations: Nullable<System_Internal.Boolean>;
    readonly StoreObject: StoreObjectIdentifier;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeEntityTypeMappingFragment: {
    new(entityType: RuntimeEntityType, storeObject: StoreObjectIdentifier, isTableExcludedFromMigrations: Nullable<System_Internal.Boolean>): RuntimeEntityTypeMappingFragment;
};


export interface __RuntimeEntityTypeMappingFragment$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IEntityTypeMappingFragment(): IEntityTypeMappingFragment$instance;
    As_IReadOnlyEntityTypeMappingFragment(): IReadOnlyEntityTypeMappingFragment$instance;
}

export type RuntimeEntityTypeMappingFragment = RuntimeEntityTypeMappingFragment$instance & __RuntimeEntityTypeMappingFragment$views;


export interface RuntimeForeignKey$instance extends RuntimeAnnotatableBase {
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly PrincipalEntityType: RuntimeEntityType;
    readonly PrincipalKey: RuntimeKey;
    readonly Properties: IReadOnlyList<RuntimeProperty>;
    get ReferencingSkipNavigations(): ISet<RuntimeSkipNavigation> | undefined;
    set ReferencingSkipNavigations(value: ISet<RuntimeSkipNavigation> | undefined);
    AddNavigation(navigation: RuntimeNavigation, onDependent: boolean): void;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeForeignKey: {
    new(dependentProperties: IReadOnlyList<RuntimeProperty>, principalKey: RuntimeKey, dependentEntityType: RuntimeEntityType, principalEntityType: RuntimeEntityType, deleteBehavior: DeleteBehavior, unique: boolean, required: boolean, requiredDependent: boolean, ownership: boolean): RuntimeForeignKey;
};


export interface __RuntimeForeignKey$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IForeignKey(): IForeignKey$instance;
    As_IRuntimeForeignKey(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeForeignKey$instance;
    As_IReadOnlyForeignKey(): IReadOnlyForeignKey$instance;
}

export type RuntimeForeignKey = RuntimeForeignKey$instance & __RuntimeForeignKey$views;


export interface RuntimeIndex$instance extends RuntimeAnnotatableBase {
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly Name: string | undefined;
    readonly Properties: IReadOnlyList<RuntimeProperty>;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeIndex: {
    new(properties: IReadOnlyList<RuntimeProperty>, declaringEntityType: RuntimeEntityType, name: string, unique: boolean): RuntimeIndex;
};


export interface __RuntimeIndex$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IIndex(): IIndex$instance;
    As_IReadOnlyIndex(): IReadOnlyIndex$instance;
}

export type RuntimeIndex = RuntimeIndex$instance & __RuntimeIndex$views;


export interface RuntimeKey$instance extends RuntimeAnnotatableBase {
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly Properties: IReadOnlyList<RuntimeProperty>;
    get ReferencingForeignKeys(): ISet<RuntimeForeignKey> | undefined;
    set ReferencingForeignKeys(value: ISet<RuntimeForeignKey> | undefined);
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    SetIdentityMapFactory(factory: Func<System_Internal.Boolean, IIdentityMap>): void;
    SetPrincipalKeyValueFactory<TKey>(factory: IPrincipalKeyValueFactory_1<TKey>): void;
    ToString(): string;
}


export const RuntimeKey: {
    new(properties: IReadOnlyList<RuntimeProperty>): RuntimeKey;
};


export interface __RuntimeKey$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IKey(): IKey$instance;
    As_IRuntimeKey(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeKey$instance;
    As_IReadOnlyKey(): IReadOnlyKey$instance;
}

export type RuntimeKey = RuntimeKey$instance & __RuntimeKey$views;


export interface RuntimeModel$instance extends RuntimeAnnotatableBase {
    readonly DebugView: DebugView;
    ModelId: Guid;
    AddEntityType(name: string, type: Type, baseType?: RuntimeEntityType, sharedClrType?: boolean, changeTrackingStrategy?: ChangeTrackingStrategy, indexerPropertyInfo?: PropertyInfo, propertyBag?: boolean, discriminatorProperty?: string, discriminatorValue?: unknown, derivedTypesCount?: int, propertyCount?: int, complexPropertyCount?: int, navigationCount?: int, skipNavigationCount?: int, servicePropertyCount?: int, foreignKeyCount?: int, unnamedIndexCount?: int, namedIndexCount?: int, keyCount?: int, triggerCount?: int): RuntimeEntityType;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddTypeMappingConfiguration(clrType: Type, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerPropertyType?: Type, valueConverter?: ValueConverter): RuntimeTypeMappingConfiguration;
    AnnotationsToDebugString(indent?: int): string;
    FinalizeModel(): IModel;
    FindAdHocEntityType(clrType: Type): RuntimeEntityType | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindEntityType(name: string): RuntimeEntityType | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAdHocEntityTypes(): IEnumerable<IReadOnlyEntityType>;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddAdHocEntityType(entityType: RuntimeEntityType): RuntimeEntityType;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    SetSkipDetectChanges(skipDetectChanges: boolean): void;
}


export const RuntimeModel: {
    new(): RuntimeModel;
    new(skipDetectChanges: boolean, modelId: Guid, entityTypeCount: int, typeConfigurationCount: int): RuntimeModel;
};


export interface __RuntimeModel$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IModel(): IModel$instance;
    As_IRuntimeModel(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeModel$instance;
    As_IReadOnlyModel(): IReadOnlyModel$instance;
}

export type RuntimeModel = RuntimeModel$instance & __RuntimeModel$views;


export interface RuntimeNavigation$instance extends RuntimePropertyBase$instance {
    readonly ClrType: Type;
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly DeclaringType: RuntimeTypeBase;
    readonly ForeignKey: RuntimeForeignKey;
    readonly IsCollection: boolean;
    readonly Sentinel: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSetter(): IClrPropertySetter;
    GetShadowIndex(): int;
    IsShadowProperty(): boolean;
    SetCollectionAccessor<TEntity, TCollection extends IEnumerable<TElement>, TElement>(getCollection: Func<TEntity, TCollection>, setCollection: Action<TEntity, TCollection>, setCollectionForMaterialization: Action<TEntity, TCollection>, createAndSetCollection: Func<TEntity, Action<TEntity, TCollection>, TCollection>, createCollection: Func<TCollection>): void;
    ToString(): string;
}


export const RuntimeNavigation: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, foreignKey: RuntimeForeignKey, propertyAccessMode: PropertyAccessMode, eagerLoaded: boolean, lazyLoadingEnabled: boolean): RuntimeNavigation;
};


export interface __RuntimeNavigation$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_INavigation(): INavigation$instance;
    As_INavigationBase(): INavigationBase$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyNavigation(): IReadOnlyNavigation$instance;
    As_IReadOnlyNavigationBase(): IReadOnlyNavigationBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeNavigation = RuntimeNavigation$instance & __RuntimeNavigation$views;


export interface RuntimeProperty$instance extends RuntimePropertyBase$instance {
    readonly ClrType: Type;
    readonly DebugView: DebugView;
    readonly DeclaringType: RuntimeTypeBase;
    get ForeignKeys(): ISet<RuntimeForeignKey> | undefined;
    set ForeignKeys(value: ISet<RuntimeForeignKey> | undefined);
    get Indexes(): List<RuntimeIndex> | undefined;
    set Indexes(value: List<RuntimeIndex> | undefined);
    readonly IsCollection: boolean;
    IsPrimitiveCollection: boolean;
    get Keys(): List<RuntimeKey> | undefined;
    set Keys(value: List<RuntimeKey> | undefined);
    get PrimaryKey(): RuntimeKey | undefined;
    set PrimaryKey(value: RuntimeKey | undefined);
    readonly Sentinel: unknown | undefined;
    TypeMapping: CoreTypeMapping;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetElementType(): IElementType | undefined;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    GetJsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    GetKeyValueComparer(): ValueComparer;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSetter(): IClrPropertySetter;
    GetShadowIndex(): int;
    GetValueComparer(): ValueComparer;
    IsShadowProperty(): boolean;
    SetComparer(valueComparer: ValueComparer): ValueComparer;
    SetElementType(clrType: Type, nullable?: boolean, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerClrType?: Type, valueConverter?: ValueConverter, valueComparer?: ValueComparer, jsonValueReaderWriter?: JsonValueReaderWriter, typeMapping?: CoreTypeMapping): RuntimeElementType;
    SetKeyComparer(valueComparer: ValueComparer): ValueComparer;
    SetProviderValueComparer(valueComparer: ValueComparer): ValueComparer;
    SetSentinelFromProviderValue(providerValue: unknown): void;
    SetValueConverter(converter: ValueConverter): void;
    ToString(): string;
}


export const RuntimeProperty: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringType: RuntimeTypeBase, propertyAccessMode: PropertyAccessMode, nullable: boolean, concurrencyToken: boolean, valueGenerated: ValueGenerated, beforeSaveBehavior: PropertySaveBehavior, afterSaveBehavior: PropertySaveBehavior, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>, valueConverter: ValueConverter, valueComparer: ValueComparer, keyValueComparer: ValueComparer, providerValueComparer: ValueComparer, jsonValueReaderWriter: JsonValueReaderWriter, typeMapping: CoreTypeMapping, sentinel: unknown): RuntimeProperty;
};


export interface __RuntimeProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IProperty(): IProperty$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyProperty(): IReadOnlyProperty$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimeProperty = RuntimeProperty$instance & __RuntimeProperty$views;


export interface RuntimePropertyBase$instance extends RuntimeAnnotatableBase {
    readonly ClrType: Type;
    readonly DeclaringType: RuntimeTypeBase;
    readonly IsCollection: boolean;
    readonly Name: string;
    readonly Sentinel: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    SetAccessors<TProperty>(currentValueGetter: Func<IInternalEntry, TProperty>, preStoreGeneratedCurrentValueGetter: Func<IInternalEntry, TProperty>, originalValueGetter: Func<IInternalEntry, TProperty>, relationshipSnapshotGetter: Func<IInternalEntry, TProperty>): void;
    SetCurrentValueComparer(comparer: IComparer<IUpdateEntry>): void;
    SetGetter<TEntity, TValue>(getClrValue: Func<TEntity, TValue>, hasSentinel: Func<TEntity, System_Internal.Boolean>): void;
    SetGetter<TEntity, TStructural, TValue>(getClrValueUsingContainingEntity: Func<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, hasSentinelUsingContainingEntity: Func<TEntity, IReadOnlyList<System_Internal.Int32>, System_Internal.Boolean>, getClrValue: Func<TStructural, TValue>, hasSentinel: Func<TStructural, System_Internal.Boolean>): void;
    SetIndexedCollectionAccessor<TEntity, TCollection extends IList<TElement>, TElement>(get: Func<TEntity, System_Internal.Int32, TElement>, set: Action<TEntity, System_Internal.Int32, TElement>, setForMaterialization: Action<TEntity, System_Internal.Int32, TElement>, createCollection: Func<System_Internal.Int32, TCollection>): void;
    SetMaterializationSetter<TEntity, TStructural, TValue>(setClrValueUsingContainingEntity: Action<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, setClrValue: Func<TStructural, TValue, TStructural>): void;
    SetMaterializationSetter<TEntity, TValue>(setClrValue: Func<TEntity, TValue, TEntity>): void;
    SetPropertyIndexes(index: int, originalValueIndex: int, shadowIndex: int, relationshipIndex: int, storeGenerationIndex: int): void;
    SetSetter<TEntity, TStructural, TValue>(setClrValueUsingContainingEntity: Action<TEntity, IReadOnlyList<System_Internal.Int32>, TValue>, setClrValue: Func<TStructural, TValue, TStructural>): void;
    SetSetter<TEntity, TValue>(setClrValue: Func<TEntity, TValue, TEntity>): void;
}


export const RuntimePropertyBase: (abstract new(name: string, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, propertyAccessMode: PropertyAccessMode) => RuntimePropertyBase) & {
};


export interface __RuntimePropertyBase$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
}

export type RuntimePropertyBase = RuntimePropertyBase$instance & __RuntimePropertyBase$views;


export interface RuntimeRelationalPropertyOverrides$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    readonly Property: RuntimeProperty;
    readonly StoreObject: StoreObjectIdentifier;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeRelationalPropertyOverrides: {
    new(property: RuntimeProperty, storeObject: StoreObjectIdentifier, columnNameOverridden: boolean, columnName: string): RuntimeRelationalPropertyOverrides;
};


export interface __RuntimeRelationalPropertyOverrides$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyRelationalPropertyOverrides(): IReadOnlyRelationalPropertyOverrides$instance;
    As_IRelationalPropertyOverrides(): IRelationalPropertyOverrides$instance;
}

export type RuntimeRelationalPropertyOverrides = RuntimeRelationalPropertyOverrides$instance & __RuntimeRelationalPropertyOverrides$views;


export interface RuntimeSequence$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    readonly Model: RuntimeModel;
    readonly ModelSchema: string | undefined;
    readonly Name: string;
    readonly Schema: string | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeSequence: {
    new(name: string, model: RuntimeModel, type: Type, schema: string, startValue: long, incrementBy: int, cyclic: boolean, minValue: Nullable<System_Internal.Int64>, maxValue: Nullable<System_Internal.Int64>, modelSchemaIsNull: boolean): RuntimeSequence;
};


export interface __RuntimeSequence$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlySequence(): IReadOnlySequence$instance;
    As_ISequence(): ISequence$instance;
}

export type RuntimeSequence = RuntimeSequence$instance & __RuntimeSequence$views;


export interface RuntimeServiceProperty$instance extends RuntimePropertyBase$instance {
    readonly ClrType: Type;
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly DeclaringType: RuntimeTypeBase;
    readonly IsCollection: boolean;
    ParameterBinding: ServiceParameterBinding;
    readonly Sentinel: unknown | undefined;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSetter(): IClrPropertySetter;
    GetShadowIndex(): int;
    IsShadowProperty(): boolean;
    ToString(): string;
}


export const RuntimeServiceProperty: {
    new(name: string, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, serviceType: Type, declaringEntityType: RuntimeEntityType, propertyAccessMode: PropertyAccessMode): RuntimeServiceProperty;
};


export interface __RuntimeServiceProperty$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
    As_IReadOnlyServiceProperty(): IReadOnlyServiceProperty$instance;
    As_IServiceProperty(): IServiceProperty$instance;
}

export type RuntimeServiceProperty = RuntimeServiceProperty$instance & __RuntimeServiceProperty$views;


export interface RuntimeSkipNavigation$instance extends RuntimePropertyBase$instance {
    readonly ClrType: Type;
    readonly DebugView: DebugView;
    readonly DeclaringEntityType: RuntimeEntityType;
    readonly DeclaringType: RuntimeTypeBase;
    Inverse: RuntimeSkipNavigation;
    readonly IsCollection: boolean;
    readonly Sentinel: unknown | undefined;
    readonly TargetEntityType: RuntimeEntityType;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetCollectionAccessor(): IClrCollectionAccessor | undefined;
    GetCurrentValueComparer(): IComparer<IUpdateEntry>;
    GetFieldName(): string | undefined;
    GetGetter(): IClrPropertyGetter;
    GetIndex(): int;
    GetIndexedCollectionAccessor(): IClrIndexedCollectionAccessor;
    GetMemberInfo(forMaterialization: boolean, forSet: boolean): MemberInfo;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetPropertyAccessMode(): PropertyAccessMode;
    GetRuntimeAnnotations(): IEnumerable<IAnnotation>;
    GetSetter(): IClrPropertySetter;
    GetShadowIndex(): int;
    IsShadowProperty(): boolean;
    SetCollectionAccessor<TEntity, TCollection extends IEnumerable<TElement>, TElement>(getCollection: Func<TEntity, TCollection>, setCollection: Action<TEntity, TCollection>, setCollectionForMaterialization: Action<TEntity, TCollection>, createAndSetCollection: Func<TEntity, Action<TEntity, TCollection>, TCollection>, createCollection: Func<TCollection>): void;
    ToString(): string;
}


export const RuntimeSkipNavigation: {
    new(name: string, clrType: Type, propertyInfo: PropertyInfo, fieldInfo: FieldInfo, declaringEntityType: RuntimeEntityType, targetEntityType: RuntimeEntityType, foreignKey: RuntimeForeignKey, collection: boolean, onDependent: boolean, propertyAccessMode: PropertyAccessMode, eagerLoaded: boolean, lazyLoadingEnabled: boolean): RuntimeSkipNavigation;
};


export interface __RuntimeSkipNavigation$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_INavigationBase(): INavigationBase$instance;
    As_IRuntimePropertyBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimePropertyBase$instance;
    As_IRuntimeSkipNavigation(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeSkipNavigation$instance;
    As_IPropertyBase(): IPropertyBase$instance;
    As_IReadOnlyNavigationBase(): IReadOnlyNavigationBase$instance;
    As_IReadOnlyPropertyBase(): IReadOnlyPropertyBase$instance;
    As_IReadOnlySkipNavigation(): IReadOnlySkipNavigation$instance;
    As_ISkipNavigation(): ISkipNavigation$instance;
}

export type RuntimeSkipNavigation = RuntimeSkipNavigation$instance & __RuntimeSkipNavigation$views;


export interface RuntimeStoredProcedure$instance extends AnnotatableBase {
    readonly DebugView: DebugView;
    EntityType: RuntimeEntityType;
    AddParameter(name: string, direction: ParameterDirection, forRowsAffected: boolean, propertyName: string, forOriginalValue: Nullable<System_Internal.Boolean>): RuntimeStoredProcedureParameter;
    AddResultColumn(name: string, forRowsAffected: boolean, propertyName: string): RuntimeStoredProcedureResultColumn;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<Annotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeStoredProcedure: {
    new(entityType: RuntimeEntityType, name: string, schema: string, rowsAffectedReturned: boolean): RuntimeStoredProcedure;
};


export interface __RuntimeStoredProcedure$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyStoredProcedure(): IReadOnlyStoredProcedure$instance;
    As_IStoredProcedure(): IStoredProcedure$instance;
}

export type RuntimeStoredProcedure = RuntimeStoredProcedure$instance & __RuntimeStoredProcedure$views;


export interface RuntimeTrigger$instance extends RuntimeAnnotatableBase {
    readonly DebugView: DebugView;
    readonly EntityType: IEntityType;
    readonly ModelName: string;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    ToString(): string;
}


export const RuntimeTrigger: {
    new(entityType: RuntimeEntityType, modelName: string): RuntimeTrigger;
};


export interface __RuntimeTrigger$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IReadOnlyTrigger(): IReadOnlyTrigger$instance;
    As_ITrigger(): ITrigger$instance;
}

export type RuntimeTrigger = RuntimeTrigger$instance & __RuntimeTrigger$views;


export interface RuntimeTypeBase$instance extends RuntimeAnnotatableBase {
    readonly BaseType: RuntimeTypeBase | undefined;
    readonly ClrType: Type;
    get ConstructorBinding(): InstantiationBinding | undefined;
    set ConstructorBinding(value: InstantiationBinding | undefined);
    readonly DirectlyDerivedTypes: IEnumerable<RuntimeTypeBase>;
    readonly EmptyShadowValuesFactory: Func<ISnapshot>;
    readonly HasDirectlyDerivedTypes: boolean;
    Model: RuntimeModel;
    readonly Name: string;
    readonly OriginalValuesFactory: Func<IInternalEntry, ISnapshot>;
    readonly ShadowValuesFactory: Func<IDictionary<System_Internal.String, unknown | undefined>, ISnapshot>;
    readonly StoreGeneratedValuesFactory: Func<ISnapshot>;
    readonly TemporaryValuesFactory: Func<IInternalEntry, ISnapshot>;
    AddComplexProperty(name: string, clrType: Type, targetTypeName: string, targetType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, nullable?: boolean, collection?: boolean, changeTrackingStrategy?: ChangeTrackingStrategy, indexerPropertyInfo?: PropertyInfo, propertyBag?: boolean, discriminatorProperty?: string, discriminatorValue?: unknown, propertyCount?: int, complexPropertyCount?: int): RuntimeComplexProperty;
    AddProperty(name: string, clrType: Type, propertyInfo?: PropertyInfo, fieldInfo?: FieldInfo, propertyAccessMode?: PropertyAccessMode, nullable?: boolean, concurrencyToken?: boolean, valueGenerated?: ValueGenerated, beforeSaveBehavior?: PropertySaveBehavior, afterSaveBehavior?: PropertySaveBehavior, maxLength?: Nullable<System_Internal.Int32>, unicode?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, providerPropertyType?: Type, valueGeneratorFactory?: Func<IProperty, ITypeBase, ValueGenerator>, valueConverter?: ValueConverter, valueComparer?: ValueComparer, keyValueComparer?: ValueComparer, providerValueComparer?: ValueComparer, jsonValueReaderWriter?: JsonValueReaderWriter, typeMapping?: CoreTypeMapping, sentinel?: unknown): RuntimeProperty;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    CalculateCounts(): PropertyCounts;
    FinalizeType(): void;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindComplexPropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeComplexProperty>;
    FindComplexProperty(name: string): RuntimeComplexProperty | undefined;
    FindDeclaredProperty(name: string): RuntimeProperty | undefined;
    FindIndexerPropertyInfo(): PropertyInfo | undefined;
    FindMember(name: string): RuntimePropertyBase | undefined;
    FindMembersInHierarchy(name: string): IEnumerable<RuntimePropertyBase>;
    FindProperties(propertyNames: IEnumerable<System_Internal.String>): IReadOnlyList<RuntimeProperty> | undefined;
    FindPropertiesInHierarchy(propertyName: string): IEnumerable<RuntimeProperty>;
    FindProperty(name: string): RuntimeProperty | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    GetDeclaredComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    GetDeclaredMembers(): IEnumerable<RuntimePropertyBase>;
    GetDeclaredProperties(): IEnumerable<RuntimeProperty>;
    GetDerivedTypes(): IEnumerable<RuntimeTypeBase>;
    GetDerivedTypes<T extends RuntimeTypeBase>(): IEnumerable<T>;
    GetFlattenedComplexProperties(): IEnumerable<RuntimeComplexProperty>;
    GetFlattenedDeclaredProperties(): IEnumerable<RuntimeProperty>;
    GetFlattenedProperties(): IEnumerable<RuntimeProperty>;
    GetFlattenedValueGeneratingProperties(): IEnumerable<RuntimeProperty>;
    GetMembers(): IEnumerable<RuntimePropertyBase>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateEmptyMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetOrCreateMaterializer(source: IStructuralTypeMaterializerSource): Func<MaterializationContext, unknown>;
    GetProperties(): IEnumerable<RuntimeProperty>;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
    GetSnapshottableMembers(): IEnumerable<RuntimePropertyBase>;
    SetEmptyShadowValuesFactory(factory: Func<ISnapshot>): void;
    SetOriginalValuesFactory(factory: Func<IInternalEntry, ISnapshot>): void;
    SetShadowValuesFactory(factory: Func<IDictionary<System_Internal.String, unknown>, ISnapshot>): void;
    SetStoreGeneratedValuesFactory(factory: Func<ISnapshot>): void;
    SetTemporaryValuesFactory(factory: Func<IInternalEntry, ISnapshot>): void;
}


export const RuntimeTypeBase: (abstract new(name: string, type: Type, model: RuntimeModel, baseType: RuntimeTypeBase, changeTrackingStrategy: ChangeTrackingStrategy, indexerPropertyInfo: PropertyInfo, propertyBag: boolean, discriminatorProperty: string, discriminatorValue: unknown, derivedTypesCount: int, propertyCount: int, complexPropertyCount: int) => RuntimeTypeBase) & {
    FindIndexerProperty(type: Type): PropertyInfo | undefined;
    ToEnumerable<T>(element: T): IEnumerable<T>;
};


export interface __RuntimeTypeBase$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_IRuntimeTypeBase(): Microsoft_EntityFrameworkCore_Metadata_Internal_Internal.IRuntimeTypeBase$instance;
    As_IReadOnlyTypeBase(): IReadOnlyTypeBase$instance;
    As_ITypeBase(): ITypeBase$instance;
}

export type RuntimeTypeBase = RuntimeTypeBase$instance & __RuntimeTypeBase$views;


export interface RuntimeTypeMappingConfiguration$instance extends RuntimeAnnotatableBase {
    readonly ClrType: Type;
    AddRuntimeAnnotation(name: string, value: unknown): Annotation;
    AddRuntimeAnnotation(name: string, annotation: Annotation): Annotation;
    AddRuntimeAnnotation(name: string, value: unknown): IAnnotation;
    AnnotationsToDebugString(indent?: int): string;
    FindAnnotation(name: string): Annotation | undefined;
    FindAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotation(name: string): Annotation | undefined;
    FindRuntimeAnnotation(name: string): IAnnotation | undefined;
    FindRuntimeAnnotationValue(name: string): unknown | undefined;
    GetAnnotations(): IEnumerable<IAnnotation>;
    GetOrAddRuntimeAnnotationValue<TValue, TArg>(name: string, valueFactory: Func<TArg, TValue>, factoryArgument: TArg): TValue;
    GetRuntimeAnnotations(): IEnumerable<Annotation>;
}


export const RuntimeTypeMappingConfiguration: {
    new(clrType: Type, maxLength: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, providerClrType: Type, valueConverter: ValueConverter): RuntimeTypeMappingConfiguration;
};


export interface __RuntimeTypeMappingConfiguration$views {
    As_IAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IAnnotatable$instance;
    As_IReadOnlyAnnotatable(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IReadOnlyAnnotatable$instance;
    As_ITypeMappingConfiguration(): ITypeMappingConfiguration$instance;
}

export type RuntimeTypeMappingConfiguration = RuntimeTypeMappingConfiguration$instance & __RuntimeTypeMappingConfiguration$views;


export interface ServiceParameterBinding$instance extends ParameterBinding {
    readonly ServiceDelegate: Func<MaterializationContext, IEntityType, unknown, unknown | undefined>;
    readonly ServiceType: Type;
    BindToParameter(bindingInfo: ParameterBindingInfo): Expression;
    BindToParameter(materializationExpression: Expression, bindingInfoExpression: Expression): Expression;
}


export const ServiceParameterBinding: (abstract new(parameterType: Type, serviceType: Type, serviceProperties: IPropertyBase[]) => ServiceParameterBinding) & {
};


export type ServiceParameterBinding = ServiceParameterBinding$instance;

export interface ServiceParameterBindingFactory$instance {
    Bind(entityType: IMutableEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IConventionEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    Bind(entityType: IReadOnlyEntityType, parameterType: Type, parameterName: string): ParameterBinding;
    CanBind(parameterType: Type, parameterName: string): boolean;
}


export const ServiceParameterBindingFactory: {
    new(serviceType: Type): ServiceParameterBindingFactory;
};


export interface __ServiceParameterBindingFactory$views {
    As_IParameterBindingFactory(): IParameterBindingFactory$instance;
}

export type ServiceParameterBindingFactory = ServiceParameterBindingFactory$instance & __ServiceParameterBindingFactory$views;


export interface SimpleModelFactory$instance {
    Create(): IMutableModel;
}


export const SimpleModelFactory: {
    new(): SimpleModelFactory;
};


export type SimpleModelFactory = SimpleModelFactory$instance;

export interface StoreObjectDictionary_1$instance<T> {
    Add(storeObject: StoreObjectIdentifier, value: T): void;
    Find(storeObject: StoreObjectIdentifier): T | undefined;
    GetValues(): IEnumerable<T>;
    Remove(storeObject: StoreObjectIdentifier): T | undefined;
}


export const StoreObjectDictionary_1: {
    new<T>(): StoreObjectDictionary_1<T>;
};


export interface __StoreObjectDictionary_1$views<T> {
    As_IReadOnlyStoreObjectDictionary_1(): IReadOnlyStoreObjectDictionary_1$instance<T>;
}

export type StoreObjectDictionary_1<T> = StoreObjectDictionary_1$instance<T> & __StoreObjectDictionary_1$views<T>;


export interface TypeBaseNameComparer$instance {
    Compare(x: IReadOnlyTypeBase, y: IReadOnlyTypeBase): int;
    Equals(x: IReadOnlyTypeBase, y: IReadOnlyTypeBase): boolean;
    GetHashCode(obj: IReadOnlyTypeBase): int;
}


export const TypeBaseNameComparer: {
    readonly Instance: TypeBaseNameComparer;
};


export type TypeBaseNameComparer = TypeBaseNameComparer$instance;

export abstract class ConfigurationSourceExtensions$instance {
    static Max(left: ConfigurationSource, right: Nullable<ConfigurationSource>): ConfigurationSource;
    static Max(left: Nullable<ConfigurationSource>, right: Nullable<ConfigurationSource>): Nullable<ConfigurationSource>;
    static Overrides(newConfigurationSource: ConfigurationSource, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static Overrides(newConfigurationSource: Nullable<ConfigurationSource>, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static OverridesStrictly(newConfigurationSource: ConfigurationSource, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
    static OverridesStrictly(newConfigurationSource: Nullable<ConfigurationSource>, oldConfigurationSource: Nullable<ConfigurationSource>): boolean;
}


export type ConfigurationSourceExtensions = ConfigurationSourceExtensions$instance;

export abstract class RelationalAnnotationNames$instance {
    static readonly AllNames: ISet<System_Internal.String>;
    static readonly Prefix: string;
    static readonly ColumnName: string;
    static readonly ColumnOrder: string;
    static readonly ColumnType: string;
    static readonly DefaultValueSql: string;
    static readonly ComputedColumnSql: string;
    static readonly IsStored: string;
    static readonly DefaultValue: string;
    static readonly DefaultConstraintName: string;
    static readonly UseNamedDefaultConstraints: string;
    static readonly TableName: string;
    static readonly Schema: string;
    static readonly ViewName: string;
    static readonly ViewSchema: string;
    static readonly FunctionName: string;
    static readonly DeleteStoredProcedure: string;
    static readonly InsertStoredProcedure: string;
    static readonly UpdateStoredProcedure: string;
    static readonly SqlQuery: string;
    static readonly Comment: string;
    static readonly Collation: string;
    static readonly DefaultSchema: string;
    static readonly Name: string;
    static readonly SequencePrefix: string;
    static readonly Sequences: string;
    static readonly CheckConstraints: string;
    static readonly Filter: string;
    static readonly DbFunctions: string;
    static readonly MaxIdentifierLength: string;
    static readonly IsFixedLength: string;
    static readonly ViewDefinitionSql: string;
    static readonly IsTableExcludedFromMigrations: string;
    static readonly MappingStrategy: string;
    static readonly TpcMappingStrategy: string;
    static readonly TphMappingStrategy: string;
    static readonly TptMappingStrategy: string;
    static readonly RelationalModel: string;
    static readonly RelationalModelFactory: string;
    static readonly DefaultMappings: string;
    static readonly DefaultColumnMappings: string;
    static readonly TableMappings: string;
    static readonly TableColumnMappings: string;
    static readonly ViewMappings: string;
    static readonly ViewColumnMappings: string;
    static readonly FunctionMappings: string;
    static readonly FunctionColumnMappings: string;
    static readonly InsertStoredProcedureMappings: string;
    static readonly InsertStoredProcedureResultColumnMappings: string;
    static readonly InsertStoredProcedureParameterMappings: string;
    static readonly DeleteStoredProcedureMappings: string;
    static readonly DeleteStoredProcedureParameterMappings: string;
    static readonly UpdateStoredProcedureMappings: string;
    static readonly UpdateStoredProcedureResultColumnMappings: string;
    static readonly UpdateStoredProcedureParameterMappings: string;
    static readonly SqlQueryMappings: string;
    static readonly SqlQueryColumnMappings: string;
    static readonly ForeignKeyMappings: string;
    static readonly TableIndexMappings: string;
    static readonly UniqueConstraintMappings: string;
    static readonly MappingFragments: string;
    static readonly RelationalOverrides: string;
    static readonly ModelDependencies: string;
    static readonly FieldValueGetter: string;
    static readonly ContainerColumnName: string;
    static readonly ContainerColumnType: string;
    static readonly ContainerColumnTypeMapping: string;
    static readonly JsonPropertyName: string;
    static readonly StoreType: string;
}


export type RelationalAnnotationNames = RelationalAnnotationNames$instance;

