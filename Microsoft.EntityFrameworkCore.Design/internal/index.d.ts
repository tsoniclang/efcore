// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Design
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { QualifiedName } from "../../Microsoft.EntityFrameworkCore.Design.Internal/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { EntityFrameworkServicesBuilder, IAnnotatable, IAnnotation, ServiceCharacteristics, ServiceCollectionMap } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { ICheckConstraint, IComplexProperty, IComplexType, IEntityType, IEntityTypeMappingFragment, IForeignKey, IIndex, IKey, IModel, INavigation, IProperty, IRelationalPropertyOverrides, ISequence, ISkipNavigation, ITrigger } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IRelationalTypeMappingSource } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { DbContext } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { Dictionary, ICollection, IDictionary, IEnumerable, IReadOnlyDictionary, IReadOnlyList, ISet, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Attribute, Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DateTimeOffset, Decimal, Double, Enum, Func, Guid, IEquatable, Int16, Int32, Int64, IServiceProvider, Nullable, Object as ClrObject, SByte, Single, String as ClrString, TimeOnly, TimeSpan, Type, UInt16, UInt32, UInt64, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { BigInteger } from "@tsonic/dotnet/System.Numerics.js";
import type { MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { IServiceCollection } from "@tsonic/microsoft-extensions/Microsoft.Extensions.DependencyInjection.js";

export interface IAnnotationCodeGenerator$instance {
    filterIgnoredAnnotations(annotations: IEnumerable<IAnnotation>): IEnumerable<IAnnotation>;
    generateFluentApiCalls(annotatable: IAnnotatable, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(checkConstraint: ICheckConstraint, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(complexProperty: IComplexProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(complexType: IComplexType, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(entityType: IEntityType, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(fragment: IEntityTypeMappingFragment, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(foreignKey: IForeignKey, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(index: IIndex, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(key: IKey, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(model: IModel, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(navigation: INavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(property: IProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(overrides: IRelationalPropertyOverrides, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(sequence: ISequence, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(navigation: ISkipNavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(trigger: ITrigger, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    removeAnnotationsHandledByConventions(annotatable: IAnnotatable, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(checkConstraint: ICheckConstraint, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(complexProperty: IComplexProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(complexType: IComplexType, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(entityType: IEntityType, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(fragment: IEntityTypeMappingFragment, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(foreignKey: IForeignKey, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(index: IIndex, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(key: IKey, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(model: IModel, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(navigation: INavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(property: IProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(overrides: IRelationalPropertyOverrides, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(sequence: ISequence, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(navigation: ISkipNavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(trigger: ITrigger, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
}


export type IAnnotationCodeGenerator = IAnnotationCodeGenerator$instance;

export interface ICSharpHelper$instance {
    arguments(values: IEnumerable<unknown>): string;
    fragment(fragment: AttributeCodeFragment): string;
    fragment(fragment: IMethodCallCodeFragment, indent?: int): string;
    fragment(fragment: IMethodCallCodeFragment, instanceIdentifier: string, typeQualified: boolean): string;
    fragment(fragment: NestedClosureCodeFragment, indent?: int): string;
    fragment(fragment: PropertyAccessorCodeFragment): string;
    getRequiredUsings(type_: Type): IEnumerable<System_Internal.String>;
    identifier(name: string, scope?: ICollection<System_Internal.String>, capitalize?: Nullable<System_Internal.Boolean>): string;
    identifier<T>(name: string, value: T, scope: IDictionary<System_Internal.String, T>, capitalize?: Nullable<System_Internal.Boolean>): string;
    lambda(properties: IEnumerable<IProperty>, lambdaIdentifier?: string): string;
    lambda(properties: IReadOnlyList<System_Internal.String>, lambdaIdentifier?: string): string;
    literal<TKey, TValue>(values: Dictionary<TKey, TValue>, vertical?: boolean): string;
    literal<T>(values: List<T>, vertical?: boolean): string;
    literal<T extends unknown>(value: Nullable<T>): string;
    literal(value: boolean): string;
    literal(value: byte): string;
    literal(value: char): string;
    literal(value: DateOnly): string;
    literal(value: DateTime): string;
    literal(value: DateTimeOffset): string;
    literal(value: decimal): string;
    literal(value: double): string;
    literal(value: number, fullName?: boolean): string;
    literal(value: Guid): string;
    literal(value: short): string;
    literal(value: int): string;
    literal(value: long): string;
    literal(value: BigInteger): string;
    literal(values: Array<Array<unknown>>): string;
    literal(value: sbyte): string;
    literal(value: float): string;
    literal(value: string): string;
    literal(value: TimeOnly): string;
    literal(value: TimeSpan): string;
    literal(value: Type, fullName?: Nullable<System_Internal.Boolean>): string;
    literal(value: ushort): string;
    literal(value: uint): string;
    literal(value: ulong): string;
    literal<T>(values: T[], vertical?: boolean): string;
    namespace_(...name: string[]): string;
    statement(node: Expression, collectedNamespaces: ISet<System_Internal.String>, unsafeAccessors: ISet<System_Internal.String>, constantReplacements?: IReadOnlyDictionary<unknown, System_Internal.String>, memberAccessReplacements?: IReadOnlyDictionary<MemberInfo, QualifiedName>): string;
    unknownLiteral(value: unknown): string;
    xmlComment(comment: string, indent?: int): string;
}


export type ICSharpHelper = ICSharpHelper$instance;

export interface IDesignTimeDbContextFactory_1$instance<TContext extends DbContext> {
    createDbContext(args: string[]): TContext;
}


export type IDesignTimeDbContextFactory_1<TContext extends DbContext> = IDesignTimeDbContextFactory_1$instance<TContext>;

export interface IDesignTimeServices$instance {
    configureDesignTimeServices(serviceCollection: IServiceCollection): void;
}


export type IDesignTimeServices = IDesignTimeServices$instance;

export interface IMethodCallCodeFragment$instance {
    readonly declaringType: string;
    readonly method: string;
    readonly typeArguments: IEnumerable<System_Internal.String>;
    readonly arguments: IEnumerable<unknown | undefined>;
    readonly chainedCall: IMethodCallCodeFragment | undefined;
}


export type IMethodCallCodeFragment = IMethodCallCodeFragment$instance;

export interface AnnotationCodeGenerator$instance {
    filterIgnoredAnnotations(annotations: IEnumerable<IAnnotation>): IEnumerable<IAnnotation>;
    generateDataAnnotationAttributes(entityType: IEntityType, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<AttributeCodeFragment>;
    generateDataAnnotationAttributes(property: IProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<AttributeCodeFragment>;
    generateDataAnnotationAttributes(annotatable: IAnnotatable, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<AttributeCodeFragment>;
    generateFluentApiCalls(model: IModel, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(entityType: IEntityType, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(complexType: IComplexType, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(fragment: IEntityTypeMappingFragment, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(property: IProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(complexProperty: IComplexProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(key: IKey, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(foreignKey: IForeignKey, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(navigation: INavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(navigation: ISkipNavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(index: IIndex, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(checkConstraint: ICheckConstraint, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(trigger: ITrigger, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(overrides: IRelationalPropertyOverrides, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(sequence: ISequence, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    generateFluentApiCalls(annotatable: IAnnotatable, annotations: IDictionary<System_Internal.String, IAnnotation>): IReadOnlyList<MethodCallCodeFragment>;
    removeAnnotationsHandledByConventions(model: IModel, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(entityType: IEntityType, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(complexType: IComplexType, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(fragment: IEntityTypeMappingFragment, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(property: IProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(complexProperty: IComplexProperty, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(key: IKey, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(foreignKey: IForeignKey, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(navigation: INavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(navigation: ISkipNavigation, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(index: IIndex, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(checkConstraint: ICheckConstraint, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(trigger: ITrigger, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(overrides: IRelationalPropertyOverrides, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(sequence: ISequence, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
    removeAnnotationsHandledByConventions(annotatable: IAnnotatable, annotations: IDictionary<System_Internal.String, IAnnotation>): void;
}


export const AnnotationCodeGenerator: {
    new(dependencies: AnnotationCodeGeneratorDependencies): AnnotationCodeGenerator;
};


export interface __AnnotationCodeGenerator$views {
    As_IAnnotationCodeGenerator(): IAnnotationCodeGenerator$instance;
}

export type AnnotationCodeGenerator = AnnotationCodeGenerator$instance & __AnnotationCodeGenerator$views;


export interface AnnotationCodeGeneratorDependencies$instance {
    relationalTypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): AnnotationCodeGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: AnnotationCodeGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const AnnotationCodeGeneratorDependencies: {
    new(relationalTypeMappingSource: IRelationalTypeMappingSource): AnnotationCodeGeneratorDependencies;
};


export type AnnotationCodeGeneratorDependencies = AnnotationCodeGeneratorDependencies$instance;

export interface AttributeCodeFragment$instance {
    readonly arguments: IReadOnlyList<unknown | undefined>;
    readonly namedArguments: IReadOnlyDictionary<System_Internal.String, unknown | undefined>;
    readonly type_: Type;
}


export const AttributeCodeFragment: {
    new(type_: Type, arguments: unknown[]): AttributeCodeFragment;
    new(type_: Type, arguments: IEnumerable<unknown>, namedArguments: IDictionary<System_Internal.String, unknown>): AttributeCodeFragment;
};


export type AttributeCodeFragment = AttributeCodeFragment$instance;

export interface DesignTimeProviderServicesAttribute$instance extends Attribute {
    readonly typeName: string;
}


export const DesignTimeProviderServicesAttribute: {
    new(typeName: string): DesignTimeProviderServicesAttribute;
};


export type DesignTimeProviderServicesAttribute = DesignTimeProviderServicesAttribute$instance;

export interface DesignTimeServicesReferenceAttribute$instance extends Attribute {
    readonly forProvider: string | undefined;
    readonly typeName: string;
}


export const DesignTimeServicesReferenceAttribute: {
    new(typeName: string): DesignTimeServicesReferenceAttribute;
    new(typeName: string, forProvider: string): DesignTimeServicesReferenceAttribute;
};


export type DesignTimeServicesReferenceAttribute = DesignTimeServicesReferenceAttribute$instance;

export interface EntityFrameworkDesignServicesBuilder$instance extends EntityFrameworkServicesBuilder {
    tryAddCoreServices(): EntityFrameworkServicesBuilder;
}


export const EntityFrameworkDesignServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkDesignServicesBuilder;
    readonly services: IDictionary<Type, ServiceCharacteristics>;
};


export type EntityFrameworkDesignServicesBuilder = EntityFrameworkDesignServicesBuilder$instance;

export interface EntityFrameworkRelationalDesignServicesBuilder$instance extends EntityFrameworkDesignServicesBuilder {
    tryAddCoreServices(): EntityFrameworkServicesBuilder;
}


export const EntityFrameworkRelationalDesignServicesBuilder: {
    new(serviceCollection: IServiceCollection): EntityFrameworkRelationalDesignServicesBuilder;
    readonly relationalServices: IDictionary<Type, ServiceCharacteristics>;
};


export type EntityFrameworkRelationalDesignServicesBuilder = EntityFrameworkRelationalDesignServicesBuilder$instance;

export interface MethodCallCodeFragment$instance {
    readonly arguments: IReadOnlyList<unknown | undefined>;
    readonly chainedCall: MethodCallCodeFragment | undefined;
    readonly declaringType: string;
    readonly method: string;
    readonly methodInfo: MethodInfo | undefined;
    readonly namespace_: string;
    chain(methodInfo: MethodInfo, ...arguments: unknown[]): MethodCallCodeFragment;
    chain(method: string, ...arguments: unknown[]): MethodCallCodeFragment;
    chain(call: MethodCallCodeFragment): MethodCallCodeFragment;
}


export const MethodCallCodeFragment: {
    new(methodInfo: MethodInfo, arguments: unknown[]): MethodCallCodeFragment;
    new(method: string, arguments: unknown[]): MethodCallCodeFragment;
};


export interface __MethodCallCodeFragment$views {
    As_IMethodCallCodeFragment(): IMethodCallCodeFragment$instance;
}

export type MethodCallCodeFragment = MethodCallCodeFragment$instance & __MethodCallCodeFragment$views;


export interface NestedClosureCodeFragment$instance {
    readonly methodCalls: IReadOnlyList<MethodCallCodeFragment>;
    readonly parameter: string;
}


export const NestedClosureCodeFragment: {
    new(parameter: string, methodCall: MethodCallCodeFragment): NestedClosureCodeFragment;
    new(parameter: string, methodCalls: IReadOnlyList<MethodCallCodeFragment>): NestedClosureCodeFragment;
};


export type NestedClosureCodeFragment = NestedClosureCodeFragment$instance;

export interface PropertyAccessorCodeFragment$instance {
    readonly parameter: string;
    readonly properties: IReadOnlyList<System_Internal.String>;
}


export const PropertyAccessorCodeFragment: {
    new(parameter: string, properties: IReadOnlyList<System_Internal.String>): PropertyAccessorCodeFragment;
};


export type PropertyAccessorCodeFragment = PropertyAccessorCodeFragment$instance;

