// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.ChangeTracking.Internal
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Abstractions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as Microsoft_EntityFrameworkCore_ChangeTracking_Internal from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { CascadeTiming, ChangeTracker, DetectChangesEventArgs, DetectedChangesEventArgs, DetectedEntityChangesEventArgs, DetectEntityChangesEventArgs, EntityEntry, EntityEntryGraphNode_1, EntityStateChangedEventArgs, EntityStateChangingEventArgs, EntityTrackedEventArgs, EntityTrackingEventArgs, IDependentKeyValueFactory, IDependentKeyValueFactory_1, IEntityEntryGraphIterator, IPrincipalKeyValueFactory, IPrincipalKeyValueFactory_1, PropertyValues, ValueComparer, ValueComparer_1 } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IDiagnosticsLogger_1, IInterceptors, ILoggingOptions } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { DebugView, IConcurrencyDetector, ICoreSingletonOptions, ICurrentDbContext, IInfrastructure_1, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IDbSetSource, IEntityFinder, IEntityFinderFactory, IEntityFinderSource } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import type { IRuntimeComplexProperty, IRuntimeComplexType, IRuntimeEntityType, IRuntimeTypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import type { IComplexProperty, IEntityType, IForeignKey, IKey, IModel, INavigation, INavigationBase, IProperty, IPropertyBase, IReadOnlyProperty, ITypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IStructuralTypeMaterializerSource } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { IDatabase, IExecutionStrategy, ValueBuffer } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Update_Internal from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { IUpdateEntry } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { IValueGeneratorSelector } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import type { DbContext, DbLoggerCategory_ChangeTracking, DbLoggerCategory_Update, EntityState } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { HashSet, ICollection as ICollection__System_Collections_Generic, IComparer as IComparer__System_Collections_Generic, IDictionary, IEnumerable as IEnumerable__System_Collections_Generic, IEqualityComparer as IEqualityComparer__System_Collections_Generic, IList as IList__System_Collections_Generic, IReadOnlyCollection, IReadOnlyList, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IComparer, IEnumerable, IEqualityComparer, IList } from "@tsonic/dotnet/System.Collections.js";
import type { NotifyCollectionChangedEventArgs } from "@tsonic/dotnet/System.Collections.Specialized.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { BindingList, IBindingList, ICancelAddNew, IRaiseItemChangedEvents, ListSortDirection, PropertyChangedEventArgs, PropertyChangingEventArgs, PropertyDescriptor } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, EventHandler, Func, IEquatable, Int32, Nullable, Object as ClrObject, String as ClrString, Tuple, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { FieldInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface IChangeDetector$instance {
    CaptureEvents(): ValueTuple<EventHandler<DetectChangesEventArgs>, EventHandler<DetectedChangesEventArgs>, EventHandler<DetectEntityChangesEventArgs>, EventHandler<DetectedEntityChangesEventArgs>>;
    DetectChanges(entry: InternalComplexEntry): void;
    DetectChanges(entry: InternalEntityEntry): void;
    DetectChanges(stateManager: IStateManager): void;
    DetectComplexCollectionChanges(entry: InternalEntryBase, complexProperty: IComplexProperty): boolean;
    OnDetectedAllChanges(stateManager: IStateManager, changesFound: boolean): void;
    OnDetectedEntityChanges(internalEntityEntry: InternalEntityEntry, changesFound: boolean): void;
    PropertyChanged(entry: IInternalEntry, propertyBase: IPropertyBase, setModified: boolean): void;
    PropertyChanging(entry: IInternalEntry, propertyBase: IPropertyBase): void;
    ResetState(): void;
    SetEvents(detectingAllChanges: EventHandler<DetectChangesEventArgs>, detectedAllChanges: EventHandler<DetectedChangesEventArgs>, detectingEntityChanges: EventHandler<DetectEntityChangesEventArgs>, detectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs>): void;
}


export type IChangeDetector = IChangeDetector$instance;

export interface IChangeTrackerFactory$instance {
    Create(): ChangeTracker;
}


export type IChangeTrackerFactory = IChangeTrackerFactory$instance;

export interface IDependentsMap$instance {
    Add(entry: IUpdateEntry): void;
    GetDependents(principalEntry: IUpdateEntry): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependents(keyValues: IReadOnlyList<unknown>): IEnumerable__System_Collections_Generic<IUpdateEntry>;
}


export type IDependentsMap = IDependentsMap$instance;

export interface IEntityGraphAttacher$instance {
    AttachGraph(rootEntry: InternalEntityEntry, targetState: EntityState, storeGeneratedWithKeySetTargetState: EntityState, forceStateWhenUnknownKey: boolean): void;
    AttachGraphAsync(rootEntry: InternalEntityEntry, targetState: EntityState, storeGeneratedWithKeySetTargetState: EntityState, forceStateWhenUnknownKey: boolean, cancellationToken?: CancellationToken): Task;
}


export type IEntityGraphAttacher = IEntityGraphAttacher$instance;

export interface IIdentityMap$instance {
    readonly Key: IKey;
    Add(keyValues: IReadOnlyList<unknown>, entry: InternalEntityEntry): void;
    AddOrUpdate(entry: InternalEntityEntry): void;
    All(): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Clear(): void;
    GetDependentsMap(foreignKey: IForeignKey): IDependentsMap;
    TryGetEntry(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>, throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
}


export type IIdentityMap = IIdentityMap$instance;

export interface IIdentityMap_1$instance<TKey> extends IIdentityMap {
    readonly Key: IKey;
    Add(keyValues: IReadOnlyList<unknown>, entry: InternalEntityEntry): void;
    AddOrUpdate(entry: InternalEntityEntry): void;
    All(): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Clear(): void;
    GetDependentsMap(foreignKey: IForeignKey): IDependentsMap;
    TryGetEntry(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>, throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
    TryGetEntryTyped(keyValue: TKey): InternalEntityEntry | undefined;
}


export type IIdentityMap_1<TKey> = IIdentityMap_1$instance<TKey>;

export interface IInternalEntityEntryNotifier$instance {
    FixupResolved(entry: InternalEntityEntry, duplicateEntry: InternalEntityEntry): void;
    KeyPropertyChanged(entry: InternalEntityEntry, property: IProperty, keys: IEnumerable__System_Collections_Generic<IKey>, foreignKeys: IEnumerable__System_Collections_Generic<IForeignKey>, oldValue: unknown, newValue: unknown): void;
    NavigationCollectionChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, added: IEnumerable__System_Collections_Generic<unknown>, removed: IEnumerable__System_Collections_Generic<unknown>): void;
    NavigationReferenceChanged(entry: InternalEntityEntry, navigation: INavigation, oldValue: unknown, newValue: unknown): void;
    PropertyChanged(entry: IInternalEntry, property: IPropertyBase, setModified: boolean): void;
    PropertyChanging(entry: IInternalEntry, property: IPropertyBase): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
    TrackedFromQuery(entry: InternalEntityEntry): void;
}


export type IInternalEntityEntryNotifier = IInternalEntityEntryNotifier$instance;

export interface IInternalEntry$instance {
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly EntityState: EntityState;
    readonly Context: DbContext;
    readonly StructuralType: IRuntimeTypeBase;
    readonly EntityEntry: InternalEntityEntry;
    readonly ContainingEntry: IInternalEntry;
    readonly Entity: unknown;
    readonly HasConceptualNull: boolean;
    readonly StateManager: IStateManager;
    AcceptChanges(): void;
    FlaggedAsStoreGenerated(propertyIndex: int): boolean;
    GetComplexCollectionEntries(property: IComplexProperty): IReadOnlyList<InternalComplexEntry | undefined>;
    GetComplexCollectionEntry(property: IComplexProperty, ordinal: int): InternalComplexEntry;
    GetCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    GetCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetFlattenedComplexEntries(): IEnumerable__System_Collections_Generic<InternalComplexEntry>;
    GetOrdinals(): IReadOnlyList<System_Internal.Int32>;
    GetOriginalValue<TProperty>(property: IProperty): TProperty;
    HandleConceptualNulls(sensitiveLoggingEnabled: boolean, force: boolean, isCascadeDelete: boolean): void;
    HasExplicitValue(property: IProperty): boolean;
    IsModified(property: IComplexProperty): boolean;
    MarkAsTemporary(property: IProperty, temporary: boolean): void;
    MarkUnknown(property: IProperty): void;
    OnComplexElementStateChange(entry: InternalComplexEntry, oldState: EntityState, newState: EntityState): void;
    OnComplexPropertyModified(property: IComplexProperty, isModified?: boolean): void;
    PrepareToSave(): IInternalEntry;
    ReadOriginalValue<T>(property: IProperty, originalValueIndex: int): T;
    ReadStoreGeneratedValue<T>(storeGeneratedIndex: int): T;
    SetEntityState(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>): void;
    SetOriginalValue(propertyBase: IPropertyBase, value: unknown, index?: int): void;
    SetProperty(propertyBase: IPropertyBase, value: unknown, isMaterialization: boolean, setModified?: boolean, isCascadeDelete?: boolean): void;
    SetPropertyModified(property: IComplexProperty, isModified?: boolean, recurse?: boolean): void;
    SetPropertyModified(property: IProperty, changeState?: boolean, isModified?: boolean, isConceptualNull?: boolean, acceptChanges?: boolean): void;
    SetStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
}


export type IInternalEntry = IInternalEntry$instance;

export interface IInternalEntrySubscriber$instance {
    SnapshotAndSubscribe(entry: InternalComplexEntry): boolean;
    SnapshotAndSubscribe(entry: InternalEntityEntry): boolean;
    SubscribeCollectionChanged(entry: InternalEntityEntry, navigation: INavigationBase): void;
    SubscribeCollectionChanged(entry: InternalEntryBase, complexProperty: IComplexProperty): void;
    Unsubscribe(entry: InternalComplexEntry): void;
    Unsubscribe(entry: InternalEntityEntry): void;
}


export type IInternalEntrySubscriber = IInternalEntrySubscriber$instance;

export interface IKeyPropagator$instance {
    PropagateValue(entry: InternalEntityEntry, property: IProperty): InternalEntityEntry | undefined;
    PropagateValueAsync(entry: InternalEntityEntry, property: IProperty, cancellationToken?: CancellationToken): Task<InternalEntityEntry | undefined>;
}


export type IKeyPropagator = IKeyPropagator$instance;

export interface ILocalViewListener$instance {
    RegisterView(viewAction: Action<InternalEntityEntry, EntityState>): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
}


export type ILocalViewListener = ILocalViewListener$instance;

export interface INavigationFixer$instance {
    BeginDelayedFixup(): boolean;
    CompleteDelayedFixup(): void;
    FixupResolved(entry: InternalEntityEntry, duplicateEntry: InternalEntityEntry): void;
    KeyPropertyChanged(entry: InternalEntityEntry, property: IProperty, containingPrincipalKeys: IEnumerable__System_Collections_Generic<IKey>, containingForeignKeys: IEnumerable__System_Collections_Generic<IForeignKey>, oldValue: unknown, newValue: unknown): void;
    NavigationCollectionChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, added: IEnumerable__System_Collections_Generic<unknown>, removed: IEnumerable__System_Collections_Generic<unknown>): void;
    NavigationReferenceChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, oldValue: unknown, newValue: unknown): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
    TrackedFromQuery(entry: InternalEntityEntry): void;
}


export type INavigationFixer = INavigationFixer$instance;

export interface ISnapshot$instance {
    Item: unknown;
    readonly IsEmpty: boolean;
    GetValue<T>(index: int): T;
}


export type ISnapshot = ISnapshot$instance;

export interface IStateManager$instance extends IResettableService {
    readonly Dependencies: StateManagerDependencies;
    DeleteOrphansTiming: CascadeTiming;
    CascadeDeleteTiming: CascadeTiming;
    readonly SavingChanges: boolean;
    readonly Entries: IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    readonly Count: int;
    ChangedCount: int;
    readonly InternalEntityEntryNotifier: IInternalEntityEntryNotifier;
    readonly ValueGenerationManager: IValueGenerationManager;
    readonly Context: DbContext;
    readonly Model: IModel;
    readonly EntityMaterializerSource: IStructuralTypeMaterializerSource;
    readonly SensitiveLoggingEnabled: boolean;
    readonly UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    BeginAttachGraph(): void;
    CaptureEvents(): ValueTuple<EventHandler<EntityTrackingEventArgs>, EventHandler<EntityTrackedEventArgs>, EventHandler<EntityStateChangingEventArgs>, EventHandler<EntityStateChangedEventArgs>>;
    CascadeDelete(entry: InternalEntityEntry, force: boolean, foreignKeys?: IEnumerable__System_Collections_Generic<IForeignKey>): void;
    ChangingState(entry: InternalEntityEntry, newState: EntityState): void;
    CreateEntityFinder(entityType: IEntityType): IEntityFinder;
    CreateEntry(values: IDictionary<System_Internal.String, unknown>, entityType: IEntityType): InternalEntityEntry;
    FindPrincipal(dependentEntry: InternalEntityEntry, foreignKey: IForeignKey): InternalEntityEntry | undefined;
    GetCountForState(added?: boolean, modified?: boolean, deleted?: boolean, unchanged?: boolean, returnSharedIdentity?: boolean): int;
    GetDependents(keyValues: IReadOnlyList<unknown>, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependentsFromNavigation(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry> | undefined;
    GetEntries(key: IKey): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntriesForState(added?: boolean, modified?: boolean, deleted?: boolean, unchanged?: boolean, returnSharedIdentity?: boolean): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntriesToSave(cascadeChanges: boolean): IList__System_Collections_Generic<IUpdateEntry>;
    GetNonDeletedEntities<TEntity>(): IEnumerable__System_Collections_Generic<TEntity>;
    GetOrCreateEntry(entity: unknown, entityType: IEntityType): InternalEntityEntry;
    GetOrCreateEntry(entity: unknown): InternalEntityEntry;
    GetRecordedReferrers(referencedEntity: unknown, clear: boolean): IEnumerable__System_Collections_Generic<Tuple<INavigationBase, InternalEntityEntry>>;
    OnTracked(internalEntityEntry: InternalEntityEntry, fromQuery: boolean): void;
    OnTracking(internalEntityEntry: InternalEntityEntry, state: EntityState, fromQuery: boolean): void;
    RecordReferencedUntrackedEntity(referencedEntity: unknown, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
    ResolveToExistingEntry(newEntry: InternalEntityEntry, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): boolean;
    SaveChanges(acceptAllChangesOnSuccess: boolean): int;
    SaveChangesAsync(acceptAllChangesOnSuccess: boolean, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    SetEvents(tracking: EventHandler<EntityTrackingEventArgs>, tracked: EventHandler<EntityTrackedEventArgs>, stateChanging: EventHandler<EntityStateChangingEventArgs>, stateChanged: EventHandler<EntityStateChangedEventArgs>): void;
    StartTracking(entry: InternalComplexEntry): InternalComplexEntry;
    StartTracking(entry: InternalEntityEntry): InternalEntityEntry;
    StartTrackingFromQuery(baseEntityType: IEntityType, entity: unknown, snapshot: ISnapshot): InternalEntityEntry;
    StopTracking(entry: InternalComplexEntry, oldState: EntityState): void;
    TryGetEntry(key: IKey, keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
    TryGetEntry(key: IKey, keyValues: unknown[], throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(entity: unknown, type: IEntityType, throwOnTypeMismatch?: boolean): InternalEntityEntry | undefined;
    TryGetEntry(entity: unknown, throwOnNonUniqueness?: boolean): InternalEntityEntry | undefined;
    TryGetEntryTyped<TKey>(key: IKey, keyValue: TKey): InternalEntityEntry | undefined;
    TryGetExistingEntry(entity: unknown, key: IKey): InternalEntityEntry | undefined;
    Unsubscribe(resetting: boolean): void;
    UpdateDependentMap(entry: InternalEntityEntry, foreignKey: IForeignKey): void;
    UpdateIdentityMap(entry: InternalEntityEntry, principalKey: IKey): void;
    UpdateReferencedUntrackedEntity(referencedEntity: unknown, newReferencedEntity: unknown, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): void;
    ResetState(): void;
}


export interface IStateManager$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type IStateManager = IStateManager$instance;

export interface IValueGenerationManager$instance {
    Generate(entry: InternalEntityEntry, includePrimaryKey?: boolean): boolean;
    GenerateAsync(entry: InternalEntityEntry, includePrimaryKey?: boolean, cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    Propagate(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    PropagateAsync(entry: InternalEntityEntry, cancellationToken: CancellationToken): Task<InternalEntityEntry | undefined>;
}


export type IValueGenerationManager = IValueGenerationManager$instance;

export interface MultiSnapshot$instance {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const MultiSnapshot: {
    new(snapshots: ISnapshot[]): MultiSnapshot;
};


export interface __MultiSnapshot$views {
    As_ISnapshot(): ISnapshot$instance;
}

export interface MultiSnapshot$instance extends ISnapshot$instance {}

export type MultiSnapshot = MultiSnapshot$instance & __MultiSnapshot$views;


export interface ArrayPropertyValues$instance extends PropertyValues {
    Clone(): PropertyValues;
    get_Item(propertyName: string): unknown | undefined;
    get_Item(property: IProperty): unknown | undefined;
    get_Item(complexProperty: IComplexProperty): IList | undefined;
    GetValue<TValue>(propertyName: string): TValue;
    GetValue<TValue>(property: IProperty): TValue;
    set_Item(propertyName: string, value: unknown | undefined): void;
    set_Item(property: IProperty, value: unknown | undefined): void;
    set_Item(complexProperty: IComplexProperty, value: IList | undefined): void;
    SetValues(obj: unknown): void;
    SetValues(propertyValues: PropertyValues): void;
    SetValues<TProperty>(values: IDictionary<System_Internal.String, TProperty>): void;
    ToObject(): unknown;
}


export const ArrayPropertyValues: {
    new(internalEntry: InternalEntryBase, values: unknown[]): ArrayPropertyValues;
};


export type ArrayPropertyValues = ArrayPropertyValues$instance;

export interface ChangeDetector$instance {
    CaptureEvents(): ValueTuple<EventHandler<DetectChangesEventArgs>, EventHandler<DetectedChangesEventArgs>, EventHandler<DetectEntityChangesEventArgs>, EventHandler<DetectedEntityChangesEventArgs>>;
    DetectChanges(stateManager: IStateManager): void;
    DetectChanges(entry: InternalEntityEntry): void;
    DetectChanges(entry: InternalComplexEntry): void;
    DetectComplexCollectionChanges(entry: InternalEntryBase, complexProperty: IComplexProperty): boolean;
    DetectNavigationChange(entry: InternalEntityEntry, navigationBase: INavigationBase): boolean;
    DetectValueChange(entry: IInternalEntry, property: IProperty): boolean;
    OnDetectedAllChanges(stateManager: IStateManager, changesFound: boolean): void;
    OnDetectedEntityChanges(internalEntityEntry: InternalEntityEntry, changesFound: boolean): void;
    OnDetectingAllChanges(stateManager: IStateManager): void;
    OnDetectingEntityChanges(internalEntityEntry: InternalEntityEntry): void;
    PropertyChanged(entry: IInternalEntry, propertyBase: IPropertyBase, setModified: boolean): void;
    PropertyChanging(entry: IInternalEntry, propertyBase: IPropertyBase): void;
    ResetState(): void;
    SetEvents(detectingAllChanges: EventHandler<DetectChangesEventArgs>, detectedAllChanges: EventHandler<DetectedChangesEventArgs>, detectingEntityChanges: EventHandler<DetectEntityChangesEventArgs>, detectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs>): void;
}


export const ChangeDetector: {
    new(logger: IDiagnosticsLogger_1<DbLoggerCategory_ChangeTracking>, loggingOptions: ILoggingOptions): ChangeDetector;
};


export interface __ChangeDetector$views {
    As_IChangeDetector(): IChangeDetector$instance;
}

export type ChangeDetector = ChangeDetector$instance & __ChangeDetector$views;


export interface ChangeTrackerFactory$instance {
    Create(): ChangeTracker;
}


export const ChangeTrackerFactory: {
    new(currentContext: ICurrentDbContext, stateManager: IStateManager, changeDetector: IChangeDetector, model: IModel, graphIterator: IEntityEntryGraphIterator): ChangeTrackerFactory;
};


export interface __ChangeTrackerFactory$views {
    As_IChangeTrackerFactory(): IChangeTrackerFactory$instance;
}

export interface ChangeTrackerFactory$instance extends IChangeTrackerFactory$instance {}

export type ChangeTrackerFactory = ChangeTrackerFactory$instance & __ChangeTrackerFactory$views;


export interface CompositeDependentKeyValueFactory$instance extends CompositeValueFactory$instance {
    CreateDependentEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown | undefined;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: unknown): boolean;
}


export const CompositeDependentKeyValueFactory: {
    new(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<IReadOnlyList<unknown>>): CompositeDependentKeyValueFactory;
};


export interface __CompositeDependentKeyValueFactory$views {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<IReadOnlyList<unknown>>;
}

export type CompositeDependentKeyValueFactory = CompositeDependentKeyValueFactory$instance & __CompositeDependentKeyValueFactory$views;


export interface CompositePrincipalKeyValueFactory$instance extends CompositeValueFactory$instance {
    CreateEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    CreateFromBuffer(valueBuffer: ValueBuffer): unknown | undefined;
    CreateFromCurrentValues(entry: IUpdateEntry): IReadOnlyList<unknown | undefined>;
    CreateFromKeyValues(keyValues: IReadOnlyList<unknown>): unknown | undefined;
    CreateFromOriginalValues(entry: IUpdateEntry): IReadOnlyList<unknown | undefined>;
    CreateFromRelationshipSnapshot(entry: IUpdateEntry): IReadOnlyList<unknown | undefined>;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    FindNullPropertyInCurrentValues(entry: IUpdateEntry): IProperty;
    FindNullPropertyInKeyValues(keyValues: IReadOnlyList<unknown>): IProperty;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: unknown): boolean;
}


export const CompositePrincipalKeyValueFactory: {
    new(key: IKey): CompositePrincipalKeyValueFactory;
};


export interface __CompositePrincipalKeyValueFactory$views {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<IReadOnlyList<unknown>>;
    As_IPrincipalKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IPrincipalKeyValueFactory$instance;
    As_IPrincipalKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IPrincipalKeyValueFactory_1$instance<IReadOnlyList<unknown>>;
}

export type CompositePrincipalKeyValueFactory = CompositePrincipalKeyValueFactory$instance & __CompositePrincipalKeyValueFactory$views;


export abstract class CompositeValueFactory$protected {
    protected readonly Properties: IReadOnlyList<IProperty>;
    protected TryCreateFromEntry(entry: IUpdateEntry, getValue: Func<IUpdateEntry, IProperty, unknown>, key: IReadOnlyList<unknown>): boolean;
}


export interface CompositeValueFactory$instance extends CompositeValueFactory$protected {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<IReadOnlyList<unknown | undefined>>;
    CreateDependentEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown | undefined;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromBuffer(valueBuffer: ValueBuffer, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromPreStoreGeneratedCurrentValues(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
    TryCreateFromRelationshipSnapshot(entry: IUpdateEntry, key: IReadOnlyList<unknown>): boolean;
}


export const CompositeValueFactory: {
    new(properties: IReadOnlyList<IProperty>): CompositeValueFactory;
    CreateEqualityComparer(properties: IReadOnlyList<IProperty>): IEqualityComparer__System_Collections_Generic<IReadOnlyList<unknown | undefined>>;
};


export interface __CompositeValueFactory$views {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<IReadOnlyList<unknown>>;
}

export type CompositeValueFactory = CompositeValueFactory$instance & __CompositeValueFactory$views;


export interface ConvertingValueComparer_2$instance<TTo, TFrom> extends ValueComparer_1<TTo> {
}


export const ConvertingValueComparer_2: {
    new<TTo, TFrom>(valueComparer: ValueComparer_1<TFrom>): ConvertingValueComparer_2<TTo, TFrom>;
};


export interface __ConvertingValueComparer_2$views<TTo, TFrom> {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<ValueComparer>;
}

export interface ConvertingValueComparer_2$instance<TTo, TFrom> extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<ValueComparer> {}

export type ConvertingValueComparer_2<TTo, TFrom> = ConvertingValueComparer_2$instance<TTo, TFrom> & __ConvertingValueComparer_2$views<TTo, TFrom>;


export abstract class CurrentPropertyValues$protected {
    protected GetComplexCollectionEntry(entry: InternalEntryBase, complexProperty: IComplexProperty, i: int): InternalComplexEntry;
    protected GetValueInternal(entry: IInternalEntry, property: IPropertyBase): unknown | undefined;
    protected SetValueInternal(entry: IInternalEntry, property: IPropertyBase, value: unknown): void;
}


export interface CurrentPropertyValues$instance extends CurrentPropertyValues$protected, EntryPropertyValues {
    GetValue<TValue>(propertyName: string): TValue;
    GetValue<TValue>(property: IProperty): TValue;
}


export const CurrentPropertyValues: {
    new(internalEntry: InternalEntryBase): CurrentPropertyValues;
};


export type CurrentPropertyValues = CurrentPropertyValues$instance;

export interface CurrentProviderValueComparer_2$instance<TModel, TProvider> {
    Compare(x: IUpdateEntry, y: IUpdateEntry): int;
}


export const CurrentProviderValueComparer_2: {
    new<TModel, TProvider>(property: IProperty): CurrentProviderValueComparer_2<TModel, TProvider>;
};


export type CurrentProviderValueComparer_2<TModel, TProvider> = CurrentProviderValueComparer_2$instance<TModel, TProvider>;

export interface CurrentValueComparerFactory$instance {
    Create(property: IPropertyBase): IComparer__System_Collections_Generic<IUpdateEntry>;
    GetComparerType(propertyBase: IPropertyBase): Type;
}


export const CurrentValueComparerFactory: {
    new(): CurrentValueComparerFactory;
    readonly Instance: CurrentValueComparerFactory;
};


export type CurrentValueComparerFactory = CurrentValueComparerFactory$instance;

export interface DependentKeyValueFactory_1$instance<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreateDependentEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown | undefined;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: TKey): boolean;
}


export const DependentKeyValueFactory_1: {
    new<TKey>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): DependentKeyValueFactory_1<TKey>;
};


export type DependentKeyValueFactory_1<TKey> = DependentKeyValueFactory_1$instance<TKey>;

export interface DependentKeyValueFactoryFactory$instance {
    CreateComposite(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<IReadOnlyList<unknown>>): IDependentKeyValueFactory_1<IReadOnlyList<unknown | undefined>>;
    CreateSimpleNonNullable<TKey extends unknown>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): IDependentKeyValueFactory_1<TKey>;
    CreateSimpleNullable<TKey, TNonNullableKey extends unknown>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): IDependentKeyValueFactory_1<TKey>;
}


export const DependentKeyValueFactoryFactory: {
    new(): DependentKeyValueFactoryFactory;
};


export type DependentKeyValueFactoryFactory = DependentKeyValueFactoryFactory$instance;

export interface DependentsMap_1$instance<TKey> {
    Add(entry: IUpdateEntry): void;
    GetDependents(principalEntry: IUpdateEntry): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependents(keyValues: IReadOnlyList<unknown>): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependentsUsingRelationshipSnapshot(principalEntry: IUpdateEntry): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    Remove(entry: IUpdateEntry): void;
    Update(entry: IUpdateEntry): void;
}


export const DependentsMap_1: {
    new<TKey>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>, dependentKeyValueFactory: IDependentKeyValueFactory_1<TKey>): DependentsMap_1<TKey>;
};


export interface __DependentsMap_1$views<TKey> {
    As_IDependentsMap(): IDependentsMap$instance;
}

export type DependentsMap_1<TKey> = DependentsMap_1$instance<TKey> & __DependentsMap_1$views<TKey>;


export abstract class EmptyShadowValuesFactoryFactory$protected {
    protected readonly UseEntityVariable: boolean;
    protected CreateReadShadowValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected CreateReadValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected GetValueComparerMethod(): MethodInfo | undefined;
}


export interface EmptyShadowValuesFactoryFactory$instance extends EmptyShadowValuesFactoryFactory$protected, SnapshotFactoryFactory {
}


export const EmptyShadowValuesFactoryFactory: {
    new(): EmptyShadowValuesFactoryFactory;
    readonly Instance: EmptyShadowValuesFactoryFactory;
};


export type EmptyShadowValuesFactoryFactory = EmptyShadowValuesFactoryFactory$instance;

export interface EntityEntryGraphIterator$instance {
    TraverseGraph<TState>(node: EntityEntryGraphNode_1<TState>, handleNode: Func<EntityEntryGraphNode_1<TState>, System_Internal.Boolean>): void;
    TraverseGraphAsync<TState>(node: EntityEntryGraphNode_1<TState>, handleNode: Func<EntityEntryGraphNode_1<TState>, CancellationToken, Task<System_Internal.Boolean>>, cancellationToken?: CancellationToken): Task;
}


export const EntityEntryGraphIterator: {
    new(): EntityEntryGraphIterator;
};


export interface __EntityEntryGraphIterator$views {
    As_IEntityEntryGraphIterator(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IEntityEntryGraphIterator$instance;
}

export interface EntityEntryGraphIterator$instance extends Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IEntityEntryGraphIterator$instance {}

export type EntityEntryGraphIterator = EntityEntryGraphIterator$instance & __EntityEntryGraphIterator$views;


export interface EntityGraphAttacher$instance {
    AttachGraph(rootEntry: InternalEntityEntry, targetState: EntityState, storeGeneratedWithKeySetTargetState: EntityState, forceStateWhenUnknownKey: boolean): void;
    AttachGraphAsync(rootEntry: InternalEntityEntry, targetState: EntityState, storeGeneratedWithKeySetTargetState: EntityState, forceStateWhenUnknownKey: boolean, cancellationToken?: CancellationToken): Task;
}


export const EntityGraphAttacher: {
    new(graphIterator: IEntityEntryGraphIterator): EntityGraphAttacher;
};


export interface __EntityGraphAttacher$views {
    As_IEntityGraphAttacher(): IEntityGraphAttacher$instance;
}

export interface EntityGraphAttacher$instance extends IEntityGraphAttacher$instance {}

export type EntityGraphAttacher = EntityGraphAttacher$instance & __EntityGraphAttacher$views;


export interface EntityReferenceMap$instance {
    Clear(): void;
    GetCountForState(added: boolean, modified: boolean, deleted: boolean, unchanged: boolean, countDeletedSharedIdentity: boolean): int;
    GetEntriesForState(added: boolean, modified: boolean, deleted: boolean, unchanged: boolean, returnDeletedSharedIdentity: boolean): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetNonDeletedEntities<TEntity>(): IEnumerable__System_Collections_Generic<TEntity>;
    TryGet(entity: unknown, entityType: IEntityType, entry: InternalEntityEntry, throwOnNonUniqueness: boolean): boolean;
    Update(entry: InternalEntityEntry, state: EntityState, oldState: Nullable<EntityState>): void;
}


export const EntityReferenceMap: {
    new(hasSubMap: boolean): EntityReferenceMap;
};


export type EntityReferenceMap = EntityReferenceMap$instance;

export abstract class EntryCurrentProviderValueComparer$protected {
    protected GetPropertyValue(entry: IUpdateEntry): unknown | undefined;
}


export interface EntryCurrentProviderValueComparer$instance extends EntryCurrentProviderValueComparer$protected, EntryCurrentValueComparer {
}


export const EntryCurrentProviderValueComparer: {
    new(property: IProperty): EntryCurrentProviderValueComparer;
};


export type EntryCurrentProviderValueComparer = EntryCurrentProviderValueComparer$instance;

export abstract class EntryCurrentValueComparer$protected {
    protected ComparePropertyValues(x: unknown, y: unknown): int;
    protected GetPropertyValue(entry: IUpdateEntry): unknown | undefined;
}


export interface EntryCurrentValueComparer$instance extends EntryCurrentValueComparer$protected {
    Compare(x: IUpdateEntry, y: IUpdateEntry): int;
    Equals(x: IUpdateEntry, y: IUpdateEntry): boolean;
    GetHashCode(obj: IUpdateEntry): int;
}


export const EntryCurrentValueComparer: {
    new(property: IProperty): EntryCurrentValueComparer;
    new(property: IProperty, underlyingComparer: IComparer): EntryCurrentValueComparer;
};


export type EntryCurrentValueComparer = EntryCurrentValueComparer$instance;

export abstract class EntryPropertyValues$protected {
    protected abstract GetComplexCollectionEntry(entry: InternalEntryBase, complexProperty: IComplexProperty, i: int): InternalComplexEntry;
    protected abstract GetValueInternal(entry: IInternalEntry, property: IPropertyBase): unknown | undefined;
    protected abstract SetValueInternal(entry: IInternalEntry, property: IPropertyBase, value: unknown): void;
}


export interface EntryPropertyValues$instance extends EntryPropertyValues$protected, PropertyValues {
    Clone(): PropertyValues;
    get_Item(propertyName: string): unknown | undefined;
    get_Item(property: IProperty): unknown | undefined;
    get_Item(complexProperty: IComplexProperty): IList | undefined;
    set_Item(propertyName: string, value: unknown | undefined): void;
    set_Item(property: IProperty, value: unknown | undefined): void;
    set_Item(complexProperty: IComplexProperty, value: IList | undefined): void;
    SetValues(obj: unknown): void;
    SetValues(propertyValues: PropertyValues): void;
    SetValues<TProperty>(values: IDictionary<System_Internal.String, TProperty>): void;
    SetValues<TProperty>(values: IDictionary<System_Internal.String, TProperty>): void;
    ToObject(): unknown;
}


export const EntryPropertyValues: {
    new(internalEntry: InternalEntryBase): EntryPropertyValues;
};


export type EntryPropertyValues = EntryPropertyValues$instance;

export abstract class IdentityMap_1$protected<TKey> {
    protected readonly PrincipalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>;
    protected Add(key: TKey, entry: InternalEntityEntry): void;
    protected Remove(key: TKey, entry: InternalEntityEntry): void;
}


export interface IdentityMap_1$instance<TKey> extends IdentityMap_1$protected<TKey> {
    readonly Key: IKey;
    Add(entry: InternalEntityEntry): void;
    Add(keyValues: IReadOnlyList<unknown>, entry: InternalEntityEntry): void;
    AddOrUpdate(entry: InternalEntityEntry): void;
    All(): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Clear(): void;
    FindDependentsMap(foreignKey: IForeignKey): IDependentsMap | undefined;
    GetDependentsMap(foreignKey: IForeignKey): IDependentsMap;
    Remove(entry: InternalEntityEntry): void;
    RemoveUsingRelationshipSnapshot(entry: InternalEntityEntry): void;
    TryGetEntry(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>, throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntryTyped(keyValue: TKey): InternalEntityEntry | undefined;
    TryGetEntryUsingPreStoreGeneratedValues(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntryUsingRelationshipSnapshot(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
}


export const IdentityMap_1: {
    new<TKey>(key: IKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>, sensitiveLoggingEnabled: boolean): IdentityMap_1<TKey>;
};


export interface __IdentityMap_1$views<TKey> {
    As_IIdentityMap(): IIdentityMap$instance;
    As_IIdentityMap_1(): IIdentityMap_1$instance<TKey>;
}

export type IdentityMap_1<TKey> = IdentityMap_1$instance<TKey> & __IdentityMap_1$views<TKey>;


export interface IdentityMapFactoryFactory$instance {
}


export const IdentityMapFactoryFactory: {
    new(): IdentityMapFactoryFactory;
    Create(key: IKey): Func<System_Internal.Boolean, IIdentityMap>;
    CreateFactory<TKey>(key: IKey): Func<System_Internal.Boolean, IIdentityMap>;
};


export type IdentityMapFactoryFactory = IdentityMapFactoryFactory$instance;

export abstract class InternalComplexEntry$protected {
    protected OnStateChanged(oldState: EntityState): void;
    protected OnStateChanging(newState: EntityState): void;
    protected SetEntityState2(oldState: EntityState, newState: EntityState, acceptChanges: boolean, modifyProperties: boolean): void;
}


export interface InternalComplexEntry$instance extends InternalComplexEntry$protected, InternalEntryBase$instance {
    readonly ComplexProperty: IComplexProperty;
    readonly ComplexType: IRuntimeComplexType;
    readonly ContainingEntry: InternalEntryBase;
    readonly DebugView: DebugView;
    readonly EntityEntry: InternalEntityEntry;
    Ordinal: int;
    OriginalOrdinal: int;
    readonly StateManager: IStateManager;
    AcceptChanges(): void;
    DiscardStoreGeneratedValues(): void;
    FlaggedAsStoreGenerated(propertyIndex: int): boolean;
    GetComplexCollectionEntries(property: IComplexProperty): IReadOnlyList<InternalComplexEntry | undefined>;
    GetComplexCollectionEntry(property: IComplexProperty, ordinal: int): InternalComplexEntry;
    GetCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    GetFlattenedComplexEntries(): IEnumerable__System_Collections_Generic<InternalComplexEntry>;
    GetOrdinals(): IReadOnlyList<System_Internal.Int32>;
    GetOrdinals(): IReadOnlyList<System_Internal.Int32>;
    GetOriginalValue(propertyBase: IPropertyBase): unknown | undefined;
    GetOriginalValue<TProperty>(property: IProperty): TProperty;
    GetPropertyPath(property: IReadOnlyProperty): string;
    GetPropertyPath(withElement?: boolean): string;
    HandleConceptualNulls(sensitiveLoggingEnabled: boolean, force: boolean, isCascadeDelete: boolean): void;
    HasExplicitValue(property: IProperty): boolean;
    IsModified(property: IProperty): boolean;
    IsModified(property: IComplexProperty): boolean;
    MarkAsTemporary(property: IProperty, temporary: boolean): void;
    MarkUnknown(property: IProperty): void;
    OnComplexElementStateChange(entry: InternalComplexEntry, oldState: EntityState, newState: EntityState): void;
    OnComplexPropertyModified(property: IComplexProperty, isModified?: boolean): void;
    PrepareToSave(): IInternalEntry;
    ReadOriginalValue<T>(property: IProperty, originalValueIndex: int): T;
    ReadPropertyValue(propertyBase: IPropertyBase): unknown | undefined;
    ReadStoreGeneratedValue<T>(storeGeneratedIndex: int): T;
    SetEntityState(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>): void;
    SetOriginalValue(propertyBase: IPropertyBase, value: unknown, index?: int): void;
    SetProperty(propertyBase: IPropertyBase, value: unknown, isMaterialization: boolean, setModified?: boolean, isCascadeDelete?: boolean): void;
    SetPropertyModified(property: IProperty, changeState?: boolean, isModified?: boolean, isConceptualNull?: boolean, acceptChanges?: boolean): void;
    SetPropertyModified(property: IComplexProperty, isModified?: boolean, recurse?: boolean): void;
    SetStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
    ToString(): string;
}


export const InternalComplexEntry: {
    new(complexType: IRuntimeComplexType, containingEntry: InternalEntryBase, ordinal: int): InternalComplexEntry;
};


export interface __InternalComplexEntry$views {
    As_IInternalEntry(): IInternalEntry$instance;
}

export type InternalComplexEntry = InternalComplexEntry$instance & __InternalComplexEntry$views;


export abstract class InternalEntityEntry$protected {
    protected OnPropertyChanged(propertyBase: IPropertyBase, value: unknown, setModified: boolean): void;
    protected OnStateChanged(oldState: EntityState): void;
    protected OnStateChanging(newState: EntityState): void;
    protected SetEntityState2(oldState: EntityState, newState: EntityState, acceptChanges: boolean, modifyProperties: boolean): void;
    protected SetServiceProperties(oldState: EntityState, newState: EntityState): void;
}


export interface InternalEntityEntry$instance extends InternalEntityEntry$protected, InternalEntryBase$instance {
    readonly DebugView: DebugView;
    readonly Entity: unknown;
    readonly EntityType: IRuntimeEntityType;
    readonly HasRelationshipSnapshot: boolean;
    readonly IsKeySet: ValueTuple<System_Internal.Boolean, System_Internal.Boolean>;
    readonly IsKeyUnknown: boolean;
    get SharedIdentityEntry(): InternalEntityEntry | undefined;
    set SharedIdentityEntry(value: InternalEntityEntry);
    readonly StateManager: IStateManager;
    AcceptChanges(): void;
    AddRangeToCollectionSnapshot(navigation: INavigationBase, addedEntities: IEnumerable__System_Collections_Generic<unknown>): void;
    AddToCollection(navigationBase: INavigationBase, value: unknown, forMaterialization: boolean): boolean;
    AddToCollectionSnapshot(navigation: INavigationBase, addedEntity: unknown): void;
    CanHaveOriginalValue(propertyBase: IPropertyBase): boolean;
    CollectionContains(navigationBase: INavigationBase, value: unknown): boolean;
    DiscardStoreGeneratedValues(): void;
    EnsureRelationshipSnapshot(): void;
    FlaggedAsStoreGenerated(propertyIndex: int): boolean;
    GetComplexCollectionEntries(property: IComplexProperty): IReadOnlyList<InternalComplexEntry | undefined>;
    GetComplexCollectionEntry(property: IComplexProperty, ordinal: int): InternalComplexEntry;
    GetCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    GetFlattenedComplexEntries(): IEnumerable__System_Collections_Generic<InternalComplexEntry>;
    GetOrCreateCollection(navigationBase: INavigationBase, forMaterialization: boolean): unknown;
    GetOrdinals(): IReadOnlyList<System_Internal.Int32>;
    GetOriginalValue<TProperty>(property: IProperty): TProperty;
    GetOriginalValue(propertyBase: IPropertyBase): unknown | undefined;
    GetRelationshipSnapshotValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetRelationshipSnapshotValue(propertyBase: IPropertyBase): unknown | undefined;
    HandleConceptualNulls(sensitiveLoggingEnabled: boolean, force: boolean, isCascadeDelete: boolean): void;
    HandleINotifyCollectionChanged(sender: unknown, eventArgs: NotifyCollectionChangedEventArgs): void;
    HandleINotifyPropertyChanged(sender: unknown, eventArgs: PropertyChangedEventArgs): void;
    HandleINotifyPropertyChanging(sender: unknown, eventArgs: PropertyChangingEventArgs): void;
    HasExplicitValue(property: IProperty): boolean;
    IsLoaded(navigation: INavigationBase): boolean;
    IsModified(property: IProperty): boolean;
    IsModified(property: IComplexProperty): boolean;
    MarkAsTemporary(property: IProperty, temporary: boolean): void;
    MarkUnchangedFromQuery(): void;
    MarkUnknown(property: IProperty): void;
    OnComplexElementStateChange(entry: InternalComplexEntry, oldState: EntityState, newState: EntityState): void;
    OnComplexPropertyModified(property: IComplexProperty, isModified?: boolean): void;
    PrepareToSave(): IInternalEntry;
    PropagateValue(principalEntry: InternalEntityEntry, principalProperty: IProperty, dependentProperty: IProperty, isMaterialization?: boolean, setModified?: boolean): void;
    ReadOriginalValue<T>(property: IProperty, originalValueIndex: int): T;
    ReadRelationshipSnapshotValue<T>(propertyBase: IPropertyBase, relationshipSnapshotIndex: int): T;
    ReadStoreGeneratedValue<T>(storeGeneratedIndex: int): T;
    RemoveFromCollection(navigationBase: INavigationBase, value: unknown): boolean;
    RemoveFromCollectionSnapshot(navigation: INavigationBase, removedEntity: unknown): void;
    SetEntityState(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>): void;
    SetEntityState(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>): void;
    SetEntityStateAsync(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>, cancellationToken?: CancellationToken): Task;
    SetEntityStateAsync(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>, cancellationToken?: CancellationToken): Task;
    SetIsLoaded(navigation: INavigationBase, loaded?: boolean): void;
    SetOriginalValue(propertyBase: IPropertyBase, value: unknown, index?: int): void;
    SetProperty(propertyBase: IPropertyBase, value: unknown, isMaterialization: boolean, setModified?: boolean, isCascadeDelete?: boolean): void;
    SetPropertyModified(property: IProperty, changeState?: boolean, isModified?: boolean, isConceptualNull?: boolean, acceptChanges?: boolean): void;
    SetPropertyModified(property: IComplexProperty, isModified?: boolean, recurse?: boolean): void;
    SetRelationshipSnapshotValue(propertyBase: IPropertyBase, value: unknown): void;
    SetStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
    ToEntityEntry(): EntityEntry;
    ToString(): string;
}


export const InternalEntityEntry: {
    new(stateManager: IStateManager, entityType: IEntityType, entity: unknown): InternalEntityEntry;
    new(stateManager: IStateManager, entityType: IEntityType, entity: unknown, shadowValues: ISnapshot): InternalEntityEntry;
    new(stateManager: IStateManager, entityType: IEntityType, values: IDictionary<System_Internal.String, unknown>, entityMaterializerSource: IStructuralTypeMaterializerSource): InternalEntityEntry;
};


export interface __InternalEntityEntry$views {
    As_IInternalEntry(): IInternalEntry$instance;
    As_IUpdateEntry(): Microsoft_EntityFrameworkCore_Update_Internal.IUpdateEntry$instance;
}

export type InternalEntityEntry = InternalEntityEntry$instance & __InternalEntityEntry$views;


export interface InternalEntityEntryNotifier$instance {
    FixupResolved(entry: InternalEntityEntry, duplicateEntry: InternalEntityEntry): void;
    KeyPropertyChanged(entry: InternalEntityEntry, property: IProperty, keys: IEnumerable__System_Collections_Generic<IKey>, foreignKeys: IEnumerable__System_Collections_Generic<IForeignKey>, oldValue: unknown, newValue: unknown): void;
    NavigationCollectionChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, added: IEnumerable__System_Collections_Generic<unknown>, removed: IEnumerable__System_Collections_Generic<unknown>): void;
    NavigationReferenceChanged(entry: InternalEntityEntry, navigation: INavigation, oldValue: unknown, newValue: unknown): void;
    PropertyChanged(entry: IInternalEntry, property: IPropertyBase, setModified: boolean): void;
    PropertyChanging(entry: IInternalEntry, property: IPropertyBase): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
    TrackedFromQuery(entry: InternalEntityEntry): void;
}


export const InternalEntityEntryNotifier: {
    new(localViewListener: ILocalViewListener, changeDetector: IChangeDetector, navigationFixer: INavigationFixer): InternalEntityEntryNotifier;
};


export type InternalEntityEntryNotifier = InternalEntityEntryNotifier$instance;

export abstract class InternalEntryBase$protected {
    protected readonly PropertyStateData: InternalEntryBase_StateData;
    protected GetOrCreateShadowCollection(navigation: INavigationBase): unknown;
    protected GetValueType(property: IProperty): InternalEntryBase_CurrentValueType;
    protected OnPropertyChanged(propertyBase: IPropertyBase, value: unknown, setModified: boolean): void;
    protected OnStateChanged(oldState: EntityState): void;
    protected OnStateChanging(newState: EntityState): void;
    protected PrepareForAdd(newState: EntityState): boolean;
    protected SetEntityState(oldState: EntityState, newState: EntityState, acceptChanges: boolean, modifyProperties: boolean): void;
    protected SetServiceProperties(oldState: EntityState, newState: EntityState): void;
}


export interface InternalEntryBase$instance extends InternalEntryBase$protected {
    readonly ContainingEntry: InternalEntryBase;
    readonly Context: DbContext;
    readonly EntityEntry: InternalEntityEntry;
    EntityState: EntityState;
    readonly HasConceptualNull: boolean;
    readonly HasOriginalValuesSnapshot: boolean;
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly StateManager: IStateManager;
    readonly StructuralType: IRuntimeTypeBase;
    AcceptChanges(): void;
    CanHaveOriginalValue(propertyBase: IPropertyBase): boolean;
    DiscardStoreGeneratedValues(): void;
    EnsureComplexCollectionEntriesCapacity(property: IComplexProperty, capacity: int, originalCapacity: int, trim?: boolean): void;
    EnsureOriginalValues(): void;
    EnsureStoreGeneratedValues(): void;
    EnsureTemporaryValues(): void;
    FlaggedAsStoreGenerated(propertyIndex: int): boolean;
    FlaggedAsTemporary(propertyIndex: int): boolean;
    GetComplexCollectionEntries(property: IComplexProperty): IReadOnlyList<InternalComplexEntry | undefined>;
    GetComplexCollectionEntry(property: IComplexProperty, ordinal: int): InternalComplexEntry;
    GetComplexCollectionOriginalEntries(property: IComplexProperty): IReadOnlyList<InternalComplexEntry | undefined>;
    GetComplexCollectionOriginalEntry(property: IComplexProperty, ordinal: int): InternalComplexEntry;
    GetCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    GetFlattenedComplexEntries(): IEnumerable__System_Collections_Generic<InternalComplexEntry>;
    GetOrdinals(): IReadOnlyList<System_Internal.Int32>;
    GetOriginalValue<TProperty>(property: IProperty): TProperty;
    GetOriginalValue(propertyBase: IPropertyBase): unknown | undefined;
    GetPreStoreGeneratedCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    HandleConceptualNulls(sensitiveLoggingEnabled: boolean, force: boolean, isCascadeDelete: boolean): void;
    HandleNullForeignKey(property: IProperty, setModified?: boolean, isCascadeDelete?: boolean): void;
    HasExplicitValue(property: IProperty): boolean;
    HasStoreGeneratedValue(property: IProperty): boolean;
    HasTemporaryValue(property: IProperty): boolean;
    IsConceptualNull(property: IProperty): boolean;
    IsModified(property: IProperty): boolean;
    IsModified(property: IComplexProperty): boolean;
    IsStoreGenerated(property: IProperty): boolean;
    IsUnknown(property: IProperty): boolean;
    MarkAsTemporary(property: IProperty, temporary: boolean): void;
    MarkUnchangedFromQuery(): void;
    MarkUnknown(property: IProperty): void;
    MoveComplexCollectionEntry(property: IComplexProperty, fromOrdinal: int, toOrdinal: int, original?: boolean): void;
    OnComplexElementStateChange(entry: InternalComplexEntry, oldState: EntityState, newState: EntityState): void;
    OnComplexPropertyModified(property: IComplexProperty, isModified?: boolean): void;
    PrepareToSave(): IInternalEntry;
    ReadOriginalValue<T>(property: IProperty, originalValueIndex: int): T;
    ReadPropertyValue(propertyBase: IPropertyBase): unknown | undefined;
    ReadShadowValue<T>(shadowIndex: int): T;
    ReadStoreGeneratedValue<T>(storeGeneratedIndex: int): T;
    ReadTemporaryValue<T>(storeGeneratedIndex: int): T;
    SetEntityState(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>): void;
    SetEntityStateAsync(entityState: EntityState, acceptChanges?: boolean, modifyProperties?: boolean, forceStateWhenUnknownKey?: Nullable<EntityState>, fallbackState?: Nullable<EntityState>, cancellationToken?: CancellationToken): Task;
    SetOriginalValue(propertyBase: IPropertyBase, value: unknown, index?: int): void;
    SetProperty(propertyBase: IPropertyBase, value: unknown, isMaterialization: boolean, setModified?: boolean, isCascadeDelete?: boolean): void;
    SetPropertyModified(property: IProperty, changeState?: boolean, isModified?: boolean, isConceptualNull?: boolean, acceptChanges?: boolean): void;
    SetPropertyModified(property: IComplexProperty, isModified?: boolean, recurse?: boolean): void;
    SetStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
    SetTemporaryValue(property: IProperty, value: unknown, setModified?: boolean): void;
    ValidateOrdinal(entry: InternalComplexEntry, original: boolean): int;
}


export const InternalEntryBase: {
    new(structuralType: IRuntimeTypeBase): InternalEntryBase;
    new(structuralType: IRuntimeTypeBase, shadowValues: ISnapshot): InternalEntryBase;
    new(structuralType: IRuntimeTypeBase, shadowValues: IDictionary<System_Internal.String, unknown>): InternalEntryBase;
    readonly FlaggedAsTemporaryMethod: MethodInfo;
    readonly FlaggedAsStoreGeneratedMethod: MethodInfo;
};


export interface __InternalEntryBase$views {
    As_IInternalEntry(): IInternalEntry$instance;
}

export type InternalEntryBase = InternalEntryBase$instance & __InternalEntryBase$views;


export interface InternalEntrySubscriber$instance {
    SnapshotAndSubscribe(entry: InternalEntityEntry): boolean;
    SnapshotAndSubscribe(entry: InternalComplexEntry): boolean;
    SubscribeCollectionChanged(entry: InternalEntityEntry, navigation: INavigationBase): void;
    SubscribeCollectionChanged(entry: InternalEntryBase, complexProperty: IComplexProperty): void;
    Unsubscribe(entry: InternalEntityEntry): void;
    Unsubscribe(entry: InternalComplexEntry): void;
    UnsubscribeCollectionChanged(entry: InternalEntityEntry, navigation: INavigationBase): void;
    UnsubscribeCollectionChanged(entry: InternalEntryBase, complexProperty: IComplexProperty): void;
}


export const InternalEntrySubscriber: {
    new(): InternalEntrySubscriber;
};


export type InternalEntrySubscriber = InternalEntrySubscriber$instance;

export interface KeyPropagator$instance {
    PropagateValue(entry: InternalEntityEntry, property: IProperty): InternalEntityEntry | undefined;
    PropagateValueAsync(entry: InternalEntityEntry, property: IProperty, cancellationToken?: CancellationToken): Task<InternalEntityEntry | undefined>;
}


export const KeyPropagator: {
    new(valueGeneratorSelector: IValueGeneratorSelector): KeyPropagator;
};


export interface __KeyPropagator$views {
    As_IKeyPropagator(): IKeyPropagator$instance;
}

export interface KeyPropagator$instance extends IKeyPropagator$instance {}

export type KeyPropagator = KeyPropagator$instance & __KeyPropagator$views;


export interface KeyValueFactoryFactory$instance {
}


export const KeyValueFactoryFactory: {
    new(): KeyValueFactoryFactory;
    Create(key: IKey): IPrincipalKeyValueFactory;
    CreateCompositeFactory(key: IKey): CompositePrincipalKeyValueFactory;
    CreateSimpleNonNullableFactory<TKey extends unknown>(key: IKey): SimplePrincipalKeyValueFactory_1<TKey>;
    CreateSimpleNullableFactory<TKey, TNonNullableKey extends unknown>(key: IKey): SimplePrincipalKeyValueFactory_1<TKey>;
};


export type KeyValueFactoryFactory = KeyValueFactoryFactory$instance;

export interface LocalViewListener$instance {
    RegisterView(viewAction: Action<InternalEntityEntry, EntityState>): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
}


export const LocalViewListener: {
    new(): LocalViewListener;
};


export interface __LocalViewListener$views {
    As_ILocalViewListener(): ILocalViewListener$instance;
}

export interface LocalViewListener$instance extends ILocalViewListener$instance {}

export type LocalViewListener = LocalViewListener$instance & __LocalViewListener$views;


export interface NavigationFixer$instance {
    AbortDelayedFixup(): void;
    BeginDelayedFixup(): boolean;
    CompleteDelayedFixup(): void;
    FixupResolved(entry: InternalEntityEntry, duplicateEntry: InternalEntityEntry): void;
    KeyPropertyChanged(entry: InternalEntityEntry, property: IProperty, containingPrincipalKeys: IEnumerable__System_Collections_Generic<IKey>, containingForeignKeys: IEnumerable__System_Collections_Generic<IForeignKey>, oldValue: unknown, newValue: unknown): void;
    NavigationCollectionChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, added: IEnumerable__System_Collections_Generic<unknown>, removed: IEnumerable__System_Collections_Generic<unknown>): void;
    NavigationReferenceChanged(entry: InternalEntityEntry, navigationBase: INavigationBase, oldValue: unknown, newValue: unknown): void;
    StateChanged(entry: InternalEntityEntry, oldState: EntityState, fromQuery: boolean): void;
    StateChanging(entry: InternalEntityEntry, newState: EntityState): void;
    TrackedFromQuery(entry: InternalEntityEntry): void;
}


export const NavigationFixer: {
    new(attacher: IEntityGraphAttacher, entityMaterializerSource: IStructuralTypeMaterializerSource): NavigationFixer;
};


export interface __NavigationFixer$views {
    As_INavigationFixer(): INavigationFixer$instance;
}

export interface NavigationFixer$instance extends INavigationFixer$instance {}

export type NavigationFixer = NavigationFixer$instance & __NavigationFixer$views;


export interface NullableClassCurrentProviderValueComparer_2$instance<TModel, TProvider> {
    Compare(x: IUpdateEntry, y: IUpdateEntry): int;
}


export const NullableClassCurrentProviderValueComparer_2: {
    new<TModel, TProvider>(property: IProperty): NullableClassCurrentProviderValueComparer_2<TModel, TProvider>;
};


export type NullableClassCurrentProviderValueComparer_2<TModel, TProvider> = NullableClassCurrentProviderValueComparer_2$instance<TModel, TProvider>;

export abstract class NullableKeyIdentityMap_1$protected<TKey> {
    protected Add2(key: TKey, entry: InternalEntityEntry): void;
}


export interface NullableKeyIdentityMap_1$instance<TKey> extends NullableKeyIdentityMap_1$protected<TKey>, IdentityMap_1$instance<TKey> {
    Add(entry: InternalEntityEntry): void;
    Add(keyValues: IReadOnlyList<unknown>, entry: InternalEntityEntry): void;
    AddOrUpdate(entry: InternalEntityEntry): void;
    All(): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Clear(): void;
    GetDependentsMap(foreignKey: IForeignKey): IDependentsMap;
    RemoveUsingRelationshipSnapshot(entry: InternalEntityEntry): void;
    TryGetEntry(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
    TryGetEntry(keyValues: IReadOnlyList<unknown>, throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(foreignKey: IForeignKey, dependentEntry: InternalEntityEntry): InternalEntityEntry | undefined;
    TryGetEntryTyped(keyValue: TKey): InternalEntityEntry | undefined;
}


export const NullableKeyIdentityMap_1: {
    new<TKey>(key: IKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>, sensitiveLoggingEnabled: boolean): NullableKeyIdentityMap_1<TKey>;
};


export interface __NullableKeyIdentityMap_1$views<TKey> {
    As_IIdentityMap(): IIdentityMap$instance;
    As_IIdentityMap_1(): IIdentityMap_1$instance<TKey>;
}

export type NullableKeyIdentityMap_1<TKey> = NullableKeyIdentityMap_1$instance<TKey> & __NullableKeyIdentityMap_1$views<TKey>;


export interface NullableStructCurrentProviderValueComparer_2$instance<TModel extends unknown, TProvider> {
    Compare(x: IUpdateEntry, y: IUpdateEntry): int;
}


export const NullableStructCurrentProviderValueComparer_2: {
    new<TModel extends unknown, TProvider>(property: IProperty): NullableStructCurrentProviderValueComparer_2<TModel, TProvider>;
};


export type NullableStructCurrentProviderValueComparer_2<TModel, TProvider> = NullableStructCurrentProviderValueComparer_2$instance<TModel, TProvider>;

export interface NullableValueComparer_1$instance<T extends unknown> extends ValueComparer_1<Nullable<T>> {
}


export const NullableValueComparer_1: {
    new<T extends unknown>(valueComparer: ValueComparer): NullableValueComparer_1<T>;
};


export interface __NullableValueComparer_1$views<T extends unknown> {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<ValueComparer>;
}

export interface NullableValueComparer_1$instance<T extends unknown> extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<ValueComparer> {}

export type NullableValueComparer_1<T> = NullableValueComparer_1$instance<T> & __NullableValueComparer_1$views<T>;


export abstract class ObservableBackedBindingList_1$protected<T> {
    protected AddNewCore(): unknown | undefined;
    protected ClearItems(): void;
    protected InsertItem(index: int, item: T): void;
    protected RemoveItem(index: int): void;
    protected SetItem(index: int, item: T): void;
}


export interface ObservableBackedBindingList_1$instance<T> extends ObservableBackedBindingList_1$protected<T>, SortableBindingList_1<T> {
    CancelNew(itemIndex: int): void;
    EndNew(itemIndex: int): void;
}


export const ObservableBackedBindingList_1: {
    new<T>(observableCollection: ICollection__System_Collections_Generic<T>): ObservableBackedBindingList_1<T>;
};


export type ObservableBackedBindingList_1<T> = ObservableBackedBindingList_1$instance<T>;

export abstract class OriginalPropertyValues$protected {
    protected GetComplexCollectionEntry(entry: InternalEntryBase, complexProperty: IComplexProperty, i: int): InternalComplexEntry;
    protected GetValueInternal(entry: IInternalEntry, property: IPropertyBase): unknown | undefined;
    protected SetValueInternal(entry: IInternalEntry, property: IPropertyBase, value: unknown): void;
}


export interface OriginalPropertyValues$instance extends OriginalPropertyValues$protected, EntryPropertyValues {
    GetValue<TValue>(propertyName: string): TValue;
    GetValue<TValue>(property: IProperty): TValue;
}


export const OriginalPropertyValues: {
    new(internalEntry: InternalEntryBase): OriginalPropertyValues;
};


export type OriginalPropertyValues = OriginalPropertyValues$instance;

export abstract class OriginalValuesFactoryFactory$protected {
    protected GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected GetValueComparerMethod(): MethodInfo | undefined;
}


export interface OriginalValuesFactoryFactory$instance extends OriginalValuesFactoryFactory$protected, SnapshotFactoryFactory_1<IInternalEntry> {
}


export const OriginalValuesFactoryFactory: {
    new(): OriginalValuesFactoryFactory;
    readonly Instance: OriginalValuesFactoryFactory;
};


export type OriginalValuesFactoryFactory = OriginalValuesFactoryFactory$instance;

export abstract class RelationshipSnapshotFactoryFactory$protected {
    protected GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected GetValueComparerMethod(): MethodInfo | undefined;
}


export interface RelationshipSnapshotFactoryFactory$instance extends RelationshipSnapshotFactoryFactory$protected, SnapshotFactoryFactory_1<IInternalEntry> {
}


export const RelationshipSnapshotFactoryFactory: {
    new(): RelationshipSnapshotFactoryFactory;
    readonly Instance: RelationshipSnapshotFactoryFactory;
};


export type RelationshipSnapshotFactoryFactory = RelationshipSnapshotFactoryFactory$instance;

export abstract class ShadowValuesFactoryFactory$protected {
    protected readonly UseEntityVariable: boolean;
    protected CreateReadShadowValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected CreateReadValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected GetValueComparerMethod(): MethodInfo | undefined;
}


export interface ShadowValuesFactoryFactory$instance extends ShadowValuesFactoryFactory$protected, SnapshotFactoryFactory_1<IDictionary<System_Internal.String, unknown>> {
}


export const ShadowValuesFactoryFactory: {
    new(): ShadowValuesFactoryFactory;
    readonly Instance: ShadowValuesFactoryFactory;
};


export type ShadowValuesFactoryFactory = ShadowValuesFactoryFactory$instance;

export abstract class SidecarValuesFactoryFactory$protected {
    protected GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected GetValueComparerMethod(): MethodInfo | undefined;
}


export interface SidecarValuesFactoryFactory$instance extends SidecarValuesFactoryFactory$protected, SnapshotFactoryFactory_1<IInternalEntry> {
}


export const SidecarValuesFactoryFactory: {
    new(): SidecarValuesFactoryFactory;
    readonly Instance: SidecarValuesFactoryFactory;
};


export type SidecarValuesFactoryFactory = SidecarValuesFactoryFactory$instance;

export interface SimpleFullyNullableDependentKeyValueFactory_1$instance<TKey> extends DependentKeyValueFactory_1<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromPreStoreGeneratedCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromRelationshipSnapshot(entry: IUpdateEntry, key: TKey): boolean;
}


export const SimpleFullyNullableDependentKeyValueFactory_1: {
    new<TKey>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): SimpleFullyNullableDependentKeyValueFactory_1<TKey>;
};


export interface __SimpleFullyNullableDependentKeyValueFactory_1$views<TKey> {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<TKey>;
}

export type SimpleFullyNullableDependentKeyValueFactory_1<TKey> = SimpleFullyNullableDependentKeyValueFactory_1$instance<TKey> & __SimpleFullyNullableDependentKeyValueFactory_1$views<TKey>;


export interface SimpleNonNullableDependentKeyValueFactory_1$instance<TKey> extends DependentKeyValueFactory_1<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromPreStoreGeneratedCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromRelationshipSnapshot(entry: IUpdateEntry, key: TKey): boolean;
}


export const SimpleNonNullableDependentKeyValueFactory_1: {
    new<TKey>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): SimpleNonNullableDependentKeyValueFactory_1<TKey>;
};


export interface __SimpleNonNullableDependentKeyValueFactory_1$views<TKey> {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<TKey>;
}

export type SimpleNonNullableDependentKeyValueFactory_1<TKey> = SimpleNonNullableDependentKeyValueFactory_1$instance<TKey> & __SimpleNonNullableDependentKeyValueFactory_1$views<TKey>;


export interface SimpleNullableDependentKeyValueFactory_1$instance<TKey extends unknown> extends DependentKeyValueFactory_1<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromPreStoreGeneratedCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromRelationshipSnapshot(entry: IUpdateEntry, key: TKey): boolean;
}


export const SimpleNullableDependentKeyValueFactory_1: {
    new<TKey extends unknown>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): SimpleNullableDependentKeyValueFactory_1<TKey>;
};


export interface __SimpleNullableDependentKeyValueFactory_1$views<TKey extends unknown> {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<TKey>;
}

export type SimpleNullableDependentKeyValueFactory_1<TKey> = SimpleNullableDependentKeyValueFactory_1$instance<TKey> & __SimpleNullableDependentKeyValueFactory_1$views<TKey>;


export interface SimpleNullablePrincipalDependentKeyValueFactory_2$instance<TKey, TNonNullableKey extends unknown> extends DependentKeyValueFactory_1<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreatePrincipalEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    TryCreateFromCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromOriginalValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromPreStoreGeneratedCurrentValues(entry: IUpdateEntry, key: TKey): boolean;
    TryCreateFromRelationshipSnapshot(entry: IUpdateEntry, key: TKey): boolean;
}


export const SimpleNullablePrincipalDependentKeyValueFactory_2: {
    new<TKey, TNonNullableKey extends unknown>(foreignKey: IForeignKey, principalKeyValueFactory: IPrincipalKeyValueFactory_1<TKey>): SimpleNullablePrincipalDependentKeyValueFactory_2<TKey, TNonNullableKey>;
};


export interface __SimpleNullablePrincipalDependentKeyValueFactory_2$views<TKey, TNonNullableKey extends unknown> {
    As_IDependentKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory$instance;
    As_IDependentKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IDependentKeyValueFactory_1$instance<TKey>;
}

export type SimpleNullablePrincipalDependentKeyValueFactory_2<TKey, TNonNullableKey> = SimpleNullablePrincipalDependentKeyValueFactory_2$instance<TKey, TNonNullableKey> & __SimpleNullablePrincipalDependentKeyValueFactory_2$views<TKey, TNonNullableKey>;


export interface SimplePrincipalKeyValueFactory_1$instance<TKey> {
    readonly EqualityComparer: IEqualityComparer__System_Collections_Generic<TKey>;
    CreateEquatableKey(entry: IUpdateEntry, fromOriginalValues: boolean): unknown;
    CreateFromCurrentValues(entry: IUpdateEntry): TKey;
    CreateFromKeyValues(keyValues: IReadOnlyList<unknown>): unknown | undefined;
    CreateFromOriginalValues(entry: IUpdateEntry): TKey;
    CreateFromRelationshipSnapshot(entry: IUpdateEntry): TKey;
    FindNullPropertyInCurrentValues(entry: IUpdateEntry): IProperty;
    FindNullPropertyInKeyValues(keyValues: IReadOnlyList<unknown>): IProperty;
}


export const SimplePrincipalKeyValueFactory_1: {
    new<TKey>(key: IKey): SimplePrincipalKeyValueFactory_1<TKey>;
};


export interface __SimplePrincipalKeyValueFactory_1$views<TKey> {
    As_IPrincipalKeyValueFactory(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IPrincipalKeyValueFactory$instance;
    As_IPrincipalKeyValueFactory_1(): Microsoft_EntityFrameworkCore_ChangeTracking_Internal.IPrincipalKeyValueFactory_1$instance<TKey>;
}

export type SimplePrincipalKeyValueFactory_1<TKey> = SimplePrincipalKeyValueFactory_1$instance<TKey> & __SimplePrincipalKeyValueFactory_1$views<TKey>;


export interface Snapshot$instance {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot: {
    new(): Snapshot;
    Empty: ISnapshot;
    readonly EmptyField: FieldInfo;
    readonly GetValueMethod: MethodInfo;
    readonly MaxGenericTypes: int;
    CreateSnapshotType(types: Type[]): Type;
};


export interface __Snapshot$views {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot$instance extends ISnapshot$instance {}

export type Snapshot = Snapshot$instance & __Snapshot$views;


export interface Snapshot_1$instance<T0> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_1: {
    new<T0>(value0: T0): Snapshot_1<T0>;
};


export interface __Snapshot_1$views<T0> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_1$instance<T0> extends ISnapshot$instance {}

export type Snapshot_1<T0> = Snapshot_1$instance<T0> & __Snapshot_1$views<T0>;


export interface Snapshot_10$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_10: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9): Snapshot_10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
};


export interface __Snapshot_10$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_10$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> extends ISnapshot$instance {}

export type Snapshot_10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> = Snapshot_10$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> & __Snapshot_10$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>;


export interface Snapshot_11$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_11: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10): Snapshot_11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
};


export interface __Snapshot_11$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_11$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> extends ISnapshot$instance {}

export type Snapshot_11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = Snapshot_11$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> & __Snapshot_11$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;


export interface Snapshot_12$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_12: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11): Snapshot_12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
};


export interface __Snapshot_12$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_12$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> extends ISnapshot$instance {}

export type Snapshot_12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = Snapshot_12$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> & __Snapshot_12$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;


export interface Snapshot_13$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_13: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12): Snapshot_13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
};


export interface __Snapshot_13$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_13$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> extends ISnapshot$instance {}

export type Snapshot_13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = Snapshot_13$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> & __Snapshot_13$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;


export interface Snapshot_14$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_14: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13): Snapshot_14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
};


export interface __Snapshot_14$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_14$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> extends ISnapshot$instance {}

export type Snapshot_14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = Snapshot_14$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> & __Snapshot_14$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;


export interface Snapshot_15$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_15: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14): Snapshot_15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
};


export interface __Snapshot_15$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_15$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> extends ISnapshot$instance {}

export type Snapshot_15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = Snapshot_15$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> & __Snapshot_15$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;


export interface Snapshot_16$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_16: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15): Snapshot_16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
};


export interface __Snapshot_16$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_16$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> extends ISnapshot$instance {}

export type Snapshot_16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = Snapshot_16$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> & __Snapshot_16$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;


export interface Snapshot_17$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_17: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16): Snapshot_17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
};


export interface __Snapshot_17$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_17$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> extends ISnapshot$instance {}

export type Snapshot_17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = Snapshot_17$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> & __Snapshot_17$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;


export interface Snapshot_18$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_18: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17): Snapshot_18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>;
};


export interface __Snapshot_18$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_18$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> extends ISnapshot$instance {}

export type Snapshot_18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> = Snapshot_18$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> & __Snapshot_18$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>;


export interface Snapshot_19$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_19: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18): Snapshot_19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>;
};


export interface __Snapshot_19$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_19$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> extends ISnapshot$instance {}

export type Snapshot_19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> = Snapshot_19$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> & __Snapshot_19$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>;


export interface Snapshot_2$instance<T0, T1> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_2: {
    new<T0, T1>(value0: T0, value1: T1): Snapshot_2<T0, T1>;
};


export interface __Snapshot_2$views<T0, T1> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_2$instance<T0, T1> extends ISnapshot$instance {}

export type Snapshot_2<T0, T1> = Snapshot_2$instance<T0, T1> & __Snapshot_2$views<T0, T1>;


export interface Snapshot_20$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_20: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19): Snapshot_20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>;
};


export interface __Snapshot_20$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_20$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> extends ISnapshot$instance {}

export type Snapshot_20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> = Snapshot_20$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> & __Snapshot_20$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>;


export interface Snapshot_21$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_21: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20): Snapshot_21<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>;
};


export interface __Snapshot_21$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_21$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> extends ISnapshot$instance {}

export type Snapshot_21<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> = Snapshot_21$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> & __Snapshot_21$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>;


export interface Snapshot_22$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_22: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21): Snapshot_22<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>;
};


export interface __Snapshot_22$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_22$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> extends ISnapshot$instance {}

export type Snapshot_22<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> = Snapshot_22$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> & __Snapshot_22$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>;


export interface Snapshot_23$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_23: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22): Snapshot_23<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>;
};


export interface __Snapshot_23$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_23$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> extends ISnapshot$instance {}

export type Snapshot_23<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> = Snapshot_23$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> & __Snapshot_23$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>;


export interface Snapshot_24$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_24: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23): Snapshot_24<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>;
};


export interface __Snapshot_24$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_24$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> extends ISnapshot$instance {}

export type Snapshot_24<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> = Snapshot_24$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> & __Snapshot_24$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>;


export interface Snapshot_25$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_25: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24): Snapshot_25<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>;
};


export interface __Snapshot_25$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_25$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> extends ISnapshot$instance {}

export type Snapshot_25<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> = Snapshot_25$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> & __Snapshot_25$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>;


export interface Snapshot_26$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_26: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24, value25: T25): Snapshot_26<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>;
};


export interface __Snapshot_26$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_26$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> extends ISnapshot$instance {}

export type Snapshot_26<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> = Snapshot_26$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> & __Snapshot_26$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>;


export interface Snapshot_27$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_27: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24, value25: T25, value26: T26): Snapshot_27<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>;
};


export interface __Snapshot_27$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_27$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> extends ISnapshot$instance {}

export type Snapshot_27<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> = Snapshot_27$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> & __Snapshot_27$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>;


export interface Snapshot_28$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_28: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24, value25: T25, value26: T26, value27: T27): Snapshot_28<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>;
};


export interface __Snapshot_28$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_28$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> extends ISnapshot$instance {}

export type Snapshot_28<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> = Snapshot_28$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> & __Snapshot_28$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>;


export interface Snapshot_29$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_29: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24, value25: T25, value26: T26, value27: T27, value28: T28): Snapshot_29<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>;
};


export interface __Snapshot_29$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_29$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> extends ISnapshot$instance {}

export type Snapshot_29<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> = Snapshot_29$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> & __Snapshot_29$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>;


export interface Snapshot_3$instance<T0, T1, T2> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_3: {
    new<T0, T1, T2>(value0: T0, value1: T1, value2: T2): Snapshot_3<T0, T1, T2>;
};


export interface __Snapshot_3$views<T0, T1, T2> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_3$instance<T0, T1, T2> extends ISnapshot$instance {}

export type Snapshot_3<T0, T1, T2> = Snapshot_3$instance<T0, T1, T2> & __Snapshot_3$views<T0, T1, T2>;


export interface Snapshot_30$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_30: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8, value9: T9, value10: T10, value11: T11, value12: T12, value13: T13, value14: T14, value15: T15, value16: T16, value17: T17, value18: T18, value19: T19, value20: T20, value21: T21, value22: T22, value23: T23, value24: T24, value25: T25, value26: T26, value27: T27, value28: T28, value29: T29): Snapshot_30<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>;
};


export interface __Snapshot_30$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_30$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> extends ISnapshot$instance {}

export type Snapshot_30<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> = Snapshot_30$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29> & __Snapshot_30$views<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>;


export interface Snapshot_4$instance<T0, T1, T2, T3> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_4: {
    new<T0, T1, T2, T3>(value0: T0, value1: T1, value2: T2, value3: T3): Snapshot_4<T0, T1, T2, T3>;
};


export interface __Snapshot_4$views<T0, T1, T2, T3> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_4$instance<T0, T1, T2, T3> extends ISnapshot$instance {}

export type Snapshot_4<T0, T1, T2, T3> = Snapshot_4$instance<T0, T1, T2, T3> & __Snapshot_4$views<T0, T1, T2, T3>;


export interface Snapshot_5$instance<T0, T1, T2, T3, T4> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_5: {
    new<T0, T1, T2, T3, T4>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4): Snapshot_5<T0, T1, T2, T3, T4>;
};


export interface __Snapshot_5$views<T0, T1, T2, T3, T4> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_5$instance<T0, T1, T2, T3, T4> extends ISnapshot$instance {}

export type Snapshot_5<T0, T1, T2, T3, T4> = Snapshot_5$instance<T0, T1, T2, T3, T4> & __Snapshot_5$views<T0, T1, T2, T3, T4>;


export interface Snapshot_6$instance<T0, T1, T2, T3, T4, T5> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_6: {
    new<T0, T1, T2, T3, T4, T5>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5): Snapshot_6<T0, T1, T2, T3, T4, T5>;
};


export interface __Snapshot_6$views<T0, T1, T2, T3, T4, T5> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_6$instance<T0, T1, T2, T3, T4, T5> extends ISnapshot$instance {}

export type Snapshot_6<T0, T1, T2, T3, T4, T5> = Snapshot_6$instance<T0, T1, T2, T3, T4, T5> & __Snapshot_6$views<T0, T1, T2, T3, T4, T5>;


export interface Snapshot_7$instance<T0, T1, T2, T3, T4, T5, T6> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_7: {
    new<T0, T1, T2, T3, T4, T5, T6>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6): Snapshot_7<T0, T1, T2, T3, T4, T5, T6>;
};


export interface __Snapshot_7$views<T0, T1, T2, T3, T4, T5, T6> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_7$instance<T0, T1, T2, T3, T4, T5, T6> extends ISnapshot$instance {}

export type Snapshot_7<T0, T1, T2, T3, T4, T5, T6> = Snapshot_7$instance<T0, T1, T2, T3, T4, T5, T6> & __Snapshot_7$views<T0, T1, T2, T3, T4, T5, T6>;


export interface Snapshot_8$instance<T0, T1, T2, T3, T4, T5, T6, T7> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_8: {
    new<T0, T1, T2, T3, T4, T5, T6, T7>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7): Snapshot_8<T0, T1, T2, T3, T4, T5, T6, T7>;
};


export interface __Snapshot_8$views<T0, T1, T2, T3, T4, T5, T6, T7> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_8$instance<T0, T1, T2, T3, T4, T5, T6, T7> extends ISnapshot$instance {}

export type Snapshot_8<T0, T1, T2, T3, T4, T5, T6, T7> = Snapshot_8$instance<T0, T1, T2, T3, T4, T5, T6, T7> & __Snapshot_8$views<T0, T1, T2, T3, T4, T5, T6, T7>;


export interface Snapshot_9$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8> {
    Item: unknown;
    GetValue<T>(index: int): T;
}


export const Snapshot_9: {
    new<T0, T1, T2, T3, T4, T5, T6, T7, T8>(value0: T0, value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8): Snapshot_9<T0, T1, T2, T3, T4, T5, T6, T7, T8>;
};


export interface __Snapshot_9$views<T0, T1, T2, T3, T4, T5, T6, T7, T8> {
    As_ISnapshot(): ISnapshot$instance;
}

export interface Snapshot_9$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8> extends ISnapshot$instance {}

export type Snapshot_9<T0, T1, T2, T3, T4, T5, T6, T7, T8> = Snapshot_9$instance<T0, T1, T2, T3, T4, T5, T6, T7, T8> & __Snapshot_9$views<T0, T1, T2, T3, T4, T5, T6, T7, T8>;


export abstract class SnapshotFactoryFactory$protected {
    protected readonly UseEntityVariable: boolean;
    protected CreateReadShadowValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected CreateReadValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected CreateSnapshotExpression(clrType: Type, parameter: Expression, types: Type[], propertyBases: IList__System_Collections_Generic<IPropertyBase>): Expression;
    protected abstract GetPropertyCount(structuralType: IRuntimeTypeBase): int;
    protected abstract GetPropertyIndex(propertyBase: IPropertyBase): int;
    protected abstract GetValueComparer(property: IProperty): ValueComparer | undefined;
    protected abstract GetValueComparerMethod(): MethodInfo | undefined;
}


export interface SnapshotFactoryFactory$instance extends SnapshotFactoryFactory$protected {
    CreateConstructorExpression(structuralType: IRuntimeTypeBase, parameter: Expression): Expression;
    CreateEmpty(structuralType: IRuntimeTypeBase): Func<ISnapshot>;
    CreateEmptyExpression(structuralType: IRuntimeTypeBase): Expression<Func<ISnapshot>>;
}


export const SnapshotFactoryFactory: {
    new(): SnapshotFactoryFactory;
    SnapshotCollection(collection: IEnumerable): HashSet<unknown> | undefined;
    SnapshotComplexCollection(list: IList, complexProperty: IRuntimeComplexProperty): IList | undefined;
};


export type SnapshotFactoryFactory = SnapshotFactoryFactory$instance;

export interface SnapshotFactoryFactory_1$instance<TInput> extends SnapshotFactoryFactory {
    Create(structuralType: IRuntimeTypeBase): Func<TInput, ISnapshot>;
    CreateExpression(structuralType: IRuntimeTypeBase): Expression<Func<TInput, ISnapshot>>;
}


export const SnapshotFactoryFactory_1: {
    new<TInput>(): SnapshotFactoryFactory_1<TInput>;
};


export type SnapshotFactoryFactory_1<TInput> = SnapshotFactoryFactory_1$instance<TInput>;

export abstract class SortableBindingList_1$protected<T> {
    protected readonly IsSortedCore: boolean;
    protected readonly SortDirectionCore: ListSortDirection;
    protected readonly SortPropertyCore: PropertyDescriptor | undefined;
    protected readonly SupportsSortingCore: boolean;
    protected ApplySortCore(prop: PropertyDescriptor, direction: ListSortDirection): void;
    protected RemoveSortCore(): void;
}


export interface SortableBindingList_1$instance<T> extends SortableBindingList_1$protected<T>, BindingList<T> {
}


export const SortableBindingList_1: {
    new<T>(list: List<T>): SortableBindingList_1<T>;
};


export type SortableBindingList_1<T> = SortableBindingList_1$instance<T>;

export abstract class StateManager$protected {
    protected SaveChanges(entriesToSave: IList__System_Collections_Generic<IUpdateEntry>): int;
    protected SaveChangesAsync(entriesToSave: IList__System_Collections_Generic<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export interface StateManager$instance extends StateManager$protected {
    CascadeDeleteTiming: CascadeTiming;
    ChangedCount: int;
    readonly ChangeDetector: IChangeDetector;
    readonly Context: DbContext;
    readonly Count: int;
    DeleteOrphansTiming: CascadeTiming;
    readonly Dependencies: StateManagerDependencies;
    readonly EntityFinderFactory: IEntityFinderFactory;
    readonly EntityMaterializerSource: IStructuralTypeMaterializerSource;
    readonly Entries: IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    readonly InternalEntityEntryNotifier: IInternalEntityEntryNotifier;
    readonly Model: IModel;
    SavingChanges: boolean;
    readonly SensitiveLoggingEnabled: boolean;
    readonly UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    readonly ValueGenerationManager: IValueGenerationManager;
    AbortAttachGraph(): void;
    AcceptAllChanges(): void;
    BeginAttachGraph(): void;
    CaptureEvents(): ValueTuple<EventHandler<EntityTrackingEventArgs>, EventHandler<EntityTrackedEventArgs>, EventHandler<EntityStateChangingEventArgs>, EventHandler<EntityStateChangedEventArgs>>;
    CascadeChanges(force: boolean): void;
    CascadeDelete(entry: InternalEntityEntry, force: boolean, foreignKeys?: IEnumerable__System_Collections_Generic<IForeignKey>): void;
    ChangingState(entry: InternalEntityEntry, newState: EntityState): void;
    Clear(resetting: boolean): void;
    CompleteAttachGraph(): void;
    CreateEntityFinder(entityType: IEntityType): IEntityFinder;
    CreateEntry(values: IDictionary<System_Internal.String, unknown>, entityType: IEntityType): InternalEntityEntry;
    FindPrincipal(dependentEntry: InternalEntityEntry, foreignKey: IForeignKey): InternalEntityEntry | undefined;
    FindPrincipalUsingPreStoreGeneratedValues(dependentEntry: InternalEntityEntry, foreignKey: IForeignKey): InternalEntityEntry | undefined;
    FindPrincipalUsingRelationshipSnapshot(dependentEntry: InternalEntityEntry, foreignKey: IForeignKey): InternalEntityEntry | undefined;
    GetCountForState(added?: boolean, modified?: boolean, deleted?: boolean, unchanged?: boolean, countDeletedSharedIdentity?: boolean): int;
    GetDependents(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependents(keyValues: IReadOnlyList<unknown>, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetDependentsFromNavigation(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry> | undefined;
    GetDependentsUsingRelationshipSnapshot(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable__System_Collections_Generic<IUpdateEntry>;
    GetEntries(key: IKey): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntriesForState(added?: boolean, modified?: boolean, deleted?: boolean, unchanged?: boolean, returnDeletedSharedIdentity?: boolean): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntriesToSave(cascadeChanges: boolean): IList__System_Collections_Generic<IUpdateEntry>;
    GetNonDeletedEntities<TEntity>(): IEnumerable__System_Collections_Generic<TEntity>;
    GetOrCreateEntry(entity: unknown): InternalEntityEntry;
    GetOrCreateEntry(entity: unknown, entityType: IEntityType): InternalEntityEntry;
    GetRecordedReferrers(referencedEntity: unknown, clear: boolean): IEnumerable__System_Collections_Generic<Tuple<INavigationBase, InternalEntityEntry>>;
    OnStateChanged(internalEntityEntry: InternalEntityEntry, oldState: EntityState): void;
    OnStateChanging(internalEntityEntry: InternalEntityEntry, newState: EntityState): void;
    OnTracked(internalEntityEntry: InternalEntityEntry, fromQuery: boolean): void;
    OnTracking(internalEntityEntry: InternalEntityEntry, state: EntityState, fromQuery: boolean): void;
    RecordReferencedUntrackedEntity(referencedEntity: unknown, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): void;
    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
    ResolveToExistingEntry(newEntry: InternalEntityEntry, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): boolean;
    SaveChanges(acceptAllChangesOnSuccess: boolean): int;
    SaveChangesAsync(acceptAllChangesOnSuccess: boolean, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    SetEvents(tracking: EventHandler<EntityTrackingEventArgs>, tracked: EventHandler<EntityTrackedEventArgs>, stateChanging: EventHandler<EntityStateChangingEventArgs>, stateChanged: EventHandler<EntityStateChangedEventArgs>): void;
    StartTracking(entry: InternalEntityEntry): InternalEntityEntry;
    StartTracking(entry: InternalComplexEntry): InternalComplexEntry;
    StartTrackingFromQuery(baseEntityType: IEntityType, entity: unknown, snapshot: ISnapshot): InternalEntityEntry;
    StopTracking(entry: InternalEntityEntry, oldState: EntityState): void;
    StopTracking(entry: InternalComplexEntry, oldState: EntityState): void;
    TryGetEntry(key: IKey, keyValues: IReadOnlyList<unknown>): InternalEntityEntry | undefined;
    TryGetEntry(key: IKey, keyValues: unknown[], throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
    TryGetEntry(entity: unknown, throwOnNonUniqueness?: boolean): InternalEntityEntry | undefined;
    TryGetEntry(entity: unknown, entityType: IEntityType, throwOnTypeMismatch?: boolean): InternalEntityEntry | undefined;
    TryGetEntryTyped<TKey>(key: IKey, keyValue: TKey): InternalEntityEntry | undefined;
    TryGetExistingEntry(entity: unknown, key: IKey): InternalEntityEntry | undefined;
    Unsubscribe(resetting: boolean): void;
    UpdateDependentMap(entry: InternalEntityEntry, foreignKey: IForeignKey): void;
    UpdateIdentityMap(entry: InternalEntityEntry, key: IKey): void;
    UpdateReferencedUntrackedEntity(referencedEntity: unknown, newReferencedEntity: unknown, navigation: INavigationBase, referencedFromEntry: InternalEntityEntry): void;
}


export const StateManager: {
    new(dependencies: StateManagerDependencies): StateManager;
};


export interface __StateManager$views {
    As_IStateManager(): IStateManager$instance;
    As_IResettableService(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance;
}

export type StateManager = StateManager$instance & __StateManager$views;


export interface StateManagerDependencies$instance {
    ChangeTrackingLogger: IDiagnosticsLogger_1<DbLoggerCategory_ChangeTracking>;
    ConcurrencyDetector: IConcurrencyDetector;
    CoreSingletonOptions: ICoreSingletonOptions;
    CurrentContext: ICurrentDbContext;
    Database: IDatabase;
    EntityFinderSource: IEntityFinderSource;
    EntityMaterializerSource: IStructuralTypeMaterializerSource;
    ExecutionStrategy: IExecutionStrategy;
    readonly Interceptors: IInterceptors;
    InternalEntityEntryNotifier: IInternalEntityEntryNotifier;
    InternalEntityEntrySubscriber: IInternalEntrySubscriber;
    LoggingOptions: ILoggingOptions;
    Model: IModel;
    NavigationFixer: INavigationFixer;
    SetSource: IDbSetSource;
    UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    ValueGenerationManager: IValueGenerationManager;
    _Clone_$(): StateManagerDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: StateManagerDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const StateManagerDependencies: {
    new(internalEntityEntrySubscriber: IInternalEntrySubscriber, internalEntityEntryNotifier: IInternalEntityEntryNotifier, valueGenerationManager: IValueGenerationManager, model: IModel, database: IDatabase, concurrencyDetector: IConcurrencyDetector, currentContext: ICurrentDbContext, entityFinderSource: IEntityFinderSource, setSource: IDbSetSource, entityMaterializerSource: IStructuralTypeMaterializerSource, executionStrategy: IExecutionStrategy, coreSingletonOptions: ICoreSingletonOptions, loggingOptions: ILoggingOptions, updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>, changeTrackingLogger: IDiagnosticsLogger_1<DbLoggerCategory_ChangeTracking>, navigationFixer: INavigationFixer, interceptors: IInterceptors): StateManagerDependencies;
};


export type StateManagerDependencies = StateManagerDependencies$instance;

export abstract class StoreGeneratedValuesFactoryFactory$protected {
    protected readonly UseEntityVariable: boolean;
    protected CreateReadShadowValueExpression(parameter: Expression, property: IPropertyBase): Expression;
    protected CreateReadValueExpression(parameter: Expression, property: IPropertyBase): Expression;
}


export interface StoreGeneratedValuesFactoryFactory$instance extends StoreGeneratedValuesFactoryFactory$protected, SidecarValuesFactoryFactory {
}


export const StoreGeneratedValuesFactoryFactory: {
    new(): StoreGeneratedValuesFactoryFactory;
};


export type StoreGeneratedValuesFactoryFactory = StoreGeneratedValuesFactoryFactory$instance;

export abstract class StructuralEntryCurrentProviderValueComparer$protected {
    protected GetPropertyValue(entry: IUpdateEntry): unknown | undefined;
}


export interface StructuralEntryCurrentProviderValueComparer$instance extends StructuralEntryCurrentProviderValueComparer$protected, StructuralEntryCurrentValueComparer {
}


export const StructuralEntryCurrentProviderValueComparer: {
    new(property: IProperty): StructuralEntryCurrentProviderValueComparer;
};


export type StructuralEntryCurrentProviderValueComparer = StructuralEntryCurrentProviderValueComparer$instance;

export interface StructuralEntryCurrentValueComparer$instance extends EntryCurrentValueComparer {
    Compare(x: IUpdateEntry, y: IUpdateEntry): int;
}


export const StructuralEntryCurrentValueComparer: {
    new(property: IProperty): StructuralEntryCurrentValueComparer;
};


export type StructuralEntryCurrentValueComparer = StructuralEntryCurrentValueComparer$instance;

export abstract class TemporaryValuesFactoryFactory$protected {
    protected CreateSnapshotExpression2(entityType: Type, parameter: Expression, types: Type[], propertyBases: IList__System_Collections_Generic<IPropertyBase>): Expression;
    protected CreateSnapshotExpression(clrType: Type, parameter: Expression, types: Type[], propertyBases: IList__System_Collections_Generic<IPropertyBase>): Expression;
}


export interface TemporaryValuesFactoryFactory$instance extends TemporaryValuesFactoryFactory$protected, SidecarValuesFactoryFactory {
}


export const TemporaryValuesFactoryFactory: {
    new(): TemporaryValuesFactoryFactory;
};


export type TemporaryValuesFactoryFactory = TemporaryValuesFactoryFactory$instance;

export interface ValueGenerationManager$instance {
    Generate(entry: InternalEntityEntry, includePrimaryKey?: boolean): boolean;
    GenerateAsync(entry: InternalEntityEntry, includePrimaryKey?: boolean, cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    Propagate(entry: InternalEntityEntry): InternalEntityEntry | undefined;
    PropagateAsync(entry: InternalEntityEntry, cancellationToken: CancellationToken): Task<InternalEntityEntry | undefined>;
}


export const ValueGenerationManager: {
    new(valueGeneratorSelector: IValueGeneratorSelector, keyPropagator: IKeyPropagator, logger: IDiagnosticsLogger_1<DbLoggerCategory_ChangeTracking>, loggingOptions: ILoggingOptions): ValueGenerationManager;
};


export interface __ValueGenerationManager$views {
    As_IValueGenerationManager(): IValueGenerationManager$instance;
}

export interface ValueGenerationManager$instance extends IValueGenerationManager$instance {}

export type ValueGenerationManager = ValueGenerationManager$instance & __ValueGenerationManager$views;


export abstract class StateManagerExtensions$instance {
    static ToList(stateManager: IStateManager): IReadOnlyList<InternalEntityEntry>;
    static ToListForState(stateManager: IStateManager, added?: boolean, modified?: boolean, deleted?: boolean, unchanged?: boolean, returnDeletedSharedIdentity?: boolean): IReadOnlyList<InternalEntityEntry>;
}


export type StateManagerExtensions = StateManagerExtensions$instance;

export abstract class ValueComparerExtensions$instance {
    static ComposeConversion(valueComparer: ValueComparer, targetClrType: Type): ValueComparer | undefined;
    static ToNullableComparer(valueComparer: ValueComparer, clrType: Type): ValueComparer | undefined;
}


export type ValueComparerExtensions = ValueComparerExtensions$instance;

