// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Migrations
// Assembly: Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IDiagnosticsLogger_1, ILoggingOptions, IRelationalCommandDiagnosticsLogger } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import type { IAnnotation, ICurrentDbContext, IDbContextOptions, IModelRuntimeInitializer, ModelDependencies, ModelSnapshot } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IConventionSetBuilder } from "../../Microsoft.EntityFrameworkCore.Metadata.Conventions.Infrastructure/internal/index.js";
import type { ICheckConstraint, IColumn, IForeignKeyConstraint, IModel, IRelationalModel, ISequence, ITable, ITableIndex, IUniqueConstraint, IView, IViewColumn } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { AlterOperationBuilder_1, ColumnsBuilder, CreateTableBuilder_1, OperationBuilder_1 } from "../../Microsoft.EntityFrameworkCore.Migrations.Operations.Builders/internal/index.js";
import type { AddCheckConstraintOperation, AddColumnOperation, AddForeignKeyOperation, AddPrimaryKeyOperation, AddUniqueConstraintOperation, AlterColumnOperation, AlterDatabaseOperation, AlterSequenceOperation, AlterTableOperation, CreateIndexOperation, CreateSequenceOperation, DeleteDataOperation, DropCheckConstraintOperation, DropColumnOperation, DropForeignKeyOperation, DropIndexOperation, DropPrimaryKeyOperation, DropSchemaOperation, DropSequenceOperation, DropTableOperation, DropUniqueConstraintOperation, EnsureSchemaOperation, InsertDataOperation, MigrationOperation, RenameColumnOperation, RenameIndexOperation, RenameSequenceOperation, RenameTableOperation, RestartSequenceOperation, SqlOperation, UpdateDataOperation } from "../../Microsoft.EntityFrameworkCore.Migrations.Operations/internal/index.js";
import type { IDbContextTransaction, IRawSqlCommandBuilder, IRelationalCommand, IRelationalCommandBuilderFactory, IRelationalConnection, IRelationalDatabaseCreator, IRelationalTypeMappingSource, ISqlGenerationHelper } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { IModificationCommandFactory, IUpdateSqlGenerator } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { DbContext, DbLoggerCategory_Migrations } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IEnumerable, IReadOnlyDictionary, IReadOnlyList, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IsolationLevel } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Attribute, Boolean as ClrBoolean, Enum, FormattableString, Func, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, Type, Void } from "@tsonic/dotnet/System.js";
import type { Assembly, TypeInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum LockReleaseBehavior {
    transaction = 0,
    connection = 1,
    explicit = 2
}


export enum MigrationsSqlGenerationOptions {
    default = 0,
    script = 1,
    idempotent = 2,
    noTransactions = 4
}


export enum ReferentialAction {
    noAction = 0,
    restrict = 1,
    cascade = 2,
    setNull = 3,
    setDefault = 4
}


export interface IHistoryRepository$instance {
    readonly lockReleaseBehavior: LockReleaseBehavior;
    acquireDatabaseLock(): IMigrationsDatabaseLock;
    create(): void;
    createAsync(cancellationToken?: CancellationToken): Task;
    exists(): boolean;
    existsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    getAppliedMigrations(): IReadOnlyList<HistoryRow>;
    getCreateScript(): string;
    getDeleteScript(migrationId: string): string;
    getInsertScript(row: HistoryRow): string;
}


export type IHistoryRepository = IHistoryRepository$instance;

export interface IMigrationCommandExecutor$instance {
    executeNonQuery(migrationCommands: IEnumerable<MigrationCommand>, connection: IRelationalConnection): void;
    executeNonQuery(migrationCommands: IReadOnlyList<MigrationCommand>, connection: IRelationalConnection, executionState: MigrationExecutionState, commitTransaction: boolean, isolationLevel?: Nullable<IsolationLevel>): int;
    executeNonQueryAsync(migrationCommands: IEnumerable<MigrationCommand>, connection: IRelationalConnection, cancellationToken?: CancellationToken): Task;
    executeNonQueryAsync(migrationCommands: IReadOnlyList<MigrationCommand>, connection: IRelationalConnection, executionState: MigrationExecutionState, commitTransaction: boolean, isolationLevel?: Nullable<IsolationLevel>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export type IMigrationCommandExecutor = IMigrationCommandExecutor$instance;

export interface IMigrationsAnnotationProvider$instance {
    forRemove(checkConstraint: ICheckConstraint): IEnumerable<IAnnotation>;
    forRemove(column: IColumn): IEnumerable<IAnnotation>;
    forRemove(foreignKey: IForeignKeyConstraint): IEnumerable<IAnnotation>;
    forRemove(model: IRelationalModel): IEnumerable<IAnnotation>;
    forRemove(sequence: ISequence): IEnumerable<IAnnotation>;
    forRemove(table: ITable): IEnumerable<IAnnotation>;
    forRemove(index: ITableIndex): IEnumerable<IAnnotation>;
    forRemove(constraint: IUniqueConstraint): IEnumerable<IAnnotation>;
    forRemove(view: IView): IEnumerable<IAnnotation>;
    forRemove(column: IViewColumn): IEnumerable<IAnnotation>;
}


export type IMigrationsAnnotationProvider = IMigrationsAnnotationProvider$instance;

export interface IMigrationsAssembly$instance {
    readonly migrations: IReadOnlyDictionary<System_Internal.String, TypeInfo>;
    readonly modelSnapshot: ModelSnapshot | undefined;
    readonly assembly: Assembly;
    createMigration(migrationClass: TypeInfo, activeProvider: string): Migration;
    findMigrationId(nameOrId: string): string | undefined;
}


export type IMigrationsAssembly = IMigrationsAssembly$instance;

export interface IMigrationsDatabaseLock$instance extends IDisposable, IAsyncDisposable {
    reacquireIfNeeded(connectionReopened: boolean, transactionRestarted: Nullable<System_Internal.Boolean>): IMigrationsDatabaseLock;
    reacquireIfNeededAsync(connectionReopened: boolean, transactionRestarted: Nullable<System_Internal.Boolean>, cancellationToken?: CancellationToken): Task<IMigrationsDatabaseLock>;
}


export type IMigrationsDatabaseLock = IMigrationsDatabaseLock$instance;

export interface IMigrationsIdGenerator$instance {
    generateId(name: string): string;
    isValidId(value: string): boolean;
}


export type IMigrationsIdGenerator = IMigrationsIdGenerator$instance;

export interface IMigrationsModelDiffer$instance {
    getDifferences(source: IRelationalModel, target: IRelationalModel): IReadOnlyList<MigrationOperation>;
    hasDifferences(source: IRelationalModel, target: IRelationalModel): boolean;
}


export type IMigrationsModelDiffer = IMigrationsModelDiffer$instance;

export interface IMigrationsSqlGenerator$instance {
    generate(operations: IReadOnlyList<MigrationOperation>, model?: IModel, options?: MigrationsSqlGenerationOptions): IReadOnlyList<MigrationCommand>;
}


export type IMigrationsSqlGenerator = IMigrationsSqlGenerator$instance;

export interface IMigrator$instance {
    generateScript(fromMigration?: string, toMigration?: string, options?: MigrationsSqlGenerationOptions): string;
    hasPendingModelChanges(): boolean;
    migrate(targetMigration?: string): void;
    migrateAsync(targetMigration?: string, cancellationToken?: CancellationToken): Task;
}


export type IMigrator = IMigrator$instance;

export interface HistoryRepository$instance {
    readonly lockReleaseBehavior: LockReleaseBehavior;
    acquireDatabaseLock(): IMigrationsDatabaseLock;
    acquireDatabaseLockAsync(cancellationToken?: CancellationToken): Task<IMigrationsDatabaseLock>;
    create(): void;
    createAsync(cancellationToken?: CancellationToken): Task;
    exists(): boolean;
    existsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    getAppliedMigrations(): IReadOnlyList<HistoryRow>;
    getAppliedMigrationsAsync(cancellationToken?: CancellationToken): Task<IReadOnlyList<HistoryRow>>;
    getBeginIfExistsScript(migrationId: string): string;
    getBeginIfNotExistsScript(migrationId: string): string;
    getCreateIfNotExistsScript(): string;
    getCreateScript(): string;
    getDeleteScript(migrationId: string): string;
    getEndIfScript(): string;
    getInsertScript(row: HistoryRow): string;
}


export const HistoryRepository: {
    readonly defaultTableName: string;
};


export interface __HistoryRepository$views {
    As_IHistoryRepository(): IHistoryRepository$instance;
}

export interface HistoryRepository$instance extends IHistoryRepository$instance {}

export type HistoryRepository = HistoryRepository$instance & __HistoryRepository$views;


export interface HistoryRepositoryDependencies$instance {
    commandLogger: IRelationalCommandDiagnosticsLogger;
    connection: IRelationalConnection;
    conventionSetBuilder: IConventionSetBuilder;
    currentContext: ICurrentDbContext;
    databaseCreator: IRelationalDatabaseCreator;
    migrationCommandExecutor: IMigrationCommandExecutor;
    migrationsLogger: IDiagnosticsLogger_1<DbLoggerCategory_Migrations>;
    migrationsSqlGenerator: IMigrationsSqlGenerator;
    modelDependencies: ModelDependencies;
    modelDiffer: IMigrationsModelDiffer;
    modelRuntimeInitializer: IModelRuntimeInitializer;
    options: IDbContextOptions;
    rawSqlCommandBuilder: IRawSqlCommandBuilder;
    sqlGenerationHelper: ISqlGenerationHelper;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): HistoryRepositoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: HistoryRepositoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const HistoryRepositoryDependencies: {
    new(databaseCreator: IRelationalDatabaseCreator, rawSqlCommandBuilder: IRawSqlCommandBuilder, connection: IRelationalConnection, options: IDbContextOptions, modelDiffer: IMigrationsModelDiffer, migrationsSqlGenerator: IMigrationsSqlGenerator, migrationCommandExecutor: IMigrationCommandExecutor, sqlGenerationHelper: ISqlGenerationHelper, conventionSetBuilder: IConventionSetBuilder, modelDependencies: ModelDependencies, typeMappingSource: IRelationalTypeMappingSource, currentContext: ICurrentDbContext, modelRuntimeInitializer: IModelRuntimeInitializer, commandLogger: IRelationalCommandDiagnosticsLogger, migrationsLogger: IDiagnosticsLogger_1<DbLoggerCategory_Migrations>): HistoryRepositoryDependencies;
};


export type HistoryRepositoryDependencies = HistoryRepositoryDependencies$instance;

export interface HistoryRow$instance {
    readonly migrationId: string;
    readonly productVersion: string;
}


export const HistoryRow: {
    new(migrationId: string, productVersion: string): HistoryRow;
};


export type HistoryRow = HistoryRow$instance;

export interface Migration$instance {
    get activeProvider(): string | undefined;
    set activeProvider(value: string);
    readonly downOperations: IReadOnlyList<MigrationOperation>;
    readonly targetModel: IModel;
    readonly upOperations: IReadOnlyList<MigrationOperation>;
}


export const Migration: {
    readonly initialDatabase: string;
};


export type Migration = Migration$instance;

export interface MigrationAttribute$instance extends Attribute {
    readonly id: string;
}


export const MigrationAttribute: {
    new(id: string): MigrationAttribute;
};


export type MigrationAttribute = MigrationAttribute$instance;

export interface MigrationBuilder$instance {
    readonly activeProvider: string | undefined;
    readonly operations: List<MigrationOperation>;
    addCheckConstraint(name: string, table: string, sql: string, schema?: string): OperationBuilder_1<AddCheckConstraintOperation>;
    addColumn<T>(name: string, table: string, type?: string, unicode?: Nullable<System_Internal.Boolean>, maxLength?: Nullable<System_Internal.Int32>, rowVersion?: boolean, schema?: string, nullable?: boolean, defaultValue?: unknown, defaultValueSql?: string, computedColumnSql?: string, fixedLength?: Nullable<System_Internal.Boolean>, comment?: string, collation?: string, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, stored?: Nullable<System_Internal.Boolean>): OperationBuilder_1<AddColumnOperation>;
    addForeignKey(name: string, table: string, column: string, principalTable: string, schema?: string, principalSchema?: string, principalColumn?: string, onUpdate?: ReferentialAction, onDelete?: ReferentialAction): OperationBuilder_1<AddForeignKeyOperation>;
    addForeignKey(name: string, table: string, columns: string[], principalTable: string, schema?: string, principalSchema?: string, principalColumns?: string[], onUpdate?: ReferentialAction, onDelete?: ReferentialAction): OperationBuilder_1<AddForeignKeyOperation>;
    addPrimaryKey(name: string, table: string, column: string, schema?: string): OperationBuilder_1<AddPrimaryKeyOperation>;
    addPrimaryKey(name: string, table: string, columns: string[], schema?: string): OperationBuilder_1<AddPrimaryKeyOperation>;
    addUniqueConstraint(name: string, table: string, column: string, schema?: string): OperationBuilder_1<AddUniqueConstraintOperation>;
    addUniqueConstraint(name: string, table: string, columns: string[], schema?: string): OperationBuilder_1<AddUniqueConstraintOperation>;
    alterColumn<T>(name: string, table: string, type?: string, unicode?: Nullable<System_Internal.Boolean>, maxLength?: Nullable<System_Internal.Int32>, rowVersion?: boolean, schema?: string, nullable?: boolean, defaultValue?: unknown, defaultValueSql?: string, computedColumnSql?: string, oldClrType?: Type, oldType?: string, oldUnicode?: Nullable<System_Internal.Boolean>, oldMaxLength?: Nullable<System_Internal.Int32>, oldRowVersion?: boolean, oldNullable?: boolean, oldDefaultValue?: unknown, oldDefaultValueSql?: string, oldComputedColumnSql?: string, fixedLength?: Nullable<System_Internal.Boolean>, oldFixedLength?: Nullable<System_Internal.Boolean>, comment?: string, oldComment?: string, collation?: string, oldCollation?: string, precision?: Nullable<System_Internal.Int32>, oldPrecision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>, oldScale?: Nullable<System_Internal.Int32>, stored?: Nullable<System_Internal.Boolean>, oldStored?: Nullable<System_Internal.Boolean>): AlterOperationBuilder_1<AlterColumnOperation>;
    alterDatabase(collation?: string, oldCollation?: string): AlterOperationBuilder_1<AlterDatabaseOperation>;
    alterSequence(name: string, schema?: string, incrementBy?: int, minValue?: Nullable<System_Internal.Int64>, maxValue?: Nullable<System_Internal.Int64>, cyclic?: boolean, oldIncrementBy?: int, oldMinValue?: Nullable<System_Internal.Int64>, oldMaxValue?: Nullable<System_Internal.Int64>, oldCyclic?: boolean): AlterOperationBuilder_1<AlterSequenceOperation>;
    alterTable(name: string, schema?: string, comment?: string, oldComment?: string): AlterOperationBuilder_1<AlterTableOperation>;
    createCheckConstraint(name: string, table: string, sql: string, schema?: string): OperationBuilder_1<AddCheckConstraintOperation>;
    createIndex(name: string, table: string, column: string, schema?: string, unique?: boolean, filter?: string, descending?: boolean[]): OperationBuilder_1<CreateIndexOperation>;
    createIndex(name: string, table: string, columns: string[], schema?: string, unique?: boolean, filter?: string, descending?: boolean[]): OperationBuilder_1<CreateIndexOperation>;
    createSequence(name: string, schema?: string, startValue?: long, incrementBy?: int, minValue?: Nullable<System_Internal.Int64>, maxValue?: Nullable<System_Internal.Int64>, cyclic?: boolean): OperationBuilder_1<CreateSequenceOperation>;
    createTable<TColumns>(name: string, columns: Func<ColumnsBuilder, TColumns>, schema?: string, constraints?: Action<CreateTableBuilder_1<TColumns>>, comment?: string): CreateTableBuilder_1<TColumns>;
    deleteData(table: string, keyColumn: string, keyValue: unknown, schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumn: string, keyColumnType: string, keyValue: unknown, schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumns: string[], keyValues: unknown[], schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumns: string[], keyColumnTypes: string[], keyValues: unknown[], schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumn: string, keyValues: unknown[], schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumn: string, keyColumnType: string, keyValues: unknown[], schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumns: string[], keyValues: Array<Array<unknown>>, schema?: string): OperationBuilder_1<DeleteDataOperation>;
    deleteData(table: string, keyColumns: string[], keyColumnTypes: string[], keyValues: Array<Array<unknown>>, schema?: string): OperationBuilder_1<DeleteDataOperation>;
    dropCheckConstraint(name: string, table: string, schema?: string): OperationBuilder_1<DropCheckConstraintOperation>;
    dropColumn(name: string, table: string, schema?: string): OperationBuilder_1<DropColumnOperation>;
    dropForeignKey(name: string, table: string, schema?: string): OperationBuilder_1<DropForeignKeyOperation>;
    dropIndex(name: string, table?: string, schema?: string): OperationBuilder_1<DropIndexOperation>;
    dropPrimaryKey(name: string, table: string, schema?: string): OperationBuilder_1<DropPrimaryKeyOperation>;
    dropSchema(name: string): OperationBuilder_1<DropSchemaOperation>;
    dropSequence(name: string, schema?: string): OperationBuilder_1<DropSequenceOperation>;
    dropTable(name: string, schema?: string): OperationBuilder_1<DropTableOperation>;
    dropUniqueConstraint(name: string, table: string, schema?: string): OperationBuilder_1<DropUniqueConstraintOperation>;
    ensureSchema(name: string): OperationBuilder_1<EnsureSchemaOperation>;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    insertData(table: string, column: string, value: unknown, schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, column: string, columnType: string, value: unknown, schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, columns: string[], values: unknown[], schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, columns: string[], columnTypes: string[], values: unknown[], schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, column: string, values: unknown[], schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, column: string, columnType: string, values: unknown[], schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, columns: string[], values: Array<Array<unknown>>, schema?: string): OperationBuilder_1<InsertDataOperation>;
    insertData(table: string, columns: string[], columnTypes: string[], values: Array<Array<unknown>>, schema?: string): OperationBuilder_1<InsertDataOperation>;
    renameColumn(name: string, table: string, newName: string, schema?: string): OperationBuilder_1<RenameColumnOperation>;
    renameIndex(name: string, newName: string, table?: string, schema?: string): OperationBuilder_1<RenameIndexOperation>;
    renameSequence(name: string, schema?: string, newName?: string, newSchema?: string): OperationBuilder_1<RenameSequenceOperation>;
    renameTable(name: string, schema?: string, newName?: string, newSchema?: string): OperationBuilder_1<RenameTableOperation>;
    restartSequence(name: string, startValue?: Nullable<System_Internal.Int64>, schema?: string): OperationBuilder_1<RestartSequenceOperation>;
    sql(sql: string, suppressTransaction?: boolean): OperationBuilder_1<SqlOperation>;
    toString(): string;
    updateData(table: string, keyColumn: string, keyValue: unknown, column: string, value: unknown, schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumn: string, keyValue: unknown, columns: string[], values: unknown[], schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyValues: unknown[], column: string, value: unknown, schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyValues: unknown[], columns: string[], values: unknown[], schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyColumnTypes: string[], keyValues: unknown[], columns: string[], columnTypes: string[], values: unknown[], schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumn: string, keyValues: unknown[], column: string, values: unknown[], schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumn: string, keyValues: unknown[], columns: string[], values: Array<Array<unknown>>, schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyValues: Array<Array<unknown>>, column: string, values: unknown[], schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyValues: Array<Array<unknown>>, columns: string[], values: Array<Array<unknown>>, schema?: string): OperationBuilder_1<UpdateDataOperation>;
    updateData(table: string, keyColumns: string[], keyColumnTypes: string[], keyValues: Array<Array<unknown>>, columns: string[], columnTypes: string[], values: Array<Array<unknown>>, schema?: string): OperationBuilder_1<UpdateDataOperation>;
}


export const MigrationBuilder: {
    new(activeProvider: string): MigrationBuilder;
};


export type MigrationBuilder = MigrationBuilder$instance;

export interface MigrationCommand$instance {
    readonly commandLogger: IRelationalCommandDiagnosticsLogger;
    readonly commandText: string;
    readonly transactionSuppressed: boolean;
    executeNonQuery(connection: IRelationalConnection, parameterValues?: IReadOnlyDictionary<System_Internal.String, unknown>): int;
    executeNonQueryAsync(connection: IRelationalConnection, parameterValues?: IReadOnlyDictionary<System_Internal.String, unknown>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export const MigrationCommand: {
    new(relationalCommand: IRelationalCommand, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, transactionSuppressed: boolean): MigrationCommand;
};


export type MigrationCommand = MigrationCommand$instance;

export interface MigrationCommandListBuilder$instance {
    append(o: string): MigrationCommandListBuilder;
    appendLine(): MigrationCommandListBuilder;
    appendLine(value: string): MigrationCommandListBuilder;
    appendLine(value: FormattableString): MigrationCommandListBuilder;
    appendLines(value: string): MigrationCommandListBuilder;
    decrementIndent(): MigrationCommandListBuilder;
    endCommand(suppressTransaction?: boolean): MigrationCommandListBuilder;
    getCommandList(): IReadOnlyList<MigrationCommand>;
    incrementIndent(): MigrationCommandListBuilder;
    indent(): IDisposable;
}


export const MigrationCommandListBuilder: {
    new(dependencies: MigrationsSqlGeneratorDependencies): MigrationCommandListBuilder;
};


export type MigrationCommandListBuilder = MigrationCommandListBuilder$instance;

export interface MigrationExecutionState$instance {
    anyOperationPerformed: boolean;
    get currentMigrationId(): string | undefined;
    set currentMigrationId(value: string);
    get databaseLock(): IMigrationsDatabaseLock | undefined;
    set databaseLock(value: IMigrationsDatabaseLock);
    lastCommittedCommandIndex: int;
    transaction: IDbContextTransaction;
}


export const MigrationExecutionState: {
    new(): MigrationExecutionState;
};


export type MigrationExecutionState = MigrationExecutionState$instance;

export interface MigrationsAnnotationProvider$instance {
    forRemove(model: IRelationalModel): IEnumerable<IAnnotation>;
    forRemove(table: ITable): IEnumerable<IAnnotation>;
    forRemove(column: IColumn): IEnumerable<IAnnotation>;
    forRemove(view: IView): IEnumerable<IAnnotation>;
    forRemove(column: IViewColumn): IEnumerable<IAnnotation>;
    forRemove(constraint: IUniqueConstraint): IEnumerable<IAnnotation>;
    forRemove(index: ITableIndex): IEnumerable<IAnnotation>;
    forRemove(foreignKey: IForeignKeyConstraint): IEnumerable<IAnnotation>;
    forRemove(sequence: ISequence): IEnumerable<IAnnotation>;
    forRemove(checkConstraint: ICheckConstraint): IEnumerable<IAnnotation>;
    forRename(table: ITable): IEnumerable<IAnnotation>;
    forRename(column: IColumn): IEnumerable<IAnnotation>;
    forRename(index: ITableIndex): IEnumerable<IAnnotation>;
    forRename(sequence: ISequence): IEnumerable<IAnnotation>;
}


export const MigrationsAnnotationProvider: {
    new(dependencies: MigrationsAnnotationProviderDependencies): MigrationsAnnotationProvider;
};


export interface __MigrationsAnnotationProvider$views {
    As_IMigrationsAnnotationProvider(): IMigrationsAnnotationProvider$instance;
}

export type MigrationsAnnotationProvider = MigrationsAnnotationProvider$instance & __MigrationsAnnotationProvider$views;


export interface MigrationsAnnotationProviderDependencies$instance {
    _Clone_$(): MigrationsAnnotationProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: MigrationsAnnotationProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MigrationsAnnotationProviderDependencies: {
    new(): MigrationsAnnotationProviderDependencies;
};


export type MigrationsAnnotationProviderDependencies = MigrationsAnnotationProviderDependencies$instance;

export interface MigrationsSqlGenerator$instance {
    generate(operations: IReadOnlyList<MigrationOperation>, model?: IModel, options?: MigrationsSqlGenerationOptions): IReadOnlyList<MigrationCommand>;
}


export const MigrationsSqlGenerator: {
    new(dependencies: MigrationsSqlGeneratorDependencies): MigrationsSqlGenerator;
};


export interface __MigrationsSqlGenerator$views {
    As_IMigrationsSqlGenerator(): IMigrationsSqlGenerator$instance;
}

export interface MigrationsSqlGenerator$instance extends IMigrationsSqlGenerator$instance {}

export type MigrationsSqlGenerator = MigrationsSqlGenerator$instance & __MigrationsSqlGenerator$views;


export interface MigrationsSqlGeneratorDependencies$instance {
    commandBuilderFactory: IRelationalCommandBuilderFactory;
    currentContext: ICurrentDbContext;
    logger: IRelationalCommandDiagnosticsLogger;
    loggingOptions: ILoggingOptions;
    migrationsLogger: IDiagnosticsLogger_1<DbLoggerCategory_Migrations>;
    modificationCommandFactory: IModificationCommandFactory;
    sqlGenerationHelper: ISqlGenerationHelper;
    typeMappingSource: IRelationalTypeMappingSource;
    updateSqlGenerator: IUpdateSqlGenerator;
    _Clone_$(): MigrationsSqlGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: MigrationsSqlGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MigrationsSqlGeneratorDependencies: {
    new(commandBuilderFactory: IRelationalCommandBuilderFactory, updateSqlGenerator: IUpdateSqlGenerator, sqlGenerationHelper: ISqlGenerationHelper, typeMappingSource: IRelationalTypeMappingSource, currentContext: ICurrentDbContext, modificationCommandFactory: IModificationCommandFactory, loggingOptions: ILoggingOptions, logger: IRelationalCommandDiagnosticsLogger, migrationsLogger: IDiagnosticsLogger_1<DbLoggerCategory_Migrations>): MigrationsSqlGeneratorDependencies;
};


export type MigrationsSqlGeneratorDependencies = MigrationsSqlGeneratorDependencies$instance;

export abstract class MigrationsAssemblyExtensions$instance {
    static getMigrationId(assembly: IMigrationsAssembly, nameOrId: string): string;
}


export type MigrationsAssemblyExtensions = MigrationsAssemblyExtensions$instance;

