// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Storage
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { CommandSource, DbCommandMethod, IDiagnosticsLogger_1, ILoggingOptions, IRelationalCommandDiagnosticsLogger, IRelationalConnectionDiagnosticsLogger } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IConcurrencyDetector, ICoreSingletonOptions, ICurrentDbContext, IDbContextOptions, IDbContextOptionsExtension, IInfrastructure_1, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IAdHocMapper, IElementType, IEntityType, IModel, IProperty, IPropertyBase, ITypeMappingConfiguration } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IMigrationCommandExecutor, IMigrationsModelDiffer, IMigrationsSqlGenerator } from "../../Microsoft.EntityFrameworkCore.Migrations/internal/index.js";
import type { IAsyncQueryProvider, IQueryCompilationContextFactory, QueryContext } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { INamedConnectionStringResolver } from "../../Microsoft.EntityFrameworkCore.Storage.Internal/internal/index.js";
import type { IJsonValueReaderWriterSource, JsonValueReaderWriter } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { IValueConverterSelector, ValueConverter, ValueConverterInfo } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { IBatchExecutor, ICommandBatchPreparer, IUpdateAdapterFactory, IUpdateEntry } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { ValueGenerator } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import type { DbContext, DbLoggerCategory_Database_Command, DbLoggerCategory_Database_Transaction, DbLoggerCategory_Infrastructure, DbLoggerCategory_Update } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IEnumerable, IList, IReadOnlyDictionary, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Data_Common_Internal from "@tsonic/dotnet/System.Data.Common.js";
import type { DbCommand, DbConnection, DbDataReader, DbParameter, DbTransaction } from "@tsonic/dotnet/System.Data.Common.js";
import type { DbType, IsolationLevel, ParameterDirection } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Enum, Exception, FormattableString, Func, Guid, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { ConstructorInfo, MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { Transaction } from "@tsonic/dotnet/System.Transactions.js";

export enum StoreTypePostfix {
    none = 0,
    size = 1,
    precision = 2,
    precisionAndScale = 3
}


export interface IDatabase$instance {
    compileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    compileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    saveChanges(entries: IList<IUpdateEntry>): int;
    saveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export type IDatabase = IDatabase$instance;

export interface IDatabaseCreator$instance {
    ensureDeleted(): boolean;
    ensureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export type IDatabaseCreator = IDatabaseCreator$instance;

export interface IDatabaseFacadeDependencies$instance {
    readonly transactionManager: IDbContextTransactionManager;
    readonly databaseCreator: IDatabaseCreator;
    readonly executionStrategy: IExecutionStrategy;
    readonly executionStrategyFactory: IExecutionStrategyFactory;
    readonly databaseProviders: IEnumerable<IDatabaseProvider>;
    readonly commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>;
    readonly concurrencyDetector: IConcurrencyDetector;
    readonly coreOptions: ICoreSingletonOptions;
    readonly queryProvider: IAsyncQueryProvider;
    readonly adHocMapper: IAdHocMapper;
    readonly typeMappingSource: ITypeMappingSource;
}


export type IDatabaseFacadeDependencies = IDatabaseFacadeDependencies$instance;

export interface IDatabaseFacadeDependenciesAccessor$instance {
    readonly dependencies: IDatabaseFacadeDependencies;
    readonly context: DbContext;
}


export type IDatabaseFacadeDependenciesAccessor = IDatabaseFacadeDependenciesAccessor$instance;

export interface IDatabaseProvider$instance {
    readonly name: string;
    readonly version: string | undefined;
    isConfigured(options: IDbContextOptions): boolean;
}


export type IDatabaseProvider = IDatabaseProvider$instance;

export interface IDbContextTransaction$instance extends IDisposable, IAsyncDisposable {
    readonly transactionId: Guid;
    readonly supportsSavepoints: boolean;
    commit(): void;
    commitAsync(cancellationToken?: CancellationToken): Task;
    createSavepoint(name: string): void;
    createSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
}


export type IDbContextTransaction = IDbContextTransaction$instance;

export interface IDbContextTransactionManager$instance extends IResettableService {
    readonly currentTransaction: IDbContextTransaction | undefined;
    beginTransaction(): IDbContextTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    commitTransaction(): void;
    commitTransactionAsync(cancellationToken?: CancellationToken): Task;
    resetState(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
}


export interface IDbContextTransactionManager$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type IDbContextTransactionManager = IDbContextTransactionManager$instance;

export interface IExceptionDetector$instance {
    isCancellation(exception: Exception, cancellationToken?: CancellationToken): boolean;
}


export type IExceptionDetector = IExceptionDetector$instance;

export interface IExecutionStrategy$instance {
    readonly retriesOnFailure: boolean;
    execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    executeAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export type IExecutionStrategy = IExecutionStrategy$instance;

export interface IExecutionStrategyFactory$instance {
    create(): IExecutionStrategy;
}


export type IExecutionStrategyFactory = IExecutionStrategyFactory$instance;

export interface IParameterNameGeneratorFactory$instance {
    create(): ParameterNameGenerator;
}


export type IParameterNameGeneratorFactory = IParameterNameGeneratorFactory$instance;

export interface IRawSqlCommandBuilder$instance {
    build(sql: string, parameters: IEnumerable<unknown>, model: IModel): RawSqlCommand;
    build(sql: string, parameters: IEnumerable<unknown>): RawSqlCommand;
    build(sql: string): IRelationalCommand;
}


export type IRawSqlCommandBuilder = IRawSqlCommandBuilder$instance;

export interface IRelationalCommand$instance extends IRelationalCommandTemplate {
    readonly commandText: string;
    readonly logCommandText: string;
    readonly parameters: IReadOnlyList<IRelationalParameter>;
    createDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
    executeNonQuery(parameterObject: RelationalCommandParameterObject): int;
    executeNonQueryAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    executeReader(parameterObject: RelationalCommandParameterObject): RelationalDataReader;
    executeScalar(parameterObject: RelationalCommandParameterObject): unknown | undefined;
    populateFrom(commandTemplate: IRelationalCommandTemplate): void;
}


export interface IRelationalCommand$instance extends IRelationalCommandTemplate$instance {}

export type IRelationalCommand = IRelationalCommand$instance;

export interface IRelationalCommandBuilder$instance {
    readonly parameters: IReadOnlyList<IRelationalParameter>;
    readonly typeMappingSource: IRelationalTypeMappingSource;
    readonly commandTextLength: int;
    addParameter(parameter: IRelationalParameter): IRelationalCommandBuilder;
    append(value: FormattableString, sensitive?: boolean): IRelationalCommandBuilder;
    append(value: string, sensitive?: boolean): IRelationalCommandBuilder;
    appendLine(): IRelationalCommandBuilder;
    build(): IRelationalCommand;
    removeParameterAt(index: int): IRelationalCommandBuilder;
}


export type IRelationalCommandBuilder = IRelationalCommandBuilder$instance;

export interface IRelationalCommandBuilderFactory$instance {
    create(): IRelationalCommandBuilder;
}


export type IRelationalCommandBuilderFactory = IRelationalCommandBuilderFactory$instance;

export interface IRelationalCommandTemplate$instance {
    readonly commandText: string;
    readonly logCommandText: string;
    readonly parameters: IReadOnlyList<IRelationalParameter>;
    createDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
}


export type IRelationalCommandTemplate = IRelationalCommandTemplate$instance;

export interface IRelationalConnection$instance extends IRelationalTransactionManager, IDbContextTransactionManager, IResettableService, IDisposable, IAsyncDisposable {
    get connectionString(): string | undefined;
    set connectionString(value: string);
    dbConnection: DbConnection;
    readonly context: DbContext;
    readonly connectionId: Guid;
    commandTimeout: Nullable<System_Internal.Int32>;
    readonly currentTransaction: IDbContextTransaction | undefined;
    beginTransaction(): IDbContextTransaction;
    beginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    beginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    close(): boolean;
    closeAsync(): Task<System_Internal.Boolean>;
    commitTransaction(): void;
    commitTransactionAsync(cancellationToken?: CancellationToken): Task;
    open(errorsExpected?: boolean): boolean;
    openAsync(cancellationToken: CancellationToken, errorsExpected?: boolean): Task<System_Internal.Boolean>;
    rentCommand(): IRelationalCommand;
    returnCommand(command: IRelationalCommand): void;
    setDbConnection(value: DbConnection, contextOwnsConnection: boolean): void;
    useTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    useTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    useTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    useTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    resetState(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
}


export type IRelationalConnection = IRelationalConnection$instance;

export interface IRelationalDatabaseCreator$instance extends IDatabaseCreator {
    create(): void;
    createAsync(cancellationToken?: CancellationToken): Task;
    exists(): boolean;
    existsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    generateCreateScript(): string;
    ensureDeleted(): boolean;
    ensureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export interface IRelationalDatabaseCreator$instance extends IDatabaseCreator$instance {}

export type IRelationalDatabaseCreator = IRelationalDatabaseCreator$instance;

export interface IRelationalDatabaseFacadeDependencies$instance extends IDatabaseFacadeDependencies {
    readonly relationalConnection: IRelationalConnection;
    readonly rawSqlCommandBuilder: IRawSqlCommandBuilder;
    readonly commandLogger: IRelationalCommandDiagnosticsLogger;
    readonly transactionManager: IDbContextTransactionManager;
    readonly databaseCreator: IDatabaseCreator;
    readonly executionStrategy: IExecutionStrategy;
    readonly executionStrategyFactory: IExecutionStrategyFactory;
    readonly databaseProviders: IEnumerable<IDatabaseProvider>;
    readonly concurrencyDetector: IConcurrencyDetector;
    readonly coreOptions: ICoreSingletonOptions;
    readonly queryProvider: IAsyncQueryProvider;
    readonly adHocMapper: IAdHocMapper;
    readonly typeMappingSource: ITypeMappingSource;
}


export type IRelationalDatabaseFacadeDependencies = IRelationalDatabaseFacadeDependencies$instance;

export interface IRelationalParameter$instance {
    readonly invariantName: string;
    addDbParameter(command: DbCommand, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    addDbParameter(command: DbCommand, value: unknown): void;
}


export type IRelationalParameter = IRelationalParameter$instance;

export interface IRelationalTransactionFactory$instance {
    create(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean): RelationalTransaction;
}


export type IRelationalTransactionFactory = IRelationalTransactionFactory$instance;

export interface IRelationalTransactionManager$instance extends IDbContextTransactionManager, IResettableService {
    readonly currentTransaction: IDbContextTransaction | undefined;
    beginTransaction(): IDbContextTransaction;
    beginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    beginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    commitTransaction(): void;
    commitTransactionAsync(cancellationToken?: CancellationToken): Task;
    useTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    useTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    useTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    useTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    resetState(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
}


export type IRelationalTransactionManager = IRelationalTransactionManager$instance;

export interface IRelationalTypeMappingSource$instance extends ITypeMappingSource {
    findMapping(elementType: IElementType): CoreTypeMapping | undefined;
    findMapping(property: IProperty): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo): CoreTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    findMapping(type: Type): CoreTypeMapping | undefined;
    findMapping(property: IProperty): RelationalTypeMapping | undefined;
    findMapping(member: MemberInfo): RelationalTypeMapping | undefined;
    findMapping(storeTypeName: string): RelationalTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): RelationalTypeMapping | undefined;
    findMapping(type: Type, storeTypeName: string, keyOrIndex?: boolean, unicode?: Nullable<System_Internal.Boolean>, size?: Nullable<System_Internal.Int32>, rowVersion?: Nullable<System_Internal.Boolean>, fixedLength?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>): RelationalTypeMapping | undefined;
    findMapping(type: Type): RelationalTypeMapping | undefined;
}


export type IRelationalTypeMappingSource = IRelationalTypeMappingSource$instance;

export interface IRelationalTypeMappingSourcePlugin$instance {
    findMapping(mappingInfo: RelationalTypeMappingInfo): RelationalTypeMapping | undefined;
}


export type IRelationalTypeMappingSourcePlugin = IRelationalTypeMappingSourcePlugin$instance;

export interface ISqlGenerationHelper$instance {
    readonly statementTerminator: string;
    readonly batchTerminator: string;
    readonly startTransactionStatement: string;
    readonly commitTransactionStatement: string;
    readonly singleLineCommentToken: string;
    delimitIdentifier(name: string, schema: string): string;
    delimitIdentifier(builder: StringBuilder, name: string, schema: string): void;
    generateParameterName(name: string): string;
    generateParameterName(builder: StringBuilder, name: string): void;
}


export type ISqlGenerationHelper = ISqlGenerationHelper$instance;

export interface ITransactionEnlistmentManager$instance {
    readonly currentAmbientTransaction: Transaction | undefined;
    readonly enlistedTransaction: Transaction | undefined;
    enlistTransaction(transaction: Transaction): void;
}


export type ITransactionEnlistmentManager = ITransactionEnlistmentManager$instance;

export interface ITypeMappingSource$instance {
    findMapping(elementType: IElementType): CoreTypeMapping | undefined;
    findMapping(property: IProperty): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo): CoreTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    findMapping(type: Type): CoreTypeMapping | undefined;
}


export type ITypeMappingSource = ITypeMappingSource$instance;

export interface ITypeMappingSourcePlugin$instance {
    findMapping(mappingInfo: TypeMappingInfo): CoreTypeMapping | undefined;
}


export type ITypeMappingSourcePlugin = ITypeMappingSourcePlugin$instance;

export interface MaterializationContext$instance {
    readonly context: DbContext;
    readonly valueBuffer: ValueBuffer;
}


export const MaterializationContext: {
    new(valueBuffer: ValueBuffer, context: DbContext): MaterializationContext;
    readonly getValueBufferMethod: MethodInfo;
};


export type MaterializationContext = MaterializationContext$instance;

export interface RelationalCommandParameterObject$instance {
    readonly commandSource: CommandSource;
    readonly connection: IRelationalConnection;
    readonly context: DbContext;
    readonly detailedErrorsEnabled: boolean;
    readonly logger: IRelationalCommandDiagnosticsLogger;
    readonly parameterValues: IReadOnlyDictionary<System_Internal.String, unknown | undefined> | undefined;
    readonly readerColumns: IReadOnlyList<ReaderColumn | undefined> | undefined;
    equals(obj: unknown): boolean;
    equals(other: RelationalCommandParameterObject): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const RelationalCommandParameterObject: {
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, commandSource: CommandSource): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, detailedErrorsEnabled: boolean): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, detailedErrorsEnabled: boolean, commandSource: CommandSource): RelationalCommandParameterObject;
};


export type RelationalCommandParameterObject = RelationalCommandParameterObject$instance;

export interface RelationalTypeMappingInfo$instance {
    clrType: Type;
    readonly coreTypeMappingInfo: TypeMappingInfo;
    dbType: Nullable<DbType>;
    get elementTypeMapping(): RelationalTypeMapping | undefined;
    set elementTypeMapping(value: RelationalTypeMapping);
    isFixedLength: Nullable<System_Internal.Boolean>;
    isKey: boolean;
    isKeyOrIndex: boolean;
    isRowVersion: Nullable<System_Internal.Boolean>;
    isUnicode: Nullable<System_Internal.Boolean>;
    get jsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    set jsonValueReaderWriter(value: JsonValueReaderWriter);
    precision: Nullable<System_Internal.Int32>;
    scale: Nullable<System_Internal.Int32>;
    size: Nullable<System_Internal.Int32>;
    get storeTypeName(): string | undefined;
    set storeTypeName(value: string);
    get storeTypeNameBase(): string | undefined;
    set storeTypeNameBase(value: string);
    equals(obj: unknown): boolean;
    equals(other: RelationalTypeMappingInfo): boolean;
    getHashCode(): int;
    toString(): string | undefined;
    withConverter(converterInfo: ValueConverterInfo): RelationalTypeMappingInfo;
}


export const RelationalTypeMappingInfo: {
    new(property: IProperty): RelationalTypeMappingInfo;
    new(elementType: IElementType, storeTypeName: string, storeTypeNameBase: string, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackFixedLength: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(principals: IReadOnlyList<IProperty>, storeTypeName: string, storeTypeNameBase: string, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackFixedLength: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(member: MemberInfo, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(source: RelationalTypeMappingInfo, converter: ValueConverterInfo): RelationalTypeMappingInfo;
    new(type: Type, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, keyOrIndex: boolean, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, rowVersion: Nullable<System_Internal.Boolean>, fixedLength: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, dbType: Nullable<DbType>, key: boolean): RelationalTypeMappingInfo;
    new(type: Type, typeMappingConfiguration: ITypeMappingConfiguration, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
};


export type RelationalTypeMappingInfo = RelationalTypeMappingInfo$instance;

export interface TypeMappingInfo$instance {
    clrType: Type;
    get elementTypeMapping(): CoreTypeMapping | undefined;
    set elementTypeMapping(value: CoreTypeMapping);
    isKey: boolean;
    isKeyOrIndex: boolean;
    isRowVersion: Nullable<System_Internal.Boolean>;
    isUnicode: Nullable<System_Internal.Boolean>;
    get jsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    set jsonValueReaderWriter(value: JsonValueReaderWriter);
    precision: Nullable<System_Internal.Int32>;
    scale: Nullable<System_Internal.Int32>;
    size: Nullable<System_Internal.Int32>;
    equals(obj: unknown): boolean;
    equals(other: TypeMappingInfo): boolean;
    getHashCode(): int;
    toString(): string | undefined;
    withConverter(converterInfo: ValueConverterInfo): TypeMappingInfo;
}


export const TypeMappingInfo: {
    new(property: IProperty): TypeMappingInfo;
    new(elementType: IElementType, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(principals: IReadOnlyList<IProperty>, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(member: MemberInfo, elementTypeMapping: CoreTypeMapping, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(type: Type, typeMappingConfiguration: ITypeMappingConfiguration, elementTypeMapping: CoreTypeMapping): TypeMappingInfo;
    new(type: Type, elementTypeMapping: CoreTypeMapping, keyOrIndex: boolean, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, rowVersion: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, key: boolean): TypeMappingInfo;
    new(source: TypeMappingInfo, converter: ValueConverterInfo, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): TypeMappingInfo;
};


export type TypeMappingInfo = TypeMappingInfo$instance;

export interface ValueBuffer$instance {
    readonly count: int;
    readonly isEmpty: boolean;
    item: unknown;
    equals(obj: unknown): boolean;
    equals(other: ValueBuffer): boolean;
    getHashCode(): int;
}


export const ValueBuffer: {
    new(values: unknown[]): ValueBuffer;
    readonly empty: ValueBuffer;
};


export type ValueBuffer = ValueBuffer$instance;

export interface BoolTypeMapping$instance extends RelationalTypeMapping {
}


export const BoolTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): BoolTypeMapping;
    readonly default: BoolTypeMapping;
};


export type BoolTypeMapping = BoolTypeMapping$instance;

export interface ByteArrayTypeMapping$instance extends RelationalTypeMapping {
}


export const ByteArrayTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, size: Nullable<System_Internal.Int32>): ByteArrayTypeMapping;
    readonly default: ByteArrayTypeMapping;
};


export type ByteArrayTypeMapping = ByteArrayTypeMapping$instance;

export interface ByteTypeMapping$instance extends RelationalTypeMapping {
}


export const ByteTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ByteTypeMapping;
    readonly default: ByteTypeMapping;
};


export type ByteTypeMapping = ByteTypeMapping$instance;

export interface CharTypeMapping$instance extends RelationalTypeMapping {
}


export const CharTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): CharTypeMapping;
    readonly default: CharTypeMapping;
};


export type CharTypeMapping = CharTypeMapping$instance;

export interface CoreTypeMapping$instance {
    readonly clrType: Type;
    readonly comparer: ValueComparer;
    readonly converter: ValueConverter | undefined;
    readonly elementTypeMapping: CoreTypeMapping | undefined;
    readonly jsonValueReaderWriter: JsonValueReaderWriter | undefined;
    readonly keyComparer: ValueComparer;
    readonly providerValueComparer: ValueComparer;
    readonly valueGeneratorFactory: Func<IProperty, IEntityType, ValueGenerator> | undefined;
    clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    generateCodeLiteral(value: unknown): Expression;
    withComposedConverter(converter: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const CoreTypeMapping: {
};


export type CoreTypeMapping = CoreTypeMapping$instance;

export interface Database$instance {
    compileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    compileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    saveChanges(entries: IList<IUpdateEntry>): int;
    saveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export const Database: {
};


export interface __Database$views {
    As_IDatabase(): IDatabase$instance;
}

export interface Database$instance extends IDatabase$instance {}

export type Database = Database$instance & __Database$views;


export interface DatabaseDependencies$instance {
    readonly logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    queryCompilationContextFactory: IQueryCompilationContextFactory;
    updateAdapterFactory: IUpdateAdapterFactory;
    _Clone_$(): DatabaseDependencies;
    equals(obj: unknown): boolean;
    equals(other: DatabaseDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const DatabaseDependencies: {
    new(queryCompilationContextFactory: IQueryCompilationContextFactory, updateAdapterFactory: IUpdateAdapterFactory, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): DatabaseDependencies;
};


export type DatabaseDependencies = DatabaseDependencies$instance;

export interface DatabaseProvider_1$instance<TOptionsExtension extends IDbContextOptionsExtension> {
    readonly name: string;
    readonly version: string | undefined;
    isConfigured(options: IDbContextOptions): boolean;
}


export const DatabaseProvider_1: {
    new<TOptionsExtension extends IDbContextOptionsExtension>(dependencies: DatabaseProviderDependencies): DatabaseProvider_1<TOptionsExtension>;
};


export interface __DatabaseProvider_1$views<TOptionsExtension extends IDbContextOptionsExtension> {
    As_IDatabaseProvider(): IDatabaseProvider$instance;
}

export interface DatabaseProvider_1$instance<TOptionsExtension extends IDbContextOptionsExtension> extends IDatabaseProvider$instance {}

export type DatabaseProvider_1<TOptionsExtension extends IDbContextOptionsExtension> = DatabaseProvider_1$instance<TOptionsExtension> & __DatabaseProvider_1$views<TOptionsExtension>;


export interface DatabaseProviderDependencies$instance {
    _Clone_$(): DatabaseProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: DatabaseProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const DatabaseProviderDependencies: {
    new(): DatabaseProviderDependencies;
};


export type DatabaseProviderDependencies = DatabaseProviderDependencies$instance;

export interface DateOnlyTypeMapping$instance extends RelationalTypeMapping {
}


export const DateOnlyTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateOnlyTypeMapping;
    readonly default: DateOnlyTypeMapping;
};


export type DateOnlyTypeMapping = DateOnlyTypeMapping$instance;

export interface DateTimeOffsetTypeMapping$instance extends RelationalTypeMapping {
}


export const DateTimeOffsetTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateTimeOffsetTypeMapping;
    readonly default: DateTimeOffsetTypeMapping;
};


export type DateTimeOffsetTypeMapping = DateTimeOffsetTypeMapping$instance;

export interface DateTimeTypeMapping$instance extends RelationalTypeMapping {
}


export const DateTimeTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateTimeTypeMapping;
    readonly default: DateTimeTypeMapping;
};


export type DateTimeTypeMapping = DateTimeTypeMapping$instance;

export interface DecimalTypeMapping$instance extends RelationalTypeMapping {
}


export const DecimalTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): DecimalTypeMapping;
    readonly default: DecimalTypeMapping;
};


export type DecimalTypeMapping = DecimalTypeMapping$instance;

export interface DoubleTypeMapping$instance extends RelationalTypeMapping {
}


export const DoubleTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DoubleTypeMapping;
    readonly default: DoubleTypeMapping;
};


export type DoubleTypeMapping = DoubleTypeMapping$instance;

export interface ExecutionResult_1$instance<TResult> {
    readonly isSuccessful: boolean;
    readonly result: TResult;
}


export const ExecutionResult_1: {
    new<TResult>(successful: boolean, result: TResult): ExecutionResult_1<TResult>;
};


export type ExecutionResult_1<TResult> = ExecutionResult_1$instance<TResult>;

export interface ExecutionStrategy$instance {
    readonly maxRetryCount: int;
    readonly maxRetryDelay: TimeSpan;
    readonly retriesOnFailure: boolean;
    execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    executeAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export const ExecutionStrategy: {
    readonly current: ExecutionStrategy | undefined;
    callOnWrappedException<TResult>(exception: Exception, exceptionHandler: Func<Exception, TResult>): TResult;
};


export interface __ExecutionStrategy$views {
    As_IExecutionStrategy(): IExecutionStrategy$instance;
}

export interface ExecutionStrategy$instance extends IExecutionStrategy$instance {}

export type ExecutionStrategy = ExecutionStrategy$instance & __ExecutionStrategy$views;


export interface ExecutionStrategyDependencies$instance {
    currentContext: ICurrentDbContext;
    logger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
    options: IDbContextOptions;
    _Clone_$(): ExecutionStrategyDependencies;
    equals(obj: unknown): boolean;
    equals(other: ExecutionStrategyDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ExecutionStrategyDependencies: {
    new(currentContext: ICurrentDbContext, options: IDbContextOptions, logger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>): ExecutionStrategyDependencies;
};


export type ExecutionStrategyDependencies = ExecutionStrategyDependencies$instance;

export interface FloatTypeMapping$instance extends RelationalTypeMapping {
}


export const FloatTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): FloatTypeMapping;
    readonly default: FloatTypeMapping;
};


export type FloatTypeMapping = FloatTypeMapping$instance;

export interface GuidTypeMapping$instance extends RelationalTypeMapping {
}


export const GuidTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): GuidTypeMapping;
    readonly default: GuidTypeMapping;
};


export type GuidTypeMapping = GuidTypeMapping$instance;

export interface IntTypeMapping$instance extends RelationalTypeMapping {
}


export const IntTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): IntTypeMapping;
    readonly default: IntTypeMapping;
};


export type IntTypeMapping = IntTypeMapping$instance;

export interface JsonTypeMapping$instance extends RelationalTypeMapping {
}


export const JsonTypeMapping: {
};


export type JsonTypeMapping = JsonTypeMapping$instance;

export interface JsonTypePlaceholder$instance {
}


export const JsonTypePlaceholder: {
    new(): JsonTypePlaceholder;
};


export type JsonTypePlaceholder = JsonTypePlaceholder$instance;

export interface LongTypeMapping$instance extends RelationalTypeMapping {
}


export const LongTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): LongTypeMapping;
    readonly default: LongTypeMapping;
};


export type LongTypeMapping = LongTypeMapping$instance;

export interface NonRetryingExecutionStrategy$instance {
    readonly retriesOnFailure: boolean;
    execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    executeAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export const NonRetryingExecutionStrategy: {
    new(dependencies: ExecutionStrategyDependencies): NonRetryingExecutionStrategy;
    new(context: DbContext): NonRetryingExecutionStrategy;
};


export interface __NonRetryingExecutionStrategy$views {
    As_IExecutionStrategy(): IExecutionStrategy$instance;
}

export interface NonRetryingExecutionStrategy$instance extends IExecutionStrategy$instance {}

export type NonRetryingExecutionStrategy = NonRetryingExecutionStrategy$instance & __NonRetryingExecutionStrategy$views;


export interface ParameterNameGenerator$instance {
    generateNext(): string;
    reset(): void;
}


export const ParameterNameGenerator: {
    new(): ParameterNameGenerator;
};


export type ParameterNameGenerator = ParameterNameGenerator$instance;

export interface ParameterNameGeneratorDependencies$instance {
    _Clone_$(): ParameterNameGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: ParameterNameGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ParameterNameGeneratorDependencies: {
    new(): ParameterNameGeneratorDependencies;
};


export type ParameterNameGeneratorDependencies = ParameterNameGeneratorDependencies$instance;

export interface ParameterNameGeneratorFactory$instance {
    create(): ParameterNameGenerator;
}


export const ParameterNameGeneratorFactory: {
    new(dependencies: ParameterNameGeneratorDependencies): ParameterNameGeneratorFactory;
};


export interface __ParameterNameGeneratorFactory$views {
    As_IParameterNameGeneratorFactory(): IParameterNameGeneratorFactory$instance;
}

export interface ParameterNameGeneratorFactory$instance extends IParameterNameGeneratorFactory$instance {}

export type ParameterNameGeneratorFactory = ParameterNameGeneratorFactory$instance & __ParameterNameGeneratorFactory$views;


export interface RawSqlCommand$instance {
    readonly parameterValues: IReadOnlyDictionary<System_Internal.String, unknown | undefined>;
    readonly relationalCommand: IRelationalCommand;
}


export const RawSqlCommand: {
    new(relationalCommand: IRelationalCommand, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>): RawSqlCommand;
};


export type RawSqlCommand = RawSqlCommand$instance;

export interface ReaderColumn$instance {
    readonly getFieldValueExpression: LambdaExpression;
    readonly isNullable: boolean;
    readonly name: string;
    readonly property: IPropertyBase;
    readonly type: Type;
}


export const ReaderColumn: {
    create(type: Type, nullable: boolean, columnName: string, property: IPropertyBase, readFunc: LambdaExpression): ReaderColumn;
    getConstructor(type: Type): ConstructorInfo;
};


export type ReaderColumn = ReaderColumn$instance;

export interface ReaderColumn_1$instance<T> extends ReaderColumn {
    readonly getFieldValue: Func<DbDataReader, int[], T>;
}


export const ReaderColumn_1: {
    new<T>(nullable: boolean, name: string, property: IPropertyBase, getFieldValueExpression: Expression<Func<DbDataReader, int[], T>>): ReaderColumn_1<T>;
};


export type ReaderColumn_1<T> = ReaderColumn_1$instance<T>;

export interface RelationalCommand$instance {
    readonly commandText: string;
    readonly logCommandText: string;
    readonly parameters: IReadOnlyList<IRelationalParameter>;
    createDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
    executeNonQuery(parameterObject: RelationalCommandParameterObject): int;
    executeNonQueryAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    executeReader(parameterObject: RelationalCommandParameterObject): RelationalDataReader;
    executeReaderAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<RelationalDataReader>;
    executeScalar(parameterObject: RelationalCommandParameterObject): unknown | undefined;
    executeScalarAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<unknown | undefined>;
    populateFrom(commandTemplate: IRelationalCommandTemplate): void;
}


export const RelationalCommand: {
    new(dependencies: RelationalCommandBuilderDependencies, commandText: string, logCommandText: string, parameters: IReadOnlyList<IRelationalParameter>): RelationalCommand;
};


export interface __RelationalCommand$views {
    As_IRelationalCommand(): IRelationalCommand$instance;
    As_IRelationalCommandTemplate(): IRelationalCommandTemplate$instance;
}

export type RelationalCommand = RelationalCommand$instance & __RelationalCommand$views;


export interface RelationalCommandBuilder$instance {
    readonly commandTextLength: int;
    readonly parameters: IReadOnlyList<IRelationalParameter>;
    readonly typeMappingSource: IRelationalTypeMappingSource;
    addParameter(parameter: IRelationalParameter): IRelationalCommandBuilder;
    append(value: string, sensitive?: boolean): IRelationalCommandBuilder;
    append(value: FormattableString, sensitive?: boolean): IRelationalCommandBuilder;
    appendLine(): IRelationalCommandBuilder;
    build(): IRelationalCommand;
    decrementIndent(): IRelationalCommandBuilder;
    incrementIndent(): IRelationalCommandBuilder;
    removeParameterAt(index: int): IRelationalCommandBuilder;
    toString(): string;
}


export const RelationalCommandBuilder: {
    new(dependencies: RelationalCommandBuilderDependencies): RelationalCommandBuilder;
};


export interface __RelationalCommandBuilder$views {
    As_IRelationalCommandBuilder(): IRelationalCommandBuilder$instance;
}

export type RelationalCommandBuilder = RelationalCommandBuilder$instance & __RelationalCommandBuilder$views;


export interface RelationalCommandBuilderDependencies$instance {
    exceptionDetector: IExceptionDetector;
    loggingOptions: ILoggingOptions;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalCommandBuilderDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalCommandBuilderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalCommandBuilderDependencies: {
    new(typeMappingSource: IRelationalTypeMappingSource, exceptionDetector: IExceptionDetector, loggingOptions: ILoggingOptions): RelationalCommandBuilderDependencies;
};


export type RelationalCommandBuilderDependencies = RelationalCommandBuilderDependencies$instance;

export interface RelationalCommandBuilderFactory$instance {
    create(): IRelationalCommandBuilder;
}


export const RelationalCommandBuilderFactory: {
    new(dependencies: RelationalCommandBuilderDependencies): RelationalCommandBuilderFactory;
};


export interface __RelationalCommandBuilderFactory$views {
    As_IRelationalCommandBuilderFactory(): IRelationalCommandBuilderFactory$instance;
}

export interface RelationalCommandBuilderFactory$instance extends IRelationalCommandBuilderFactory$instance {}

export type RelationalCommandBuilderFactory = RelationalCommandBuilderFactory$instance & __RelationalCommandBuilderFactory$views;


export interface RelationalConnection$instance {
    commandTimeout: Nullable<System_Internal.Int32>;
    readonly connectionId: Guid;
    get connectionString(): string | undefined;
    set connectionString(value: string);
    readonly context: DbContext;
    readonly currentAmbientTransaction: Transaction | undefined;
    readonly currentTransaction: IDbContextTransaction | undefined;
    dbConnection: DbConnection;
    readonly enlistedTransaction: Transaction | undefined;
    beginTransaction(): IDbContextTransaction;
    beginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    beginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    beginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    close(): boolean;
    closeAsync(): Task<System_Internal.Boolean>;
    commitTransaction(): void;
    commitTransactionAsync(cancellationToken?: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    enlistTransaction(transaction: Transaction): void;
    open(errorsExpected?: boolean): boolean;
    openAsync(cancellationToken: CancellationToken, errorsExpected?: boolean): Task<System_Internal.Boolean>;
    rentCommand(): IRelationalCommand;
    returnCommand(command: IRelationalCommand): void;
    rollbackTransaction(): void;
    rollbackTransactionAsync(cancellationToken?: CancellationToken): Task;
    setDbConnection(value: DbConnection, contextOwnsConnection: boolean): void;
    useTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    useTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    useTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    useTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
}


export const RelationalConnection: {
};


export interface __RelationalConnection$views {
    As_IResettableService(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance;
    As_IDbContextTransactionManager(): IDbContextTransactionManager$instance;
    As_ITransactionEnlistmentManager(): ITransactionEnlistmentManager$instance;
    As_IRelationalConnection(): IRelationalConnection$instance;
    As_IRelationalTransactionManager(): IRelationalTransactionManager$instance;
}

export interface RelationalConnection$instance extends ITransactionEnlistmentManager$instance {}

export type RelationalConnection = RelationalConnection$instance & __RelationalConnection$views;


export interface RelationalConnectionDependencies$instance {
    connectionLogger: IRelationalConnectionDiagnosticsLogger;
    connectionStringResolver: INamedConnectionStringResolver;
    contextOptions: IDbContextOptions;
    currentContext: ICurrentDbContext;
    exceptionDetector: IExceptionDetector;
    relationalCommandBuilderFactory: IRelationalCommandBuilderFactory;
    relationalTransactionFactory: IRelationalTransactionFactory;
    transactionLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>;
    _Clone_$(): RelationalConnectionDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalConnectionDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalConnectionDependencies: {
    new(contextOptions: IDbContextOptions, transactionLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, connectionLogger: IRelationalConnectionDiagnosticsLogger, connectionStringResolver: INamedConnectionStringResolver, relationalTransactionFactory: IRelationalTransactionFactory, currentContext: ICurrentDbContext, relationalCommandBuilderFactory: IRelationalCommandBuilderFactory, exceptionDetector: IExceptionDetector): RelationalConnectionDependencies;
};


export type RelationalConnectionDependencies = RelationalConnectionDependencies$instance;

export interface RelationalDatabase$instance extends Database$instance {
    compileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    compileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    saveChanges(entries: IList<IUpdateEntry>): int;
    saveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export const RelationalDatabase: {
    new(dependencies: DatabaseDependencies, relationalDependencies: RelationalDatabaseDependencies): RelationalDatabase;
};


export interface __RelationalDatabase$views {
    As_IDatabase(): IDatabase$instance;
}

export type RelationalDatabase = RelationalDatabase$instance & __RelationalDatabase$views;


export interface RelationalDatabaseCreator$instance {
    canConnect(): boolean;
    canConnectAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    create(): void;
    createAsync(cancellationToken?: CancellationToken): Task;
    createTables(): void;
    createTablesAsync(cancellationToken?: CancellationToken): Task;
    delete(): void;
    deleteAsync(cancellationToken?: CancellationToken): Task;
    ensureCreated(): boolean;
    ensureCreatedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    ensureDeleted(): boolean;
    ensureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    exists(): boolean;
    existsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    generateCreateScript(): string;
    hasTables(): boolean;
    hasTablesAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export const RelationalDatabaseCreator: {
};


export interface __RelationalDatabaseCreator$views {
    As_IDatabaseCreator(): IDatabaseCreator$instance;
    As_IRelationalDatabaseCreator(): IRelationalDatabaseCreator$instance;
}

export interface RelationalDatabaseCreator$instance extends IRelationalDatabaseCreator$instance {}

export type RelationalDatabaseCreator = RelationalDatabaseCreator$instance & __RelationalDatabaseCreator$views;


export interface RelationalDatabaseCreatorDependencies$instance {
    commandLogger: IRelationalCommandDiagnosticsLogger;
    connection: IRelationalConnection;
    contextOptions: IDbContextOptions;
    currentContext: ICurrentDbContext;
    exceptionDetector: IExceptionDetector;
    readonly executionStrategy: IExecutionStrategy;
    migrationCommandExecutor: IMigrationCommandExecutor;
    migrationsSqlGenerator: IMigrationsSqlGenerator;
    modelDiffer: IMigrationsModelDiffer;
    sqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): RelationalDatabaseCreatorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalDatabaseCreatorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalDatabaseCreatorDependencies: {
    new(connection: IRelationalConnection, modelDiffer: IMigrationsModelDiffer, migrationsSqlGenerator: IMigrationsSqlGenerator, migrationCommandExecutor: IMigrationCommandExecutor, sqlGenerationHelper: ISqlGenerationHelper, executionStrategy: IExecutionStrategy, currentContext: ICurrentDbContext, contextOptions: IDbContextOptions, commandLogger: IRelationalCommandDiagnosticsLogger, exceptionDetector: IExceptionDetector): RelationalDatabaseCreatorDependencies;
};


export type RelationalDatabaseCreatorDependencies = RelationalDatabaseCreatorDependencies$instance;

export interface RelationalDatabaseDependencies$instance {
    batchExecutor: IBatchExecutor;
    batchPreparer: ICommandBatchPreparer;
    connection: IRelationalConnection;
    _Clone_$(): RelationalDatabaseDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalDatabaseDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalDatabaseDependencies: {
    new(batchPreparer: ICommandBatchPreparer, batchExecutor: IBatchExecutor, connection: IRelationalConnection): RelationalDatabaseDependencies;
};


export type RelationalDatabaseDependencies = RelationalDatabaseDependencies$instance;

export interface RelationalDataReader$instance {
    readonly commandId: Guid;
    readonly dbCommand: DbCommand;
    readonly dbDataReader: DbDataReader;
    readonly relationalConnection: IRelationalConnection;
    close(): void;
    closeAsync(): ValueTask;
    dispose(): void;
    disposeAsync(): ValueTask;
    initialize(relationalConnection: IRelationalConnection, command: DbCommand, reader: DbDataReader, commandId: Guid, logger: IRelationalCommandDiagnosticsLogger): void;
    read(): boolean;
    readAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export const RelationalDataReader: {
    new(): RelationalDataReader;
};


export type RelationalDataReader = RelationalDataReader$instance;

export interface RelationalExecutionStrategyFactory$instance {
    create(): IExecutionStrategy;
}


export const RelationalExecutionStrategyFactory: {
    new(dependencies: ExecutionStrategyDependencies): RelationalExecutionStrategyFactory;
};


export interface __RelationalExecutionStrategyFactory$views {
    As_IExecutionStrategyFactory(): IExecutionStrategyFactory$instance;
}

export interface RelationalExecutionStrategyFactory$instance extends IExecutionStrategyFactory$instance {}

export type RelationalExecutionStrategyFactory = RelationalExecutionStrategyFactory$instance & __RelationalExecutionStrategyFactory$views;


export interface RelationalGeometryTypeMapping_2$instance<TGeometry, TProvider> extends RelationalTypeMapping {
    createParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    createParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    customizeDataReaderExpression(expression: Expression): Expression;
    generateCodeLiteral(value: unknown): Expression;
}


export const RelationalGeometryTypeMapping_2: {
};


export type RelationalGeometryTypeMapping_2<TGeometry, TProvider> = RelationalGeometryTypeMapping_2$instance<TGeometry, TProvider>;

export interface RelationalSqlGenerationHelper$instance {
    readonly batchTerminator: string;
    readonly commitTransactionStatement: string;
    readonly singleLineCommentToken: string;
    readonly startTransactionStatement: string;
    readonly statementTerminator: string;
    delimitIdentifier(identifier: string): string;
    delimitIdentifier(builder: StringBuilder, identifier: string): void;
    delimitIdentifier(name: string, schema: string): string;
    delimitIdentifier(builder: StringBuilder, name: string, schema: string): void;
    delimitJsonPathElement(pathElement: string): string;
    escapeIdentifier(identifier: string): string;
    escapeIdentifier(builder: StringBuilder, identifier: string): void;
    escapeJsonPathElement(identifier: string): string;
    generateComment(text: string): string;
    generateCreateSavepointStatement(name: string): string;
    generateParameterName(name: string): string;
    generateParameterName(builder: StringBuilder, name: string): void;
    generateParameterNamePlaceholder(name: string): string;
    generateParameterNamePlaceholder(builder: StringBuilder, name: string): void;
    generateReleaseSavepointStatement(name: string): string;
    generateRollbackToSavepointStatement(name: string): string;
}


export const RelationalSqlGenerationHelper: {
    new(dependencies: RelationalSqlGenerationHelperDependencies): RelationalSqlGenerationHelper;
};


export interface __RelationalSqlGenerationHelper$views {
    As_ISqlGenerationHelper(): ISqlGenerationHelper$instance;
}

export type RelationalSqlGenerationHelper = RelationalSqlGenerationHelper$instance & __RelationalSqlGenerationHelper$views;


export interface RelationalSqlGenerationHelperDependencies$instance {
    _Clone_$(): RelationalSqlGenerationHelperDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalSqlGenerationHelperDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalSqlGenerationHelperDependencies: {
    new(): RelationalSqlGenerationHelperDependencies;
};


export type RelationalSqlGenerationHelperDependencies = RelationalSqlGenerationHelperDependencies$instance;

export interface RelationalTransaction$instance {
    readonly supportsSavepoints: boolean;
    readonly transactionId: Guid;
    commit(): void;
    commitAsync(cancellationToken?: CancellationToken): Task;
    createSavepoint(name: string): void;
    createSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
    dispose(): void;
    disposeAsync(): ValueTask;
    releaseSavepoint(name: string): void;
    releaseSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
    rollback(): void;
    rollbackAsync(cancellationToken?: CancellationToken): Task;
    rollbackToSavepoint(name: string): void;
    rollbackToSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
}


export const RelationalTransaction: {
    new(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean, sqlGenerationHelper: ISqlGenerationHelper): RelationalTransaction;
};


export interface __RelationalTransaction$views {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<DbTransaction>;
    As_IDbContextTransaction(): IDbContextTransaction$instance;
}

export interface RelationalTransaction$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<DbTransaction>, IDbContextTransaction$instance {}

export type RelationalTransaction = RelationalTransaction$instance & __RelationalTransaction$views;


export interface RelationalTransactionFactory$instance {
    create(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean): RelationalTransaction;
}


export const RelationalTransactionFactory: {
    new(dependencies: RelationalTransactionFactoryDependencies): RelationalTransactionFactory;
};


export interface __RelationalTransactionFactory$views {
    As_IRelationalTransactionFactory(): IRelationalTransactionFactory$instance;
}

export interface RelationalTransactionFactory$instance extends IRelationalTransactionFactory$instance {}

export type RelationalTransactionFactory = RelationalTransactionFactory$instance & __RelationalTransactionFactory$views;


export interface RelationalTransactionFactoryDependencies$instance {
    sqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): RelationalTransactionFactoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalTransactionFactoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalTransactionFactoryDependencies: {
    new(sqlGenerationHelper: ISqlGenerationHelper): RelationalTransactionFactoryDependencies;
};


export type RelationalTransactionFactoryDependencies = RelationalTransactionFactoryDependencies$instance;

export interface RelationalTypeMapping$instance extends CoreTypeMapping {
    readonly dbType: Nullable<DbType>;
    readonly isFixedLength: boolean;
    readonly isUnicode: boolean;
    readonly precision: Nullable<System_Internal.Int32>;
    readonly scale: Nullable<System_Internal.Int32>;
    readonly size: Nullable<System_Internal.Int32>;
    readonly storeType: string;
    readonly storeTypeNameBase: string;
    readonly storeTypePostfix: StoreTypePostfix;
    clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    createParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    customizeDataReaderExpression(expression: Expression): Expression;
    generateProviderValueSqlLiteral(value: unknown): string;
    generateSqlLiteral(value: unknown): string;
    getDataReaderMethod(): MethodInfo;
    withComposedConverter(converter: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    withPrecisionAndScale(precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMapping;
    withStoreTypeAndSize(storeType: string, size: Nullable<System_Internal.Int32>): RelationalTypeMapping;
    withTypeMappingInfo(mappingInfo: RelationalTypeMappingInfo): RelationalTypeMapping;
}


export const RelationalTypeMapping: {
    readonly nullMapping: RelationalTypeMapping;
    getDataReaderMethod(type: Type): MethodInfo;
};


export type RelationalTypeMapping = RelationalTypeMapping$instance;

export interface RelationalTypeMappingSource$instance extends TypeMappingSourceBase$instance {
    findMapping(property: IProperty): CoreTypeMapping | undefined;
    findMapping(elementType: IElementType): CoreTypeMapping | undefined;
    findMapping(type: Type): RelationalTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): RelationalTypeMapping | undefined;
    findMapping(member: MemberInfo): RelationalTypeMapping | undefined;
    findMapping(storeTypeName: string): RelationalTypeMapping | undefined;
    findMapping(type: Type): CoreTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
}


export const RelationalTypeMappingSource: {
};


export interface __RelationalTypeMappingSource$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
    As_IRelationalTypeMappingSource(): IRelationalTypeMappingSource$instance;
}

export type RelationalTypeMappingSource = RelationalTypeMappingSource$instance & __RelationalTypeMappingSource$views;


export interface RelationalTypeMappingSourceDependencies$instance {
    plugins: IEnumerable<IRelationalTypeMappingSourcePlugin>;
    _Clone_$(): RelationalTypeMappingSourceDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalTypeMappingSourceDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalTypeMappingSourceDependencies: {
    new(plugins: IEnumerable<IRelationalTypeMappingSourcePlugin>): RelationalTypeMappingSourceDependencies;
};


export type RelationalTypeMappingSourceDependencies = RelationalTypeMappingSourceDependencies$instance;

export interface RetryLimitExceededException$instance extends Exception {
}


export const RetryLimitExceededException: {
    new(): RetryLimitExceededException;
    new(message: string): RetryLimitExceededException;
    new(message: string, innerException: Exception): RetryLimitExceededException;
    new(info: SerializationInfo, context: StreamingContext): RetryLimitExceededException;
};


export type RetryLimitExceededException = RetryLimitExceededException$instance;

export interface SByteTypeMapping$instance extends RelationalTypeMapping {
}


export const SByteTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): SByteTypeMapping;
    readonly default: SByteTypeMapping;
};


export type SByteTypeMapping = SByteTypeMapping$instance;

export interface ShortTypeMapping$instance extends RelationalTypeMapping {
}


export const ShortTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ShortTypeMapping;
    readonly default: ShortTypeMapping;
};


export type ShortTypeMapping = ShortTypeMapping$instance;

export interface StringTypeMapping$instance extends RelationalTypeMapping {
}


export const StringTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, unicode: boolean, size: Nullable<System_Internal.Int32>): StringTypeMapping;
    readonly default: StringTypeMapping;
};


export type StringTypeMapping = StringTypeMapping$instance;

export interface TimeOnlyTypeMapping$instance extends RelationalTypeMapping {
}


export const TimeOnlyTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): TimeOnlyTypeMapping;
    readonly default: TimeOnlyTypeMapping;
};


export type TimeOnlyTypeMapping = TimeOnlyTypeMapping$instance;

export interface TimeSpanTypeMapping$instance extends RelationalTypeMapping {
}


export const TimeSpanTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): TimeSpanTypeMapping;
    readonly default: TimeSpanTypeMapping;
};


export type TimeSpanTypeMapping = TimeSpanTypeMapping$instance;

export interface TypeMappingSource$instance extends TypeMappingSourceBase$instance {
    findMapping(property: IProperty): CoreTypeMapping | undefined;
    findMapping(elementType: IElementType): CoreTypeMapping | undefined;
    findMapping(type: Type): CoreTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
}


export const TypeMappingSource: {
};


export interface __TypeMappingSource$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
}

export type TypeMappingSource = TypeMappingSource$instance & __TypeMappingSource$views;


export interface TypeMappingSourceBase$instance {
    findMapping(property: IProperty): CoreTypeMapping | undefined;
    findMapping(elementType: IElementType): CoreTypeMapping | undefined;
    findMapping(type: Type): CoreTypeMapping | undefined;
    findMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo): CoreTypeMapping | undefined;
    findMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
}


export const TypeMappingSourceBase: {
};


export interface __TypeMappingSourceBase$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
}

export type TypeMappingSourceBase = TypeMappingSourceBase$instance & __TypeMappingSourceBase$views;


export interface TypeMappingSourceDependencies$instance {
    readonly jsonValueReaderWriterSource: IJsonValueReaderWriterSource;
    plugins: IEnumerable<ITypeMappingSourcePlugin>;
    valueConverterSelector: IValueConverterSelector;
    _Clone_$(): TypeMappingSourceDependencies;
    equals(obj: unknown): boolean;
    equals(other: TypeMappingSourceDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const TypeMappingSourceDependencies: {
    new(valueConverterSelector: IValueConverterSelector, jsonValueReaderWriterSource: IJsonValueReaderWriterSource, plugins: IEnumerable<ITypeMappingSourcePlugin>): TypeMappingSourceDependencies;
};


export type TypeMappingSourceDependencies = TypeMappingSourceDependencies$instance;

export interface TypeMaterializationInfo$instance {
    readonly isNullable: Nullable<System_Internal.Boolean>;
    readonly mapping: RelationalTypeMapping;
    readonly modelClrType: Type;
    readonly property: IProperty;
    readonly providerClrType: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const TypeMaterializationInfo: {
    new(modelClrType: Type, property: IProperty, mapping: RelationalTypeMapping, nullable: Nullable<System_Internal.Boolean>): TypeMaterializationInfo;
};


export type TypeMaterializationInfo = TypeMaterializationInfo$instance;

export interface UIntTypeMapping$instance extends RelationalTypeMapping {
}


export const UIntTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): UIntTypeMapping;
    readonly default: UIntTypeMapping;
};


export type UIntTypeMapping = UIntTypeMapping$instance;

export interface ULongTypeMapping$instance extends RelationalTypeMapping {
}


export const ULongTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ULongTypeMapping;
    readonly default: ULongTypeMapping;
};


export type ULongTypeMapping = ULongTypeMapping$instance;

export interface UShortTypeMapping$instance extends RelationalTypeMapping {
}


export const UShortTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): UShortTypeMapping;
    readonly default: UShortTypeMapping;
};


export type UShortTypeMapping = UShortTypeMapping$instance;

export abstract class DbContextTransactionExtensions$instance {
    static getDbTransaction(dbContextTransaction: IDbContextTransaction): DbTransaction;
}


export type DbContextTransactionExtensions = DbContextTransactionExtensions$instance;

export abstract class RelationalCommandBuilderExtensions$instance {
    static addCompositeParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, subParameters: IReadOnlyList<IRelationalParameter>): IRelationalCommandBuilder;
    static addParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, name: string, relationalTypeMapping: RelationalTypeMapping, nullable: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): IRelationalCommandBuilder;
    static addParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, name: string): IRelationalCommandBuilder;
    static addRawParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, dbParameter: DbParameter): IRelationalCommandBuilder;
    static appendLine(commandBuilder: IRelationalCommandBuilder, value: FormattableString): IRelationalCommandBuilder;
    static appendLine(commandBuilder: IRelationalCommandBuilder, value: string): IRelationalCommandBuilder;
    static appendLines(commandBuilder: IRelationalCommandBuilder, value: string, skipFinalNewline?: boolean): IRelationalCommandBuilder;
    static indent(commandBuilder: IRelationalCommandBuilder): IDisposable;
}


export type RelationalCommandBuilderExtensions = RelationalCommandBuilderExtensions$instance;

export abstract class RelationalExecutionStrategyExtensions$instance {
    static executeInTransaction<TResult>(strategy: IExecutionStrategy, operation: Func<TResult>, verifySucceeded: Func<System_Internal.Boolean>, isolationLevel: IsolationLevel): TResult;
    static executeInTransaction(strategy: IExecutionStrategy, operation: Action, verifySucceeded: Func<System_Internal.Boolean>, isolationLevel: IsolationLevel): void;
    static executeInTransaction<TState>(strategy: IExecutionStrategy, state: TState, operation: Action<TState>, verifySucceeded: Func<TState, System_Internal.Boolean>, isolationLevel: IsolationLevel): void;
    static executeInTransaction<TState, TResult>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, TResult>, verifySucceeded: Func<TState, System_Internal.Boolean>, isolationLevel: IsolationLevel): TResult;
    static executeInTransactionAsync<TResult>(strategy: IExecutionStrategy, operation: Func<CancellationToken, Task<TResult>>, verifySucceeded: Func<CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<TResult>;
    static executeInTransactionAsync(strategy: IExecutionStrategy, operation: Func<Task>, verifySucceeded: Func<Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel): Task;
    static executeInTransactionAsync(strategy: IExecutionStrategy, operation: Func<CancellationToken, Task>, verifySucceeded: Func<CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task;
    static executeInTransactionAsync<TState>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, CancellationToken, Task>, verifySucceeded: Func<TState, CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task;
    static executeInTransactionAsync<TState, TResult>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<TState, CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<TResult>;
}


export type RelationalExecutionStrategyExtensions = RelationalExecutionStrategyExtensions$instance;

export abstract class RelationalTypeMappingSourceExtensions$instance {
    static getMapping(typeMappingSource: IRelationalTypeMappingSource, property: IProperty): RelationalTypeMapping;
    static getMapping(typeMappingSource: IRelationalTypeMappingSource, typeName: string): RelationalTypeMapping;
    static getMapping(typeMappingSource: IRelationalTypeMappingSource, clrType: Type, model: IModel): RelationalTypeMapping;
    static getMapping(typeMappingSource: IRelationalTypeMappingSource, clrType: Type): RelationalTypeMapping;
    static getMappingForValue(typeMappingSource: IRelationalTypeMappingSource, value: unknown, model: IModel): RelationalTypeMapping;
    static getMappingForValue(typeMappingSource: IRelationalTypeMappingSource, value: unknown): RelationalTypeMapping;
}


export type RelationalTypeMappingSourceExtensions = RelationalTypeMappingSourceExtensions$instance;

