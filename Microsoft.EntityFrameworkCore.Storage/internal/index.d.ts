// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Storage
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { CommandSource, DbCommandMethod, IDiagnosticsLogger_1, ILoggingOptions, IRelationalCommandDiagnosticsLogger, IRelationalConnectionDiagnosticsLogger } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IConcurrencyDetector, ICoreSingletonOptions, ICurrentDbContext, IDbContextOptions, IDbContextOptionsExtension, IInfrastructure_1, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IAdHocMapper, IElementType, IEntityType, IModel, IProperty, IPropertyBase, ITypeMappingConfiguration } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IMigrationCommandExecutor, IMigrationsModelDiffer, IMigrationsSqlGenerator, MigrationCommand, MigrationsSqlGenerationOptions } from "../../Microsoft.EntityFrameworkCore.Migrations/internal/index.js";
import type { IAsyncQueryProvider, IQueryCompilationContextFactory, QueryContext } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { INamedConnectionStringResolver } from "../../Microsoft.EntityFrameworkCore.Storage.Internal/internal/index.js";
import type { IJsonValueReaderWriterSource, JsonValueReaderWriter } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { IValueConverterSelector, ValueConverter, ValueConverter_2, ValueConverterInfo } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { IBatchExecutor, ICommandBatchPreparer, IUpdateAdapterFactory, IUpdateEntry } from "../../Microsoft.EntityFrameworkCore.Update/internal/index.js";
import type { ValueGenerator } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import type { DbContext, DbLoggerCategory_Database_Command, DbLoggerCategory_Database_Transaction, DbLoggerCategory_Infrastructure, DbLoggerCategory_Update } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IEnumerable, IList, IReadOnlyDictionary, IReadOnlyList, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Data_Common_Internal from "@tsonic/dotnet/System.Data.Common.js";
import type { DbCommand, DbConnection, DbDataReader, DbParameter, DbTransaction } from "@tsonic/dotnet/System.Data.Common.js";
import type { DbType, IsolationLevel, ParameterDirection } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Enum, Exception, FormattableString, Func, Guid, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, Random, String as ClrString, TimeSpan, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { ConstructorInfo, MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { Transaction } from "@tsonic/dotnet/System.Transactions.js";

export enum StoreTypePostfix {
    None = 0,
    Size = 1,
    Precision = 2,
    PrecisionAndScale = 3
}


export interface IDatabase$instance {
    CompileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    CompileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    SaveChanges(entries: IList<IUpdateEntry>): int;
    SaveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export type IDatabase = IDatabase$instance;

export interface IDatabaseCreator$instance {
    EnsureDeleted(): boolean;
    EnsureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export type IDatabaseCreator = IDatabaseCreator$instance;

export interface IDatabaseFacadeDependencies$instance {
    readonly TransactionManager: IDbContextTransactionManager;
    readonly DatabaseCreator: IDatabaseCreator;
    readonly ExecutionStrategy: IExecutionStrategy;
    readonly ExecutionStrategyFactory: IExecutionStrategyFactory;
    readonly DatabaseProviders: IEnumerable<IDatabaseProvider>;
    readonly CommandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>;
    readonly ConcurrencyDetector: IConcurrencyDetector;
    readonly CoreOptions: ICoreSingletonOptions;
    readonly QueryProvider: IAsyncQueryProvider;
    readonly AdHocMapper: IAdHocMapper;
    readonly TypeMappingSource: ITypeMappingSource;
}


export type IDatabaseFacadeDependencies = IDatabaseFacadeDependencies$instance;

export interface IDatabaseFacadeDependenciesAccessor$instance {
    readonly Dependencies: IDatabaseFacadeDependencies;
    readonly Context: DbContext;
}


export type IDatabaseFacadeDependenciesAccessor = IDatabaseFacadeDependenciesAccessor$instance;

export interface IDatabaseProvider$instance {
    readonly Name: string;
    readonly Version: string | undefined;
    IsConfigured(options: IDbContextOptions): boolean;
}


export type IDatabaseProvider = IDatabaseProvider$instance;

export interface IDbContextTransaction$instance extends IDisposable, IAsyncDisposable {
    readonly TransactionId: Guid;
    readonly SupportsSavepoints: boolean;
    Commit(): void;
    CommitAsync(cancellationToken?: CancellationToken): Task;
    CreateSavepoint(name: string): void;
    CreateSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
}


export interface IDbContextTransaction$instance extends System_Internal.IAsyncDisposable, System_Internal.IDisposable {}

export type IDbContextTransaction = IDbContextTransaction$instance;

export interface IDbContextTransactionManager$instance extends IResettableService {
    readonly CurrentTransaction: IDbContextTransaction | undefined;
    BeginTransaction(): IDbContextTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    CommitTransaction(): void;
    CommitTransactionAsync(cancellationToken?: CancellationToken): Task;
    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
}


export interface IDbContextTransactionManager$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type IDbContextTransactionManager = IDbContextTransactionManager$instance;

export interface IExceptionDetector$instance {
    IsCancellation(exception: Exception, cancellationToken?: CancellationToken): boolean;
}


export type IExceptionDetector = IExceptionDetector$instance;

export interface IExecutionStrategy$instance {
    readonly RetriesOnFailure: boolean;
    Execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    ExecuteAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export type IExecutionStrategy = IExecutionStrategy$instance;

export interface IExecutionStrategyFactory$instance {
    Create(): IExecutionStrategy;
}


export type IExecutionStrategyFactory = IExecutionStrategyFactory$instance;

export interface IParameterNameGeneratorFactory$instance {
    Create(): ParameterNameGenerator;
}


export type IParameterNameGeneratorFactory = IParameterNameGeneratorFactory$instance;

export interface IRawSqlCommandBuilder$instance {
    Build(sql: string, parameters: IEnumerable<unknown>, model: IModel): RawSqlCommand;
    Build(sql: string, parameters: IEnumerable<unknown>): RawSqlCommand;
    Build(sql: string): IRelationalCommand;
}


export type IRawSqlCommandBuilder = IRawSqlCommandBuilder$instance;

export interface IRelationalCommand$instance extends IRelationalCommandTemplate {
    readonly CommandText: string;
    readonly LogCommandText: string;
    readonly Parameters: IReadOnlyList<IRelationalParameter>;
    CreateDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
    ExecuteNonQuery(parameterObject: RelationalCommandParameterObject): int;
    ExecuteNonQueryAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    ExecuteReader(parameterObject: RelationalCommandParameterObject): RelationalDataReader;
    ExecuteScalar(parameterObject: RelationalCommandParameterObject): unknown | undefined;
    PopulateFrom(commandTemplate: IRelationalCommandTemplate): void;
}


export interface IRelationalCommand$instance extends IRelationalCommandTemplate$instance {}

export type IRelationalCommand = IRelationalCommand$instance;

export interface IRelationalCommandBuilder$instance {
    readonly Parameters: IReadOnlyList<IRelationalParameter>;
    readonly TypeMappingSource: IRelationalTypeMappingSource;
    readonly CommandTextLength: int;
    AddParameter(parameter: IRelationalParameter): IRelationalCommandBuilder;
    Append(value: FormattableString, sensitive?: boolean): IRelationalCommandBuilder;
    Append(value: string, sensitive?: boolean): IRelationalCommandBuilder;
    AppendLine(): IRelationalCommandBuilder;
    Build(): IRelationalCommand;
    RemoveParameterAt(index: int): IRelationalCommandBuilder;
}


export type IRelationalCommandBuilder = IRelationalCommandBuilder$instance;

export interface IRelationalCommandBuilderFactory$instance {
    Create(): IRelationalCommandBuilder;
}


export type IRelationalCommandBuilderFactory = IRelationalCommandBuilderFactory$instance;

export interface IRelationalCommandTemplate$instance {
    readonly CommandText: string;
    readonly LogCommandText: string;
    readonly Parameters: IReadOnlyList<IRelationalParameter>;
    CreateDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
}


export type IRelationalCommandTemplate = IRelationalCommandTemplate$instance;

export interface IRelationalConnection$instance extends IRelationalTransactionManager, IDbContextTransactionManager, IResettableService, IDisposable, IAsyncDisposable {
    get ConnectionString(): string | undefined;
    set ConnectionString(value: string | undefined);
    DbConnection: DbConnection;
    readonly Context: DbContext;
    readonly ConnectionId: Guid;
    CommandTimeout: Nullable<System_Internal.Int32>;
    readonly CurrentTransaction: IDbContextTransaction | undefined;
    BeginTransaction(): IDbContextTransaction;
    BeginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    BeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    Close(): boolean;
    CloseAsync(): Task<System_Internal.Boolean>;
    CommitTransaction(): void;
    CommitTransactionAsync(cancellationToken?: CancellationToken): Task;
    Open(errorsExpected?: boolean): boolean;
    OpenAsync(cancellationToken: CancellationToken, errorsExpected?: boolean): Task<System_Internal.Boolean>;
    RentCommand(): IRelationalCommand;
    ReturnCommand(command: IRelationalCommand): void;
    SetDbConnection(value: DbConnection, contextOwnsConnection: boolean): void;
    UseTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    UseTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    UseTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    UseTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
}


export interface IRelationalConnection$instance extends System_Internal.IAsyncDisposable, System_Internal.IDisposable {}

export type IRelationalConnection = IRelationalConnection$instance;

export interface IRelationalDatabaseCreator$instance extends IDatabaseCreator {
    Create(): void;
    CreateAsync(cancellationToken?: CancellationToken): Task;
    Exists(): boolean;
    ExistsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    GenerateCreateScript(): string;
    EnsureDeleted(): boolean;
    EnsureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export interface IRelationalDatabaseCreator$instance extends IDatabaseCreator$instance {}

export type IRelationalDatabaseCreator = IRelationalDatabaseCreator$instance;

export interface IRelationalDatabaseFacadeDependencies$instance extends IDatabaseFacadeDependencies {
    readonly RelationalConnection: IRelationalConnection;
    readonly RawSqlCommandBuilder: IRawSqlCommandBuilder;
    readonly CommandLogger: IRelationalCommandDiagnosticsLogger;
    readonly TransactionManager: IDbContextTransactionManager;
    readonly DatabaseCreator: IDatabaseCreator;
    readonly ExecutionStrategy: IExecutionStrategy;
    readonly ExecutionStrategyFactory: IExecutionStrategyFactory;
    readonly DatabaseProviders: IEnumerable<IDatabaseProvider>;
    readonly ConcurrencyDetector: IConcurrencyDetector;
    readonly CoreOptions: ICoreSingletonOptions;
    readonly QueryProvider: IAsyncQueryProvider;
    readonly AdHocMapper: IAdHocMapper;
    readonly TypeMappingSource: ITypeMappingSource;
}


export type IRelationalDatabaseFacadeDependencies = IRelationalDatabaseFacadeDependencies$instance;

export interface IRelationalParameter$instance {
    readonly InvariantName: string;
    AddDbParameter(command: DbCommand, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>): void;
    AddDbParameter(command: DbCommand, value: unknown): void;
}


export type IRelationalParameter = IRelationalParameter$instance;

export interface IRelationalTransactionFactory$instance {
    Create(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean): RelationalTransaction;
}


export type IRelationalTransactionFactory = IRelationalTransactionFactory$instance;

export interface IRelationalTransactionManager$instance extends IDbContextTransactionManager, IResettableService {
    readonly CurrentTransaction: IDbContextTransaction | undefined;
    BeginTransaction(): IDbContextTransaction;
    BeginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    BeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    CommitTransaction(): void;
    CommitTransactionAsync(cancellationToken?: CancellationToken): Task;
    UseTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    UseTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    UseTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    UseTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
}


export type IRelationalTransactionManager = IRelationalTransactionManager$instance;

export interface IRelationalTypeMappingSource$instance extends ITypeMappingSource {
    FindMapping(elementType: IElementType): CoreTypeMapping | undefined;
    FindMapping(property: IProperty): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo): CoreTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(type: Type): CoreTypeMapping | undefined;
    FindMapping(property: IProperty): RelationalTypeMapping | undefined;
    FindMapping(member: MemberInfo): RelationalTypeMapping | undefined;
    FindMapping(storeTypeName: string): RelationalTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): RelationalTypeMapping | undefined;
    FindMapping(type: Type, storeTypeName: string, keyOrIndex?: boolean, unicode?: Nullable<System_Internal.Boolean>, size?: Nullable<System_Internal.Int32>, rowVersion?: Nullable<System_Internal.Boolean>, fixedLength?: Nullable<System_Internal.Boolean>, precision?: Nullable<System_Internal.Int32>, scale?: Nullable<System_Internal.Int32>): RelationalTypeMapping | undefined;
    FindMapping(type: Type): RelationalTypeMapping | undefined;
}


export type IRelationalTypeMappingSource = IRelationalTypeMappingSource$instance;

export interface IRelationalTypeMappingSourcePlugin$instance {
    FindMapping(mappingInfo: RelationalTypeMappingInfo): RelationalTypeMapping | undefined;
}


export type IRelationalTypeMappingSourcePlugin = IRelationalTypeMappingSourcePlugin$instance;

export interface ISqlGenerationHelper$instance {
    readonly StatementTerminator: string;
    readonly BatchTerminator: string;
    readonly StartTransactionStatement: string;
    readonly CommitTransactionStatement: string;
    readonly SingleLineCommentToken: string;
    DelimitIdentifier(name: string, schema: string): string;
    DelimitIdentifier(builder: StringBuilder, name: string, schema: string): void;
    GenerateParameterName(name: string): string;
    GenerateParameterName(builder: StringBuilder, name: string): void;
}


export type ISqlGenerationHelper = ISqlGenerationHelper$instance;

export interface ITransactionEnlistmentManager$instance {
    readonly CurrentAmbientTransaction: Transaction | undefined;
    readonly EnlistedTransaction: Transaction | undefined;
    EnlistTransaction(transaction: Transaction): void;
}


export type ITransactionEnlistmentManager = ITransactionEnlistmentManager$instance;

export interface ITypeMappingSource$instance {
    FindMapping(elementType: IElementType): CoreTypeMapping | undefined;
    FindMapping(property: IProperty): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo): CoreTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(type: Type): CoreTypeMapping | undefined;
}


export type ITypeMappingSource = ITypeMappingSource$instance;

export interface ITypeMappingSourcePlugin$instance {
    FindMapping(mappingInfo: TypeMappingInfo): CoreTypeMapping | undefined;
}


export type ITypeMappingSourcePlugin = ITypeMappingSourcePlugin$instance;

export interface MaterializationContext$instance {
    readonly Context: DbContext;
    readonly ValueBuffer: ValueBuffer;
}


export const MaterializationContext: {
    new(valueBuffer: ValueBuffer, context: DbContext): MaterializationContext;
    readonly GetValueBufferMethod: MethodInfo;
};


export type MaterializationContext = MaterializationContext$instance;

export interface RelationalCommandParameterObject$instance {
    readonly CommandSource: CommandSource;
    readonly Connection: IRelationalConnection;
    readonly Context: DbContext | undefined;
    readonly DetailedErrorsEnabled: boolean;
    readonly Logger: IRelationalCommandDiagnosticsLogger | undefined;
    readonly ParameterValues: IReadOnlyDictionary<System_Internal.String, unknown | undefined> | undefined;
    readonly ReaderColumns: IReadOnlyList<ReaderColumn | undefined> | undefined;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalCommandParameterObject): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalCommandParameterObject: {
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, commandSource: CommandSource): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, detailedErrorsEnabled: boolean): RelationalCommandParameterObject;
    new(connection: IRelationalConnection, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>, readerColumns: IReadOnlyList<ReaderColumn>, context: DbContext, logger: IRelationalCommandDiagnosticsLogger, detailedErrorsEnabled: boolean, commandSource: CommandSource): RelationalCommandParameterObject;
};


export type RelationalCommandParameterObject = RelationalCommandParameterObject$instance;

export interface RelationalTypeMappingInfo$instance {
    get ClrType(): Type | undefined;
    set ClrType(value: Type | undefined);
    readonly CoreTypeMappingInfo: TypeMappingInfo;
    DbType: Nullable<DbType>;
    get ElementTypeMapping(): RelationalTypeMapping | undefined;
    set ElementTypeMapping(value: RelationalTypeMapping | undefined);
    IsFixedLength: Nullable<System_Internal.Boolean>;
    IsKey: boolean;
    IsKeyOrIndex: boolean;
    IsRowVersion: Nullable<System_Internal.Boolean>;
    IsUnicode: Nullable<System_Internal.Boolean>;
    get JsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    set JsonValueReaderWriter(value: JsonValueReaderWriter | undefined);
    Precision: Nullable<System_Internal.Int32>;
    Scale: Nullable<System_Internal.Int32>;
    Size: Nullable<System_Internal.Int32>;
    get StoreTypeName(): string | undefined;
    set StoreTypeName(value: string | undefined);
    get StoreTypeNameBase(): string | undefined;
    set StoreTypeNameBase(value: string | undefined);
    Equals(obj: unknown): boolean;
    Equals(other: RelationalTypeMappingInfo): boolean;
    GetHashCode(): int;
    ToString(): string;
    WithConverter(converterInfo: ValueConverterInfo): RelationalTypeMappingInfo;
}


export const RelationalTypeMappingInfo: {
    new(property: IProperty): RelationalTypeMappingInfo;
    new(elementType: IElementType, storeTypeName: string, storeTypeNameBase: string, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackFixedLength: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(principals: IReadOnlyList<IProperty>, storeTypeName: string, storeTypeNameBase: string, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackFixedLength: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(member: MemberInfo, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
    new(source: RelationalTypeMappingInfo, converter: ValueConverterInfo): RelationalTypeMappingInfo;
    new(type: Type, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, keyOrIndex: boolean, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, rowVersion: Nullable<System_Internal.Boolean>, fixedLength: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, dbType: Nullable<DbType>, key: boolean): RelationalTypeMappingInfo;
    new(type: Type, typeMappingConfiguration: ITypeMappingConfiguration, elementTypeMapping: RelationalTypeMapping, storeTypeName: string, storeTypeNameBase: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMappingInfo;
};


export type RelationalTypeMappingInfo = RelationalTypeMappingInfo$instance;

export interface TypeMappingInfo$instance {
    get ClrType(): Type | undefined;
    set ClrType(value: Type | undefined);
    get ElementTypeMapping(): CoreTypeMapping | undefined;
    set ElementTypeMapping(value: CoreTypeMapping | undefined);
    IsKey: boolean;
    IsKeyOrIndex: boolean;
    IsRowVersion: Nullable<System_Internal.Boolean>;
    IsUnicode: Nullable<System_Internal.Boolean>;
    get JsonValueReaderWriter(): JsonValueReaderWriter | undefined;
    set JsonValueReaderWriter(value: JsonValueReaderWriter | undefined);
    Precision: Nullable<System_Internal.Int32>;
    Scale: Nullable<System_Internal.Int32>;
    Size: Nullable<System_Internal.Int32>;
    Equals(obj: unknown): boolean;
    Equals(other: TypeMappingInfo): boolean;
    GetHashCode(): int;
    ToString(): string;
    WithConverter(converterInfo: ValueConverterInfo): TypeMappingInfo;
}


export const TypeMappingInfo: {
    new(property: IProperty): TypeMappingInfo;
    new(elementType: IElementType, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(principals: IReadOnlyList<IProperty>, fallbackUnicode: Nullable<System_Internal.Boolean>, fallbackSize: Nullable<System_Internal.Int32>, fallbackPrecision: Nullable<System_Internal.Int32>, fallbackScale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(member: MemberInfo, elementTypeMapping: CoreTypeMapping, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): TypeMappingInfo;
    new(type: Type, typeMappingConfiguration: ITypeMappingConfiguration, elementTypeMapping: CoreTypeMapping): TypeMappingInfo;
    new(type: Type, elementTypeMapping: CoreTypeMapping, keyOrIndex: boolean, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, rowVersion: Nullable<System_Internal.Boolean>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, key: boolean): TypeMappingInfo;
    new(source: TypeMappingInfo, converter: ValueConverterInfo, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): TypeMappingInfo;
};


export type TypeMappingInfo = TypeMappingInfo$instance;

export interface ValueBuffer$instance {
    readonly Count: int;
    readonly IsEmpty: boolean;
    [index: number]: unknown | undefined;
    Equals(obj: unknown): boolean;
    Equals(other: ValueBuffer): boolean;
    GetHashCode(): int;
}


export const ValueBuffer: {
    new(values: unknown[]): ValueBuffer;
    readonly Empty: ValueBuffer;
};


export type ValueBuffer = ValueBuffer$instance;

export interface BoolTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const BoolTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): BoolTypeMapping;
    readonly Default: BoolTypeMapping;
};


export type BoolTypeMapping = BoolTypeMapping$instance;

export interface ByteArrayTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const ByteArrayTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, size: Nullable<System_Internal.Int32>): ByteArrayTypeMapping;
    readonly Default: ByteArrayTypeMapping;
};


export type ByteArrayTypeMapping = ByteArrayTypeMapping$instance;

export interface ByteTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const ByteTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ByteTypeMapping;
    readonly Default: ByteTypeMapping;
};


export type ByteTypeMapping = ByteTypeMapping$instance;

export interface CharTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const CharTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): CharTypeMapping;
    readonly Default: CharTypeMapping;
};


export type CharTypeMapping = CharTypeMapping$instance;

export interface CoreTypeMapping$instance {
    readonly ClrType: Type;
    readonly Comparer: ValueComparer;
    readonly Converter: ValueConverter | undefined;
    readonly ElementTypeMapping: CoreTypeMapping | undefined;
    readonly JsonValueReaderWriter: JsonValueReaderWriter | undefined;
    readonly KeyComparer: ValueComparer;
    readonly Parameters: unknown;
    readonly ProviderValueComparer: ValueComparer;
    readonly ValueGeneratorFactory: Func<IProperty, IEntityType, ValueGenerator> | undefined;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateCodeLiteral(value: unknown): Expression;
    WithComposedConverter(converter: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const CoreTypeMapping: (abstract new(parameters: unknown) => CoreTypeMapping) & {
};


export type CoreTypeMapping = CoreTypeMapping$instance;

export interface Database$instance {
    readonly Dependencies: DatabaseDependencies;
    CompileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    CompileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    SaveChanges(entries: IList<IUpdateEntry>): int;
    SaveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export const Database: (abstract new(dependencies: DatabaseDependencies) => Database) & {
};


export interface __Database$views {
    As_IDatabase(): IDatabase$instance;
}

export interface Database$instance extends IDatabase$instance {}

export type Database = Database$instance & __Database$views;


export interface DatabaseDependencies$instance {
    readonly Logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    QueryCompilationContextFactory: IQueryCompilationContextFactory;
    UpdateAdapterFactory: IUpdateAdapterFactory;
    _Clone_$(): DatabaseDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: DatabaseDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const DatabaseDependencies: {
    new(queryCompilationContextFactory: IQueryCompilationContextFactory, updateAdapterFactory: IUpdateAdapterFactory, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): DatabaseDependencies;
};


export type DatabaseDependencies = DatabaseDependencies$instance;

export interface DatabaseProvider_1$instance<TOptionsExtension extends IDbContextOptionsExtension> {
    readonly Dependencies: DatabaseProviderDependencies;
    readonly Name: string;
    readonly Version: string | undefined;
    IsConfigured(options: IDbContextOptions): boolean;
}


export const DatabaseProvider_1: {
    new<TOptionsExtension extends IDbContextOptionsExtension>(dependencies: DatabaseProviderDependencies): DatabaseProvider_1<TOptionsExtension>;
};


export interface __DatabaseProvider_1$views<TOptionsExtension extends IDbContextOptionsExtension> {
    As_IDatabaseProvider(): IDatabaseProvider$instance;
}

export interface DatabaseProvider_1$instance<TOptionsExtension extends IDbContextOptionsExtension> extends IDatabaseProvider$instance {}

export type DatabaseProvider_1<TOptionsExtension extends IDbContextOptionsExtension> = DatabaseProvider_1$instance<TOptionsExtension> & __DatabaseProvider_1$views<TOptionsExtension>;


export interface DatabaseProviderDependencies$instance {
    _Clone_$(): DatabaseProviderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: DatabaseProviderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const DatabaseProviderDependencies: {
    new(): DatabaseProviderDependencies;
};


export type DatabaseProviderDependencies = DatabaseProviderDependencies$instance;

export interface DateOnlyTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const DateOnlyTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateOnlyTypeMapping;
    readonly Default: DateOnlyTypeMapping;
};


export type DateOnlyTypeMapping = DateOnlyTypeMapping$instance;

export interface DateTimeOffsetTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const DateTimeOffsetTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateTimeOffsetTypeMapping;
    readonly Default: DateTimeOffsetTypeMapping;
};


export type DateTimeOffsetTypeMapping = DateTimeOffsetTypeMapping$instance;

export interface DateTimeTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const DateTimeTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DateTimeTypeMapping;
    readonly Default: DateTimeTypeMapping;
};


export type DateTimeTypeMapping = DateTimeTypeMapping$instance;

export interface DecimalTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const DecimalTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): DecimalTypeMapping;
    readonly Default: DecimalTypeMapping;
};


export type DecimalTypeMapping = DecimalTypeMapping$instance;

export interface DoubleTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const DoubleTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): DoubleTypeMapping;
    readonly Default: DoubleTypeMapping;
};


export type DoubleTypeMapping = DoubleTypeMapping$instance;

export interface ExecutionResult_1$instance<TResult> {
    readonly IsSuccessful: boolean;
    readonly Result: TResult;
}


export const ExecutionResult_1: {
    new<TResult>(successful: boolean, result: TResult): ExecutionResult_1<TResult>;
};


export type ExecutionResult_1<TResult> = ExecutionResult_1$instance<TResult>;

export interface ExecutionStrategy$instance {
    readonly Dependencies: ExecutionStrategyDependencies;
    readonly ExceptionsEncountered: List<Exception>;
    readonly MaxRetryCount: int;
    readonly MaxRetryDelay: TimeSpan;
    readonly Random: Random;
    readonly RetriesOnFailure: boolean;
    Execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    ExecuteAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
    GetNextDelay(lastException: Exception): Nullable<TimeSpan>;
    OnFirstExecution(): void;
    OnRetry(): void;
    ShouldRetryOn(exception: Exception): boolean;
    ShouldVerifySuccessOn(exception: Exception): boolean;
}


export const ExecutionStrategy: (abstract new(context: DbContext, maxRetryCount: int, maxRetryDelay: TimeSpan) => ExecutionStrategy) & (abstract new(dependencies: ExecutionStrategyDependencies, maxRetryCount: int, maxRetryDelay: TimeSpan) => ExecutionStrategy) & {
    readonly DefaultMaxRetryCount: int;
    readonly DefaultMaxDelay: TimeSpan;
    get Current(): ExecutionStrategy | undefined;
    set Current(value: ExecutionStrategy | undefined);
    CallOnWrappedException<TResult>(exception: Exception, exceptionHandler: Func<Exception, TResult>): TResult;
};


export interface __ExecutionStrategy$views {
    As_IExecutionStrategy(): IExecutionStrategy$instance;
}

export interface ExecutionStrategy$instance extends IExecutionStrategy$instance {}

export type ExecutionStrategy = ExecutionStrategy$instance & __ExecutionStrategy$views;


export interface ExecutionStrategyDependencies$instance {
    CurrentContext: ICurrentDbContext;
    Logger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
    Options: IDbContextOptions;
    _Clone_$(): ExecutionStrategyDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ExecutionStrategyDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ExecutionStrategyDependencies: {
    new(currentContext: ICurrentDbContext, options: IDbContextOptions, logger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>): ExecutionStrategyDependencies;
};


export type ExecutionStrategyDependencies = ExecutionStrategyDependencies$instance;

export interface FloatTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const FloatTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): FloatTypeMapping;
    readonly Default: FloatTypeMapping;
};


export type FloatTypeMapping = FloatTypeMapping$instance;

export interface GuidTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const GuidTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): GuidTypeMapping;
    readonly Default: GuidTypeMapping;
};


export type GuidTypeMapping = GuidTypeMapping$instance;

export interface IntTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const IntTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): IntTypeMapping;
    readonly Default: IntTypeMapping;
};


export type IntTypeMapping = IntTypeMapping$instance;

export interface JsonTypeMapping$instance extends RelationalTypeMapping {
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const JsonTypeMapping: (abstract new(storeType: string, clrType: Type, dbType: Nullable<DbType>) => JsonTypeMapping) & (abstract new(parameters: unknown) => JsonTypeMapping) & {
};


export type JsonTypeMapping = JsonTypeMapping$instance;

export interface JsonTypePlaceholder$instance {
}


export const JsonTypePlaceholder: {
};


export type JsonTypePlaceholder = JsonTypePlaceholder$instance;

export interface LongTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const LongTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): LongTypeMapping;
    readonly Default: LongTypeMapping;
};


export type LongTypeMapping = LongTypeMapping$instance;

export interface NonRetryingExecutionStrategy$instance {
    readonly RetriesOnFailure: boolean;
    Execute<TState, TResult>(state: TState, operation: Func<DbContext, TState, TResult>, verifySucceeded: Func<DbContext, TState, ExecutionResult_1<TResult>>): TResult;
    ExecuteAsync<TState, TResult>(state: TState, operation: Func<DbContext, TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<DbContext, TState, CancellationToken, Task<ExecutionResult_1<TResult>>>, cancellationToken?: CancellationToken): Task<TResult>;
}


export const NonRetryingExecutionStrategy: {
    new(dependencies: ExecutionStrategyDependencies): NonRetryingExecutionStrategy;
    new(context: DbContext): NonRetryingExecutionStrategy;
};


export interface __NonRetryingExecutionStrategy$views {
    As_IExecutionStrategy(): IExecutionStrategy$instance;
}

export interface NonRetryingExecutionStrategy$instance extends IExecutionStrategy$instance {}

export type NonRetryingExecutionStrategy = NonRetryingExecutionStrategy$instance & __NonRetryingExecutionStrategy$views;


export interface ParameterNameGenerator$instance {
    GenerateNext(): string;
    Reset(): void;
}


export const ParameterNameGenerator: {
    new(): ParameterNameGenerator;
};


export type ParameterNameGenerator = ParameterNameGenerator$instance;

export interface ParameterNameGeneratorDependencies$instance {
    _Clone_$(): ParameterNameGeneratorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ParameterNameGeneratorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ParameterNameGeneratorDependencies: {
    new(): ParameterNameGeneratorDependencies;
};


export type ParameterNameGeneratorDependencies = ParameterNameGeneratorDependencies$instance;

export interface ParameterNameGeneratorFactory$instance {
    readonly Dependencies: ParameterNameGeneratorDependencies;
    Create(): ParameterNameGenerator;
}


export const ParameterNameGeneratorFactory: {
    new(dependencies: ParameterNameGeneratorDependencies): ParameterNameGeneratorFactory;
};


export interface __ParameterNameGeneratorFactory$views {
    As_IParameterNameGeneratorFactory(): IParameterNameGeneratorFactory$instance;
}

export interface ParameterNameGeneratorFactory$instance extends IParameterNameGeneratorFactory$instance {}

export type ParameterNameGeneratorFactory = ParameterNameGeneratorFactory$instance & __ParameterNameGeneratorFactory$views;


export interface RawSqlCommand$instance {
    readonly ParameterValues: IReadOnlyDictionary<System_Internal.String, unknown | undefined>;
    readonly RelationalCommand: IRelationalCommand;
}


export const RawSqlCommand: {
    new(relationalCommand: IRelationalCommand, parameterValues: IReadOnlyDictionary<System_Internal.String, unknown>): RawSqlCommand;
};


export type RawSqlCommand = RawSqlCommand$instance;

export interface ReaderColumn$instance {
    readonly GetFieldValueExpression: LambdaExpression;
    readonly IsNullable: boolean;
    readonly Name: string | undefined;
    readonly Property: IPropertyBase | undefined;
    readonly Type: Type;
}


export const ReaderColumn: (abstract new(type: Type, nullable: boolean, name: string, property: IPropertyBase, getFieldValueExpression: LambdaExpression) => ReaderColumn) & {
    Create(type: Type, nullable: boolean, columnName: string, property: IPropertyBase, readFunc: LambdaExpression): ReaderColumn;
    GetConstructor(type: Type): ConstructorInfo;
};


export type ReaderColumn = ReaderColumn$instance;

export interface ReaderColumn_1$instance<T> extends ReaderColumn {
    readonly GetFieldValue: Func<DbDataReader, int[], T>;
}


export const ReaderColumn_1: {
    new<T>(nullable: boolean, name: string, property: IPropertyBase, getFieldValueExpression: Expression<Func<DbDataReader, int[], T>>): ReaderColumn_1<T>;
};


export type ReaderColumn_1<T> = ReaderColumn_1$instance<T>;

export interface RelationalCommand$instance {
    CommandText: string;
    readonly Dependencies: RelationalCommandBuilderDependencies;
    LogCommandText: string;
    Parameters: IReadOnlyList<IRelationalParameter>;
    CreateDbCommand(parameterObject: RelationalCommandParameterObject, commandId: Guid, commandMethod: DbCommandMethod): DbCommand;
    CreateRelationalDataReader(): RelationalDataReader;
    ExecuteNonQuery(parameterObject: RelationalCommandParameterObject): int;
    ExecuteNonQueryAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
    ExecuteReader(parameterObject: RelationalCommandParameterObject): RelationalDataReader;
    ExecuteReaderAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<RelationalDataReader>;
    ExecuteScalar(parameterObject: RelationalCommandParameterObject): unknown | undefined;
    ExecuteScalarAsync(parameterObject: RelationalCommandParameterObject, cancellationToken?: CancellationToken): Task<unknown | undefined>;
    PopulateFrom(commandTemplate: IRelationalCommandTemplate): void;
}


export const RelationalCommand: {
    new(dependencies: RelationalCommandBuilderDependencies, commandText: string, logCommandText: string, parameters: IReadOnlyList<IRelationalParameter>): RelationalCommand;
};


export interface __RelationalCommand$views {
    As_IRelationalCommand(): IRelationalCommand$instance;
    As_IRelationalCommandTemplate(): IRelationalCommandTemplate$instance;
}

export type RelationalCommand = RelationalCommand$instance & __RelationalCommand$views;


export interface RelationalCommandBuilder$instance {
    readonly CommandTextLength: int;
    readonly Dependencies: RelationalCommandBuilderDependencies;
    readonly Parameters: IReadOnlyList<IRelationalParameter>;
    readonly TypeMappingSource: IRelationalTypeMappingSource;
    AddParameter(parameter: IRelationalParameter): IRelationalCommandBuilder;
    Append(value: string, sensitive?: boolean): IRelationalCommandBuilder;
    Append(value: FormattableString, sensitive?: boolean): IRelationalCommandBuilder;
    AppendLine(): IRelationalCommandBuilder;
    Build(): IRelationalCommand;
    DecrementIndent(): IRelationalCommandBuilder;
    IncrementIndent(): IRelationalCommandBuilder;
    RemoveParameterAt(index: int): IRelationalCommandBuilder;
    ToString(): string;
}


export const RelationalCommandBuilder: {
    new(dependencies: RelationalCommandBuilderDependencies): RelationalCommandBuilder;
};


export interface __RelationalCommandBuilder$views {
    As_IRelationalCommandBuilder(): IRelationalCommandBuilder$instance;
}

export type RelationalCommandBuilder = RelationalCommandBuilder$instance & __RelationalCommandBuilder$views;


export interface RelationalCommandBuilderDependencies$instance {
    ExceptionDetector: IExceptionDetector;
    LoggingOptions: ILoggingOptions;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalCommandBuilderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalCommandBuilderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalCommandBuilderDependencies: {
    new(typeMappingSource: IRelationalTypeMappingSource, exceptionDetector: IExceptionDetector, loggingOptions: ILoggingOptions): RelationalCommandBuilderDependencies;
};


export type RelationalCommandBuilderDependencies = RelationalCommandBuilderDependencies$instance;

export interface RelationalCommandBuilderFactory$instance {
    readonly Dependencies: RelationalCommandBuilderDependencies;
    Create(): IRelationalCommandBuilder;
}


export const RelationalCommandBuilderFactory: {
    new(dependencies: RelationalCommandBuilderDependencies): RelationalCommandBuilderFactory;
};


export interface __RelationalCommandBuilderFactory$views {
    As_IRelationalCommandBuilderFactory(): IRelationalCommandBuilderFactory$instance;
}

export interface RelationalCommandBuilderFactory$instance extends IRelationalCommandBuilderFactory$instance {}

export type RelationalCommandBuilderFactory = RelationalCommandBuilderFactory$instance & __RelationalCommandBuilderFactory$views;


export interface RelationalConnection$instance {
    CommandTimeout: Nullable<System_Internal.Int32>;
    readonly ConnectionId: Guid;
    get ConnectionString(): string | undefined;
    set ConnectionString(value: string | undefined);
    readonly Context: DbContext;
    readonly CurrentAmbientTransaction: Transaction | undefined;
    get CurrentTransaction(): IDbContextTransaction | undefined;
    set CurrentTransaction(value: IDbContextTransaction | undefined);
    DbConnection: DbConnection;
    readonly Dependencies: RelationalConnectionDependencies;
    get EnlistedTransaction(): Transaction | undefined;
    set EnlistedTransaction(value: Transaction | undefined);
    readonly SupportsAmbientTransactions: boolean;
    BeginTransaction(): IDbContextTransaction;
    BeginTransaction(isolationLevel: IsolationLevel): IDbContextTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    BeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<IDbContextTransaction>;
    Close(): boolean;
    CloseAsync(): Task<System_Internal.Boolean>;
    CloseDbConnection(): void;
    CloseDbConnectionAsync(): Task;
    CommitTransaction(): void;
    CommitTransactionAsync(cancellationToken?: CancellationToken): Task;
    ConnectionBeginTransaction(isolationLevel: IsolationLevel): DbTransaction;
    ConnectionBeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): ValueTask<DbTransaction>;
    ConnectionEnlistTransaction(transaction: Transaction): void;
    CreateDbConnection(): DbConnection;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    DisposeDbConnection(): void;
    DisposeDbConnectionAsync(): ValueTask;
    EnlistTransaction(transaction: Transaction): void;
    GetValidatedConnectionString(): string;
    Open(errorsExpected?: boolean): boolean;
    OpenAsync(cancellationToken: CancellationToken, errorsExpected?: boolean): Task<System_Internal.Boolean>;
    OpenDbConnection(errorsExpected: boolean): void;
    OpenDbConnectionAsync(errorsExpected: boolean, cancellationToken: CancellationToken): Task;
    RentCommand(): IRelationalCommand;
    ResetState(disposeDbConnection: boolean): void;
    ResetStateAsync(disposeDbConnection: boolean): ValueTask;
    ReturnCommand(command: IRelationalCommand): void;
    RollbackTransaction(): void;
    RollbackTransactionAsync(cancellationToken?: CancellationToken): Task;
    SetDbConnection(value: DbConnection, contextOwnsConnection: boolean): void;
    UseTransaction(transaction: DbTransaction): IDbContextTransaction | undefined;
    UseTransaction(transaction: DbTransaction, transactionId: Guid): IDbContextTransaction | undefined;
    UseTransactionAsync(transaction: DbTransaction, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
    UseTransactionAsync(transaction: DbTransaction, transactionId: Guid, cancellationToken?: CancellationToken): Task<IDbContextTransaction | undefined>;
}


export const RelationalConnection: (abstract new(dependencies: RelationalConnectionDependencies) => RelationalConnection) & {
};


export interface __RelationalConnection$views {
    As_IResettableService(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance;
    As_IDbContextTransactionManager(): IDbContextTransactionManager$instance;
    As_ITransactionEnlistmentManager(): ITransactionEnlistmentManager$instance;
    As_IRelationalConnection(): IRelationalConnection$instance;
    As_IRelationalTransactionManager(): IRelationalTransactionManager$instance;
}

export type RelationalConnection = RelationalConnection$instance & __RelationalConnection$views;


export interface RelationalConnectionDependencies$instance {
    ConnectionLogger: IRelationalConnectionDiagnosticsLogger;
    ConnectionStringResolver: INamedConnectionStringResolver;
    ContextOptions: IDbContextOptions;
    CurrentContext: ICurrentDbContext;
    ExceptionDetector: IExceptionDetector;
    RelationalCommandBuilderFactory: IRelationalCommandBuilderFactory;
    RelationalTransactionFactory: IRelationalTransactionFactory;
    TransactionLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>;
    _Clone_$(): RelationalConnectionDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalConnectionDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalConnectionDependencies: {
    new(contextOptions: IDbContextOptions, transactionLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, connectionLogger: IRelationalConnectionDiagnosticsLogger, connectionStringResolver: INamedConnectionStringResolver, relationalTransactionFactory: IRelationalTransactionFactory, currentContext: ICurrentDbContext, relationalCommandBuilderFactory: IRelationalCommandBuilderFactory, exceptionDetector: IExceptionDetector): RelationalConnectionDependencies;
};


export type RelationalConnectionDependencies = RelationalConnectionDependencies$instance;

export interface RelationalDatabase$instance extends Database$instance {
    readonly RelationalDependencies: RelationalDatabaseDependencies;
    CompileQuery<TResult>(query: Expression, async: boolean): Func<QueryContext, TResult>;
    CompileQueryExpression<TResult>(query: Expression, async: boolean): Expression<Func<QueryContext, TResult>>;
    SaveChanges(entries: IList<IUpdateEntry>): int;
    SaveChangesAsync(entries: IList<IUpdateEntry>, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export const RelationalDatabase: {
    new(dependencies: DatabaseDependencies, relationalDependencies: RelationalDatabaseDependencies): RelationalDatabase;
};


export interface __RelationalDatabase$views {
    As_IDatabase(): IDatabase$instance;
}

export type RelationalDatabase = RelationalDatabase$instance & __RelationalDatabase$views;


export interface RelationalDatabaseCreator$instance {
    readonly Dependencies: RelationalDatabaseCreatorDependencies;
    CanConnect(): boolean;
    CanConnectAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    Create(): void;
    CreateAsync(cancellationToken?: CancellationToken): Task;
    CreateTables(): void;
    CreateTablesAsync(cancellationToken?: CancellationToken): Task;
    Delete(): void;
    DeleteAsync(cancellationToken?: CancellationToken): Task;
    EnsureCreated(): boolean;
    EnsureCreatedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    EnsureDeleted(): boolean;
    EnsureDeletedAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    Exists(): boolean;
    ExistsAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
    GenerateCreateScript(): string;
    GetCreateTablesCommands(options?: MigrationsSqlGenerationOptions): IReadOnlyList<MigrationCommand>;
    HasTables(): boolean;
    HasTablesAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export const RelationalDatabaseCreator: (abstract new(dependencies: RelationalDatabaseCreatorDependencies) => RelationalDatabaseCreator) & {
};


export interface __RelationalDatabaseCreator$views {
    As_IDatabaseCreator(): IDatabaseCreator$instance;
    As_IRelationalDatabaseCreator(): IRelationalDatabaseCreator$instance;
}

export interface RelationalDatabaseCreator$instance extends IRelationalDatabaseCreator$instance {}

export type RelationalDatabaseCreator = RelationalDatabaseCreator$instance & __RelationalDatabaseCreator$views;


export interface RelationalDatabaseCreatorDependencies$instance {
    CommandLogger: IRelationalCommandDiagnosticsLogger;
    Connection: IRelationalConnection;
    ContextOptions: IDbContextOptions;
    CurrentContext: ICurrentDbContext;
    ExceptionDetector: IExceptionDetector;
    readonly ExecutionStrategy: IExecutionStrategy;
    MigrationCommandExecutor: IMigrationCommandExecutor;
    MigrationsSqlGenerator: IMigrationsSqlGenerator;
    ModelDiffer: IMigrationsModelDiffer;
    SqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): RelationalDatabaseCreatorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalDatabaseCreatorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalDatabaseCreatorDependencies: {
    new(connection: IRelationalConnection, modelDiffer: IMigrationsModelDiffer, migrationsSqlGenerator: IMigrationsSqlGenerator, migrationCommandExecutor: IMigrationCommandExecutor, sqlGenerationHelper: ISqlGenerationHelper, executionStrategy: IExecutionStrategy, currentContext: ICurrentDbContext, contextOptions: IDbContextOptions, commandLogger: IRelationalCommandDiagnosticsLogger, exceptionDetector: IExceptionDetector): RelationalDatabaseCreatorDependencies;
};


export type RelationalDatabaseCreatorDependencies = RelationalDatabaseCreatorDependencies$instance;

export interface RelationalDatabaseDependencies$instance {
    BatchExecutor: IBatchExecutor;
    BatchPreparer: ICommandBatchPreparer;
    Connection: IRelationalConnection;
    _Clone_$(): RelationalDatabaseDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalDatabaseDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalDatabaseDependencies: {
    new(batchPreparer: ICommandBatchPreparer, batchExecutor: IBatchExecutor, connection: IRelationalConnection): RelationalDatabaseDependencies;
};


export type RelationalDatabaseDependencies = RelationalDatabaseDependencies$instance;

export interface RelationalDataReader$instance {
    readonly CommandId: Guid;
    readonly DbCommand: DbCommand;
    readonly DbDataReader: DbDataReader;
    readonly RelationalConnection: IRelationalConnection;
    Close(): void;
    CloseAsync(): ValueTask;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Initialize(relationalConnection: IRelationalConnection, command: DbCommand, reader: DbDataReader, commandId: Guid, logger: IRelationalCommandDiagnosticsLogger): void;
    Read(): boolean;
    ReadAsync(cancellationToken?: CancellationToken): Task<System_Internal.Boolean>;
}


export const RelationalDataReader: {
    new(): RelationalDataReader;
};


export type RelationalDataReader = RelationalDataReader$instance;

export interface RelationalExecutionStrategyFactory$instance {
    readonly Dependencies: ExecutionStrategyDependencies;
    Create(): IExecutionStrategy;
    CreateDefaultStrategy(dependencies: ExecutionStrategyDependencies): IExecutionStrategy;
}


export const RelationalExecutionStrategyFactory: {
    new(dependencies: ExecutionStrategyDependencies): RelationalExecutionStrategyFactory;
};


export interface __RelationalExecutionStrategyFactory$views {
    As_IExecutionStrategyFactory(): IExecutionStrategyFactory$instance;
}

export interface RelationalExecutionStrategyFactory$instance extends IExecutionStrategyFactory$instance {}

export type RelationalExecutionStrategyFactory = RelationalExecutionStrategyFactory$instance & __RelationalExecutionStrategyFactory$views;


export interface RelationalGeometryTypeMapping_2$instance<TGeometry, TProvider> extends RelationalTypeMapping {
    readonly SpatialConverter: ValueConverter_2<TGeometry, TProvider> | undefined;
    readonly WktReaderType: Type;
    AsText(value: unknown): string;
    CreateParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    CreateParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    CustomizeDataReaderExpression(expression: Expression): Expression;
    GenerateCodeLiteral(value: unknown): Expression;
    GetSrid(value: unknown): int;
}


export const RelationalGeometryTypeMapping_2: (abstract new<TGeometry, TProvider>(converter: ValueConverter_2<TGeometry, TProvider>, storeType: string, jsonValueReaderWriter: JsonValueReaderWriter) => RelationalGeometryTypeMapping_2<TGeometry, TProvider>) & (abstract new<TGeometry, TProvider>(parameters: unknown, converter: ValueConverter_2<TGeometry, TProvider>) => RelationalGeometryTypeMapping_2<TGeometry, TProvider>) & {
};


export type RelationalGeometryTypeMapping_2<TGeometry, TProvider> = RelationalGeometryTypeMapping_2$instance<TGeometry, TProvider>;

export interface RelationalSqlGenerationHelper$instance {
    readonly BatchTerminator: string;
    readonly CommitTransactionStatement: string;
    readonly Dependencies: RelationalSqlGenerationHelperDependencies;
    readonly SingleLineCommentToken: string;
    readonly StartTransactionStatement: string;
    readonly StatementTerminator: string;
    DelimitIdentifier(identifier: string): string;
    DelimitIdentifier(builder: StringBuilder, identifier: string): void;
    DelimitIdentifier(name: string, schema: string): string;
    DelimitIdentifier(builder: StringBuilder, name: string, schema: string): void;
    DelimitJsonPathElement(pathElement: string): string;
    EscapeIdentifier(identifier: string): string;
    EscapeIdentifier(builder: StringBuilder, identifier: string): void;
    EscapeJsonPathElement(identifier: string): string;
    GenerateComment(text: string): string;
    GenerateCreateSavepointStatement(name: string): string;
    GenerateParameterName(name: string): string;
    GenerateParameterName(builder: StringBuilder, name: string): void;
    GenerateParameterNamePlaceholder(name: string): string;
    GenerateParameterNamePlaceholder(builder: StringBuilder, name: string): void;
    GenerateReleaseSavepointStatement(name: string): string;
    GenerateRollbackToSavepointStatement(name: string): string;
}


export const RelationalSqlGenerationHelper: {
    new(dependencies: RelationalSqlGenerationHelperDependencies): RelationalSqlGenerationHelper;
};


export interface __RelationalSqlGenerationHelper$views {
    As_ISqlGenerationHelper(): ISqlGenerationHelper$instance;
}

export type RelationalSqlGenerationHelper = RelationalSqlGenerationHelper$instance & __RelationalSqlGenerationHelper$views;


export interface RelationalSqlGenerationHelperDependencies$instance {
    _Clone_$(): RelationalSqlGenerationHelperDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalSqlGenerationHelperDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalSqlGenerationHelperDependencies: {
    new(): RelationalSqlGenerationHelperDependencies;
};


export type RelationalSqlGenerationHelperDependencies = RelationalSqlGenerationHelperDependencies$instance;

export interface RelationalTransaction$instance {
    readonly Connection: IRelationalConnection;
    readonly Logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>;
    readonly SupportsSavepoints: boolean;
    readonly TransactionId: Guid;
    ClearTransaction(): void;
    ClearTransactionAsync(cancellationToken?: CancellationToken): Task;
    Commit(): void;
    CommitAsync(cancellationToken?: CancellationToken): Task;
    CreateSavepoint(name: string): void;
    CreateSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    ReleaseSavepoint(name: string): void;
    ReleaseSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
    Rollback(): void;
    RollbackAsync(cancellationToken?: CancellationToken): Task;
    RollbackToSavepoint(name: string): void;
    RollbackToSavepointAsync(name: string, cancellationToken?: CancellationToken): Task;
}


export const RelationalTransaction: {
    new(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean, sqlGenerationHelper: ISqlGenerationHelper): RelationalTransaction;
};


export interface __RelationalTransaction$views {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<DbTransaction>;
    As_IDbContextTransaction(): IDbContextTransaction$instance;
}

export interface RelationalTransaction$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<DbTransaction>, IDbContextTransaction$instance {}

export type RelationalTransaction = RelationalTransaction$instance & __RelationalTransaction$views;


export interface RelationalTransactionFactory$instance {
    readonly Dependencies: RelationalTransactionFactoryDependencies;
    Create(connection: IRelationalConnection, transaction: DbTransaction, transactionId: Guid, logger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Transaction>, transactionOwned: boolean): RelationalTransaction;
}


export const RelationalTransactionFactory: {
    new(dependencies: RelationalTransactionFactoryDependencies): RelationalTransactionFactory;
};


export interface __RelationalTransactionFactory$views {
    As_IRelationalTransactionFactory(): IRelationalTransactionFactory$instance;
}

export interface RelationalTransactionFactory$instance extends IRelationalTransactionFactory$instance {}

export type RelationalTransactionFactory = RelationalTransactionFactory$instance & __RelationalTransactionFactory$views;


export interface RelationalTransactionFactoryDependencies$instance {
    SqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): RelationalTransactionFactoryDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalTransactionFactoryDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalTransactionFactoryDependencies: {
    new(sqlGenerationHelper: ISqlGenerationHelper): RelationalTransactionFactoryDependencies;
};


export type RelationalTransactionFactoryDependencies = RelationalTransactionFactoryDependencies$instance;

export interface RelationalTypeMapping$instance extends CoreTypeMapping {
    readonly DbType: Nullable<DbType>;
    readonly IsFixedLength: boolean;
    readonly IsUnicode: boolean;
    readonly Parameters: unknown;
    readonly Precision: Nullable<System_Internal.Int32>;
    readonly Scale: Nullable<System_Internal.Int32>;
    readonly Size: Nullable<System_Internal.Int32>;
    readonly SqlLiteralFormatString: string;
    readonly StoreType: string;
    readonly StoreTypeNameBase: string;
    readonly StoreTypePostfix: StoreTypePostfix;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    ConfigureParameter(parameter: DbParameter): void;
    CreateParameter(command: DbCommand, name: string, value: unknown, nullable?: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): DbParameter;
    CustomizeDataReaderExpression(expression: Expression): Expression;
    GenerateNonNullSqlLiteral(value: unknown): string;
    GenerateProviderValueSqlLiteral(value: unknown): string;
    GenerateSqlLiteral(value: unknown): string;
    GetDataReaderMethod(): MethodInfo;
    ProcessStoreType(parameters: unknown, storeType: string, storeTypeNameBase: string): string;
    WithComposedConverter(converter: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    WithPrecisionAndScale(precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): RelationalTypeMapping;
    WithStoreTypeAndSize(storeType: string, size: Nullable<System_Internal.Int32>): RelationalTypeMapping;
    WithTypeMappingInfo(mappingInfo: RelationalTypeMappingInfo): RelationalTypeMapping;
}


export const RelationalTypeMapping: (abstract new(parameters: unknown) => RelationalTypeMapping) & (abstract new(storeType: string, clrType: Type, dbType: Nullable<DbType>, unicode: boolean, size: Nullable<System_Internal.Int32>, fixedLength: boolean, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, jsonValueReaderWriter: JsonValueReaderWriter) => RelationalTypeMapping) & {
    readonly NullMapping: RelationalTypeMapping;
    GetDataReaderMethod(type: Type): MethodInfo;
};


export type RelationalTypeMapping = RelationalTypeMapping$instance;

export interface RelationalTypeMappingSource$instance extends TypeMappingSourceBase$instance {
    readonly RelationalDependencies: RelationalTypeMappingSourceDependencies;
    FindCollectionMapping(info: RelationalTypeMappingInfo, modelType: Type, providerType: Type, elementMapping: CoreTypeMapping): RelationalTypeMapping | undefined;
    FindMapping(mappingInfo: RelationalTypeMappingInfo): RelationalTypeMapping | undefined;
    FindMapping(mappingInfo: TypeMappingInfo): CoreTypeMapping;
    FindMapping(property: IProperty): CoreTypeMapping | undefined;
    FindMapping(elementType: IElementType): CoreTypeMapping | undefined;
    FindMapping(type: Type): RelationalTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): RelationalTypeMapping | undefined;
    FindMapping(member: MemberInfo): RelationalTypeMapping | undefined;
    FindMapping(storeTypeName: string): RelationalTypeMapping | undefined;
    FindMapping(type: Type): CoreTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    ParseStoreTypeName(storeTypeName: string, unicode: Nullable<System_Internal.Boolean>, size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>): string | undefined;
}


export const RelationalTypeMappingSource: (abstract new(dependencies: TypeMappingSourceDependencies, relationalDependencies: RelationalTypeMappingSourceDependencies) => RelationalTypeMappingSource) & {
};


export interface __RelationalTypeMappingSource$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
    As_IRelationalTypeMappingSource(): IRelationalTypeMappingSource$instance;
}

export type RelationalTypeMappingSource = RelationalTypeMappingSource$instance & __RelationalTypeMappingSource$views;


export interface RelationalTypeMappingSourceDependencies$instance {
    Plugins: IEnumerable<IRelationalTypeMappingSourcePlugin>;
    _Clone_$(): RelationalTypeMappingSourceDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalTypeMappingSourceDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalTypeMappingSourceDependencies: {
    new(plugins: IEnumerable<IRelationalTypeMappingSourcePlugin>): RelationalTypeMappingSourceDependencies;
};


export type RelationalTypeMappingSourceDependencies = RelationalTypeMappingSourceDependencies$instance;

export interface RetryLimitExceededException$instance extends Exception {
}


export const RetryLimitExceededException: {
    new(): RetryLimitExceededException;
    new(message: string): RetryLimitExceededException;
    new(message: string, innerException: Exception): RetryLimitExceededException;
    new(info: SerializationInfo, context: StreamingContext): RetryLimitExceededException;
};


export type RetryLimitExceededException = RetryLimitExceededException$instance;

export interface SByteTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const SByteTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): SByteTypeMapping;
    readonly Default: SByteTypeMapping;
};


export type SByteTypeMapping = SByteTypeMapping$instance;

export interface ShortTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const ShortTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ShortTypeMapping;
    readonly Default: ShortTypeMapping;
};


export type ShortTypeMapping = ShortTypeMapping$instance;

export interface StringTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    EscapeSqlLiteral(literal: string): string;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const StringTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>, unicode: boolean, size: Nullable<System_Internal.Int32>): StringTypeMapping;
    readonly Default: StringTypeMapping;
};


export type StringTypeMapping = StringTypeMapping$instance;

export interface TimeOnlyTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
    GenerateNonNullSqlLiteral(value: unknown): string;
}


export const TimeOnlyTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): TimeOnlyTypeMapping;
    readonly Default: TimeOnlyTypeMapping;
};


export type TimeOnlyTypeMapping = TimeOnlyTypeMapping$instance;

export interface TimeSpanTypeMapping$instance extends RelationalTypeMapping {
    readonly SqlLiteralFormatString: string;
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const TimeSpanTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): TimeSpanTypeMapping;
    readonly Default: TimeSpanTypeMapping;
};


export type TimeSpanTypeMapping = TimeSpanTypeMapping$instance;

export interface TypeMappingSource$instance extends TypeMappingSourceBase$instance {
    FindCollectionMapping(info: TypeMappingInfo, modelType: Type, providerType: Type, elementMapping: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(property: IProperty): CoreTypeMapping | undefined;
    FindMapping(elementType: IElementType): CoreTypeMapping | undefined;
    FindMapping(type: Type): CoreTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    FindMapping(mappingInfo: TypeMappingInfo): CoreTypeMapping | undefined;
}


export const TypeMappingSource: (abstract new(dependencies: TypeMappingSourceDependencies) => TypeMappingSource) & {
};


export interface __TypeMappingSource$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
}

export type TypeMappingSource = TypeMappingSource$instance & __TypeMappingSource$views;


export interface TypeMappingSourceBase$instance {
    readonly Dependencies: TypeMappingSourceDependencies;
    FindMapping(mappingInfo: TypeMappingInfo): CoreTypeMapping | undefined;
    FindMapping(property: IProperty): CoreTypeMapping | undefined;
    FindMapping(elementType: IElementType): CoreTypeMapping | undefined;
    FindMapping(type: Type): CoreTypeMapping | undefined;
    FindMapping(type: Type, model: IModel, elementMapping?: CoreTypeMapping): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo): CoreTypeMapping | undefined;
    FindMapping(member: MemberInfo, model: IModel, useAttributes: boolean): CoreTypeMapping | undefined;
    TryFindJsonCollectionMapping(mappingInfo: TypeMappingInfo, modelClrType: Type, providerClrType: Type, elementMapping: CoreTypeMapping, elementComparer: ValueComparer, collectionReaderWriter: JsonValueReaderWriter): boolean;
    ValidateMapping(mapping: CoreTypeMapping, property: IProperty): void;
}


export const TypeMappingSourceBase: (abstract new(dependencies: TypeMappingSourceDependencies) => TypeMappingSourceBase) & {
};


export interface __TypeMappingSourceBase$views {
    As_ITypeMappingSource(): ITypeMappingSource$instance;
}

export type TypeMappingSourceBase = TypeMappingSourceBase$instance & __TypeMappingSourceBase$views;


export interface TypeMappingSourceDependencies$instance {
    readonly JsonValueReaderWriterSource: IJsonValueReaderWriterSource;
    Plugins: IEnumerable<ITypeMappingSourcePlugin>;
    ValueConverterSelector: IValueConverterSelector;
    _Clone_$(): TypeMappingSourceDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: TypeMappingSourceDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const TypeMappingSourceDependencies: {
    new(valueConverterSelector: IValueConverterSelector, jsonValueReaderWriterSource: IJsonValueReaderWriterSource, plugins: IEnumerable<ITypeMappingSourcePlugin>): TypeMappingSourceDependencies;
};


export type TypeMappingSourceDependencies = TypeMappingSourceDependencies$instance;

export interface TypeMaterializationInfo$instance {
    readonly IsNullable: Nullable<System_Internal.Boolean>;
    readonly Mapping: RelationalTypeMapping;
    readonly ModelClrType: Type;
    readonly Property: IProperty | undefined;
    readonly ProviderClrType: Type;
    Equals(other: TypeMaterializationInfo): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const TypeMaterializationInfo: {
    new(modelClrType: Type, property: IProperty, mapping: RelationalTypeMapping, nullable: Nullable<System_Internal.Boolean>): TypeMaterializationInfo;
};


export type TypeMaterializationInfo = TypeMaterializationInfo$instance;

export interface UIntTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const UIntTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): UIntTypeMapping;
    readonly Default: UIntTypeMapping;
};


export type UIntTypeMapping = UIntTypeMapping$instance;

export interface ULongTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const ULongTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): ULongTypeMapping;
    readonly Default: ULongTypeMapping;
};


export type ULongTypeMapping = ULongTypeMapping$instance;

export interface UShortTypeMapping$instance extends RelationalTypeMapping {
    Clone(parameters: unknown): RelationalTypeMapping;
    Clone(parameters: unknown): CoreTypeMapping;
    Clone(mappingInfo?: Nullable<RelationalTypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter, storeTypePostfix?: Nullable<StoreTypePostfix>): RelationalTypeMapping;
    Clone(mappingInfo?: Nullable<TypeMappingInfo>, clrType?: Type, converter?: ValueConverter, comparer?: ValueComparer, keyComparer?: ValueComparer, providerValueComparer?: ValueComparer, elementMapping?: CoreTypeMapping, jsonValueReaderWriter?: JsonValueReaderWriter): CoreTypeMapping;
}


export const UShortTypeMapping: {
    new(storeType: string, dbType: Nullable<DbType>): UShortTypeMapping;
    readonly Default: UShortTypeMapping;
};


export type UShortTypeMapping = UShortTypeMapping$instance;

export abstract class DbContextTransactionExtensions$instance {
    static GetDbTransaction(dbContextTransaction: IDbContextTransaction): DbTransaction;
}


export type DbContextTransactionExtensions = DbContextTransactionExtensions$instance;

export abstract class RelationalCommandBuilderExtensions$instance {
    static AddCompositeParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, subParameters: IReadOnlyList<IRelationalParameter>): IRelationalCommandBuilder;
    static AddParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, name: string, relationalTypeMapping: RelationalTypeMapping, nullable: Nullable<System_Internal.Boolean>, direction?: ParameterDirection): IRelationalCommandBuilder;
    static AddParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, name: string): IRelationalCommandBuilder;
    static AddRawParameter(commandBuilder: IRelationalCommandBuilder, invariantName: string, dbParameter: DbParameter): IRelationalCommandBuilder;
    static AppendLine(commandBuilder: IRelationalCommandBuilder, value: FormattableString): IRelationalCommandBuilder;
    static AppendLine(commandBuilder: IRelationalCommandBuilder, value: string): IRelationalCommandBuilder;
    static AppendLines(commandBuilder: IRelationalCommandBuilder, value: string, skipFinalNewline?: boolean): IRelationalCommandBuilder;
    static Indent(commandBuilder: IRelationalCommandBuilder): IDisposable;
}


export type RelationalCommandBuilderExtensions = RelationalCommandBuilderExtensions$instance;

export abstract class RelationalExecutionStrategyExtensions$instance {
    static ExecuteInTransaction<TResult>(strategy: IExecutionStrategy, operation: Func<TResult>, verifySucceeded: Func<System_Internal.Boolean>, isolationLevel: IsolationLevel): TResult;
    static ExecuteInTransaction(strategy: IExecutionStrategy, operation: Action, verifySucceeded: Func<System_Internal.Boolean>, isolationLevel: IsolationLevel): void;
    static ExecuteInTransaction<TState>(strategy: IExecutionStrategy, state: TState, operation: Action<TState>, verifySucceeded: Func<TState, System_Internal.Boolean>, isolationLevel: IsolationLevel): void;
    static ExecuteInTransaction<TState, TResult>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, TResult>, verifySucceeded: Func<TState, System_Internal.Boolean>, isolationLevel: IsolationLevel): TResult;
    static ExecuteInTransactionAsync<TResult>(strategy: IExecutionStrategy, operation: Func<CancellationToken, Task<TResult>>, verifySucceeded: Func<CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<TResult>;
    static ExecuteInTransactionAsync(strategy: IExecutionStrategy, operation: Func<Task>, verifySucceeded: Func<Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel): Task;
    static ExecuteInTransactionAsync(strategy: IExecutionStrategy, operation: Func<CancellationToken, Task>, verifySucceeded: Func<CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task;
    static ExecuteInTransactionAsync<TState>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, CancellationToken, Task>, verifySucceeded: Func<TState, CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task;
    static ExecuteInTransactionAsync<TState, TResult>(strategy: IExecutionStrategy, state: TState, operation: Func<TState, CancellationToken, Task<TResult>>, verifySucceeded: Func<TState, CancellationToken, Task<System_Internal.Boolean>>, isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): Task<TResult>;
}


export type RelationalExecutionStrategyExtensions = RelationalExecutionStrategyExtensions$instance;

export abstract class RelationalTypeMappingSourceExtensions$instance {
    static GetMapping(typeMappingSource: IRelationalTypeMappingSource, property: IProperty): RelationalTypeMapping;
    static GetMapping(typeMappingSource: IRelationalTypeMappingSource, typeName: string): RelationalTypeMapping;
    static GetMapping(typeMappingSource: IRelationalTypeMappingSource, clrType: Type, model: IModel): RelationalTypeMapping;
    static GetMapping(typeMappingSource: IRelationalTypeMappingSource, clrType: Type): RelationalTypeMapping;
    static GetMappingForValue(typeMappingSource: IRelationalTypeMappingSource, value: unknown, model: IModel): RelationalTypeMapping;
    static GetMappingForValue(typeMappingSource: IRelationalTypeMappingSource, value: unknown): RelationalTypeMapping;
}


export type RelationalTypeMappingSourceExtensions = RelationalTypeMappingSourceExtensions$instance;

