// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.ValueGeneration
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { EntityEntry } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IProperty, ITypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { ValueConverter } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, Func, Guid, IDisposable, IEquatable, Int32, Int64, Object as ClrObject, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface IValueGeneratorCache$instance {
    getOrAdd(property: IProperty, typeBase: ITypeBase, factory: Func<IProperty, ITypeBase, ValueGenerator>): ValueGenerator | undefined;
}


export type IValueGeneratorCache = IValueGeneratorCache$instance;

export interface IValueGeneratorSelector$instance {
    select(property: IProperty, typeBase: ITypeBase): ValueGenerator | undefined;
    trySelect(property: IProperty, typeBase: ITypeBase, valueGenerator: ValueGenerator): boolean;
}


export type IValueGeneratorSelector = IValueGeneratorSelector$instance;

export interface BinaryValueGenerator$instance extends ValueGenerator_1<byte[]> {
    readonly generatesTemporaryValues: boolean;
    next4(entry: EntityEntry): byte[];
    next4(entry: EntityEntry): unknown;
}


export const BinaryValueGenerator: {
    new(): BinaryValueGenerator;
};


export type BinaryValueGenerator = BinaryValueGenerator$instance;

export interface DiscriminatorValueGeneratorFactory$instance extends ValueGeneratorFactory {
    create(property: IProperty, entityType: ITypeBase): ValueGenerator;
}


export const DiscriminatorValueGeneratorFactory: {
    new(): DiscriminatorValueGeneratorFactory;
};


export type DiscriminatorValueGeneratorFactory = DiscriminatorValueGeneratorFactory$instance;

export interface GuidValueGenerator$instance extends ValueGenerator_1<Guid> {
    readonly generatesTemporaryValues: boolean;
    next4(entry: EntityEntry): Guid;
    next4(entry: EntityEntry): unknown;
}


export const GuidValueGenerator: {
    new(): GuidValueGenerator;
};


export type GuidValueGenerator = GuidValueGenerator$instance;

export interface HiLoValueGenerator_1$instance<TValue> extends ValueGenerator_1<TValue> {
    next(entry: EntityEntry): TValue;
    next(entry: EntityEntry): unknown;
    nextAsync(entry: EntityEntry, cancellationToken?: CancellationToken): ValueTask<TValue>;
    nextAsync(entry: EntityEntry, cancellationToken?: CancellationToken): ValueTask<TValue>;
}


export const HiLoValueGenerator_1: {
};


export type HiLoValueGenerator_1<TValue> = HiLoValueGenerator_1$instance<TValue>;

export interface HiLoValueGeneratorState$instance {
    dispose(): void;
    next<TValue>(getNewLowValue: Func<System_Internal.Int64>): TValue;
    nextAsync<TValue>(getNewLowValue: Func<CancellationToken, Task<System_Internal.Int64>>, cancellationToken?: CancellationToken): ValueTask<TValue>;
}


export const HiLoValueGeneratorState: {
    new(blockSize: int): HiLoValueGeneratorState;
};


export type HiLoValueGeneratorState = HiLoValueGeneratorState$instance;

export interface RelationalValueGeneratorSelector$instance extends ValueGeneratorSelector$instance {
    select(property: IProperty, typeBase: ITypeBase): ValueGenerator | undefined;
    trySelect(property: IProperty, typeBase: ITypeBase, valueGenerator: ValueGenerator): boolean;
}


export const RelationalValueGeneratorSelector: {
    new(dependencies: ValueGeneratorSelectorDependencies): RelationalValueGeneratorSelector;
};


export interface __RelationalValueGeneratorSelector$views {
    As_IValueGeneratorSelector(): IValueGeneratorSelector$instance;
}

export type RelationalValueGeneratorSelector = RelationalValueGeneratorSelector$instance & __RelationalValueGeneratorSelector$views;


export interface SequentialGuidValueGenerator$instance extends ValueGenerator_1<Guid> {
    readonly generatesTemporaryValues: boolean;
    next4(entry: EntityEntry): Guid;
    next4(entry: EntityEntry): unknown;
}


export const SequentialGuidValueGenerator: {
    new(): SequentialGuidValueGenerator;
};


export type SequentialGuidValueGenerator = SequentialGuidValueGenerator$instance;

export interface StringValueGenerator$instance extends ValueGenerator_1<System_Internal.String> {
    readonly generatesTemporaryValues: boolean;
    next4(entry: EntityEntry): string;
    next4(entry: EntityEntry): unknown;
}


export const StringValueGenerator: {
    new(): StringValueGenerator;
};


export type StringValueGenerator = StringValueGenerator$instance;

export interface TemporaryGuidValueGenerator$instance extends GuidValueGenerator {
    readonly generatesTemporaryValues: boolean;
}


export const TemporaryGuidValueGenerator: {
    new(): TemporaryGuidValueGenerator;
};


export type TemporaryGuidValueGenerator = TemporaryGuidValueGenerator$instance;

export interface TemporaryNumberValueGeneratorFactory$instance extends ValueGeneratorFactory {
    create(property: IProperty, entityType: ITypeBase): ValueGenerator;
}


export const TemporaryNumberValueGeneratorFactory: {
    new(): TemporaryNumberValueGeneratorFactory;
};


export type TemporaryNumberValueGeneratorFactory = TemporaryNumberValueGeneratorFactory$instance;

export interface ValueGenerator$instance {
    readonly generatesStableValues: boolean;
    readonly generatesTemporaryValues: boolean;
    next(entry: EntityEntry): unknown;
    nextAsync(entry: EntityEntry, cancellationToken?: CancellationToken): ValueTask<unknown>;
    withConverter(converter: ValueConverter): ValueGenerator;
}


export const ValueGenerator: {
};


export type ValueGenerator = ValueGenerator$instance;

export interface ValueGenerator_1$instance<TValue> extends ValueGenerator {
    next(entry: EntityEntry): TValue;
    next(entry: EntityEntry): unknown;
    nextAsync(entry: EntityEntry, cancellationToken?: CancellationToken): ValueTask<TValue>;
    nextAsync(entry: EntityEntry, cancellationToken?: CancellationToken): ValueTask<unknown>;
}


export const ValueGenerator_1: {
};


export type ValueGenerator_1<TValue> = ValueGenerator_1$instance<TValue>;

export interface ValueGeneratorCache$instance {
    getOrAdd(property: IProperty, typeBase: ITypeBase, factory: Func<IProperty, ITypeBase, ValueGenerator>): ValueGenerator | undefined;
}


export const ValueGeneratorCache: {
    new(dependencies: ValueGeneratorCacheDependencies): ValueGeneratorCache;
};


export interface __ValueGeneratorCache$views {
    As_IValueGeneratorCache(): IValueGeneratorCache$instance;
}

export interface ValueGeneratorCache$instance extends IValueGeneratorCache$instance {}

export type ValueGeneratorCache = ValueGeneratorCache$instance & __ValueGeneratorCache$views;


export interface ValueGeneratorCacheDependencies$instance {
    _Clone_$(): ValueGeneratorCacheDependencies;
    equals(obj: unknown): boolean;
    equals(other: ValueGeneratorCacheDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ValueGeneratorCacheDependencies: {
    new(): ValueGeneratorCacheDependencies;
};


export type ValueGeneratorCacheDependencies = ValueGeneratorCacheDependencies$instance;

export interface ValueGeneratorFactory$instance {
    create(property: IProperty, typeBase: ITypeBase): ValueGenerator;
}


export const ValueGeneratorFactory: {
};


export type ValueGeneratorFactory = ValueGeneratorFactory$instance;

export interface ValueGeneratorSelector$instance {
    readonly cache: IValueGeneratorCache;
    create(property: IProperty, typeBase: ITypeBase): ValueGenerator;
    select(property: IProperty, typeBase: ITypeBase): ValueGenerator | undefined;
    tryCreate(property: IProperty, typeBase: ITypeBase, valueGenerator: ValueGenerator): boolean;
    trySelect(property: IProperty, typeBase: ITypeBase, valueGenerator: ValueGenerator): boolean;
}


export const ValueGeneratorSelector: {
    new(dependencies: ValueGeneratorSelectorDependencies): ValueGeneratorSelector;
};


export interface __ValueGeneratorSelector$views {
    As_IValueGeneratorSelector(): IValueGeneratorSelector$instance;
}

export interface ValueGeneratorSelector$instance extends IValueGeneratorSelector$instance {}

export type ValueGeneratorSelector = ValueGeneratorSelector$instance & __ValueGeneratorSelector$views;


export interface ValueGeneratorSelectorDependencies$instance {
    cache: IValueGeneratorCache;
    _Clone_$(): ValueGeneratorSelectorDependencies;
    equals(obj: unknown): boolean;
    equals(other: ValueGeneratorSelectorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ValueGeneratorSelectorDependencies: {
    new(cache: IValueGeneratorCache): ValueGeneratorSelectorDependencies;
};


export type ValueGeneratorSelectorDependencies = ValueGeneratorSelectorDependencies$instance;

