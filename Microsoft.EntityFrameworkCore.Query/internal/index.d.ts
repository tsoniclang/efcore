// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Query
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Abstractions, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { InternalEntityEntry, ISnapshot, IStateManager } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { CommandSource, IDiagnosticsLogger_1, IInterceptors, IRelationalCommandDiagnosticsLogger, ISingletonInterceptor } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import type { IAnnotation, IConcurrencyDetector, ICoreSingletonOptions, ICurrentDbContext, IDbContextOptions } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IDbContextServices } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import type { IClrCollectionAccessor, IComplexProperty, IComplexType, IEntityType, IKey, IModel, INavigation, INavigationBase, IProperty, IPropertyBase, ITableBase, ITypeBase, MemberIdentity } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { RelationalCommandResolver, ResultContext, SingleQueryResultCoordinator, SplitQueryResultCoordinator } from "../../Microsoft.EntityFrameworkCore.Query.Internal/internal/index.js";
import type { CaseWhenClause, ColumnExpression, OrderingExpression, SelectExpression, SqlExpression, SqlParameterExpression } from "../../Microsoft.EntityFrameworkCore.Query.SqlExpressions/internal/index.js";
import type { JsonReaderData } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { IExceptionDetector, IExecutionStrategy, IParameterNameGeneratorFactory, IRelationalCommand, IRelationalCommandBuilderFactory, IRelationalConnection, IRelationalTypeMappingSource, ISqlGenerationHelper, ITypeMappingSource, MaterializationContext, ReaderColumn, RelationalCommandBuilderDependencies, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { DbContext, DbLoggerCategory_Database_Command, DbLoggerCategory_Query, ParameterTranslationMode, QuerySplittingBehavior, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Dictionary, HashSet, IAsyncEnumerable, ICollection, IEnumerable as IEnumerable__System_Collections_Generic, IEqualityComparer, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList, ISet, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import type { DbCommand, DbDataReader } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Attribute, Boolean as ClrBoolean, Enum, Exception, Func, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Linq_Expressions_Internal from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { ConstantExpression, Expression, ExpressionType, ExpressionVisitor, LambdaExpression, NewArrayExpression, ParameterExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import * as System_Linq_Internal from "@tsonic/dotnet/System.Linq.js";
import type { IQueryable, IQueryProvider } from "@tsonic/dotnet/System.Linq.js";
import type { MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { IMemoryCache } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Caching.Memory.js";

export enum ResultCardinality {
    enumerable = 0,
    single = 1,
    singleOrDefault = 2
}


export interface IAggregateMethodCallTranslator$instance {
    translate(method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IAggregateMethodCallTranslator = IAggregateMethodCallTranslator$instance;

export interface IAggregateMethodCallTranslatorPlugin$instance {
    readonly translators: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslator>;
}


export type IAggregateMethodCallTranslatorPlugin = IAggregateMethodCallTranslatorPlugin$instance;

export interface IAggregateMethodCallTranslatorProvider$instance {
    translate(model: IModel, method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IAggregateMethodCallTranslatorProvider = IAggregateMethodCallTranslatorProvider$instance;

export interface IAsyncQueryProvider$instance extends IQueryProvider {
    executeAsync<TResult>(expression: Expression, cancellationToken?: CancellationToken): TResult;
}


export type IAsyncQueryProvider = IAsyncQueryProvider$instance;

export interface ICompiledQueryCacheKeyGenerator$instance {
    generateCacheKey(query: Expression, async_: boolean): unknown;
}


export type ICompiledQueryCacheKeyGenerator = ICompiledQueryCacheKeyGenerator$instance;

export interface IEntityMaterializerSource$instance {
}


export type IEntityMaterializerSource = IEntityMaterializerSource$instance;

export interface IEvaluatableExpressionFilter$instance {
    isEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export type IEvaluatableExpressionFilter = IEvaluatableExpressionFilter$instance;

export interface IEvaluatableExpressionFilterPlugin$instance {
    isEvaluatableExpression(expression: Expression): boolean;
}


export type IEvaluatableExpressionFilterPlugin = IEvaluatableExpressionFilterPlugin$instance;

export interface IIncludableQueryable_2$instance<TEntity, TProperty> extends IQueryable<TEntity>, IEnumerable__System_Collections_Generic<TEntity>, IEnumerable, IQueryable {
}


export type IIncludableQueryable_2<TEntity, TProperty> = IIncludableQueryable_2$instance<TEntity, TProperty>;

export interface ILiftableConstantFactory$instance {
    createLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type_: Type): Expression;
}


export type ILiftableConstantFactory = ILiftableConstantFactory$instance;

export interface ILiftableConstantProcessor$instance {
    readonly liftedConstants: IReadOnlyList<ValueTuple<ParameterExpression, Expression>>;
    inlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    liftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
}


export type ILiftableConstantProcessor = ILiftableConstantProcessor$instance;

export interface IMemberTranslator$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMemberTranslator = IMemberTranslator$instance;

export interface IMemberTranslatorPlugin$instance {
    readonly translators: IEnumerable__System_Collections_Generic<IMemberTranslator>;
}


export type IMemberTranslatorPlugin = IMemberTranslatorPlugin$instance;

export interface IMemberTranslatorProvider$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMemberTranslatorProvider = IMemberTranslatorProvider$instance;

export interface IMethodCallTranslator$instance {
    translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMethodCallTranslator = IMethodCallTranslator$instance;

export interface IMethodCallTranslatorPlugin$instance {
    readonly translators: IEnumerable__System_Collections_Generic<IMethodCallTranslator>;
}


export type IMethodCallTranslatorPlugin = IMethodCallTranslatorPlugin$instance;

export interface IMethodCallTranslatorProvider$instance {
    translate(model: IModel, instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMethodCallTranslatorProvider = IMethodCallTranslatorProvider$instance;

export interface INavigationExpansionExtensibilityHelper$instance {
    areQueryRootsCompatible(first: EntityQueryRootExpression, second: EntityQueryRootExpression): boolean;
    createQueryRoot(entityType: IEntityType, source: EntityQueryRootExpression): EntityQueryRootExpression;
    validateQueryRootCreation(entityType: IEntityType, source: EntityQueryRootExpression): void;
}


export type INavigationExpansionExtensibilityHelper = INavigationExpansionExtensibilityHelper$instance;

export interface IPrintableExpression$instance {
    print(expressionPrinter: ExpressionPrinter): void;
}


export type IPrintableExpression = IPrintableExpression$instance;

export interface IQueryableMethodTranslatingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): QueryableMethodTranslatingExpressionVisitor;
}


export type IQueryableMethodTranslatingExpressionVisitorFactory = IQueryableMethodTranslatingExpressionVisitorFactory$instance;

export interface IQueryCompilationContextFactory$instance {
    create(async_: boolean): QueryCompilationContext;
}


export type IQueryCompilationContextFactory = IQueryCompilationContextFactory$instance;

export interface IQueryContextFactory$instance {
    create(): QueryContext;
}


export type IQueryContextFactory = IQueryContextFactory$instance;

export interface IQueryingEnumerable$instance {
    toQueryString(): string;
}


export type IQueryingEnumerable = IQueryingEnumerable$instance;

export interface IQuerySqlGeneratorFactory$instance {
    create(): QuerySqlGenerator;
}


export type IQuerySqlGeneratorFactory = IQuerySqlGeneratorFactory$instance;

export interface IQueryTranslationPostprocessorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): QueryTranslationPostprocessor;
}


export type IQueryTranslationPostprocessorFactory = IQueryTranslationPostprocessorFactory$instance;

export interface IQueryTranslationPreprocessorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): QueryTranslationPreprocessor;
}


export type IQueryTranslationPreprocessorFactory = IQueryTranslationPreprocessorFactory$instance;

export interface IRelationalLiftableConstantFactory$instance extends ILiftableConstantFactory {
    createLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type_: Type): Expression;
    createLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<RelationalMaterializerLiftableConstantContext, unknown>>, variableName: string, type_: Type): LiftableConstantExpression;
}


export interface IRelationalLiftableConstantFactory$instance extends ILiftableConstantFactory$instance {}

export type IRelationalLiftableConstantFactory = IRelationalLiftableConstantFactory$instance;

export interface IRelationalParameterBasedSqlProcessorFactory$instance {
    create(parameters: RelationalParameterBasedSqlProcessorParameters): RelationalParameterBasedSqlProcessor;
}


export type IRelationalParameterBasedSqlProcessorFactory = IRelationalParameterBasedSqlProcessorFactory$instance;

export interface IRelationalQueryStringFactory$instance {
    create(command: DbCommand): string;
}


export type IRelationalQueryStringFactory = IRelationalQueryStringFactory$instance;

export interface IRelationalQuotableExpression$instance {
    quote(): Expression;
}


export type IRelationalQuotableExpression = IRelationalQuotableExpression$instance;

export interface IRelationalSqlTranslatingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
}


export type IRelationalSqlTranslatingExpressionVisitorFactory = IRelationalSqlTranslatingExpressionVisitorFactory$instance;

export interface IShapedQueryCompilingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext): ShapedQueryCompilingExpressionVisitor;
}


export type IShapedQueryCompilingExpressionVisitorFactory = IShapedQueryCompilingExpressionVisitorFactory$instance;

export interface ISqlAliasManagerFactory$instance {
    create(): SqlAliasManager;
}


export type ISqlAliasManagerFactory = ISqlAliasManagerFactory$instance;

export interface ISqlExpressionFactory$instance {
    add(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    applyDefaultTypeMapping(sqlExpression: SqlExpression): SqlExpression | undefined;
    applyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
    case_(operand: SqlExpression, whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression, existingExpression?: SqlExpression): SqlExpression;
    case_(whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression): SqlExpression;
    constant(value: unknown, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, type_: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, type_: Type, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    convert(operand: SqlExpression, type_: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    equal(left: SqlExpression, right: SqlExpression): SqlExpression;
    exists(subquery: SelectExpression): SqlExpression;
    fragment(sql: string, type_?: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(instance: SqlExpression, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, instancePropagatesNullability: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(schema: string, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    in_(item: SqlExpression, subquery: SelectExpression): SqlExpression;
    in_(item: SqlExpression, valuesParameter: SqlParameterExpression): SqlExpression;
    in_(item: SqlExpression, values: IReadOnlyList<SqlExpression>): SqlExpression;
    like(match: SqlExpression, pattern: SqlExpression, escapeChar?: SqlExpression): SqlExpression;
    makeBinary(operatorType: ExpressionType, left: SqlExpression, right: SqlExpression, typeMapping: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    makeUnary(operatorType: ExpressionType, operand: SqlExpression, type_: Type, typeMapping?: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    niladicFunction(instance: SqlExpression, name: string, nullable: boolean, instancePropagatesNullability: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    niladicFunction(name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    niladicFunction(schema: string, name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
}


export type ISqlExpressionFactory = ISqlExpressionFactory$instance;

export interface IStructuralTypeMaterializerSource$instance {
    createMaterializeExpression(parameters: StructuralTypeMaterializerSourceParameters, materializationExpression: Expression): Expression;
    getMaterializer(complexType: IComplexType): Func<MaterializationContext, unknown>;
    getMaterializer(entityType: IEntityType): Func<MaterializationContext, unknown>;
}


export type IStructuralTypeMaterializerSource = IStructuralTypeMaterializerSource$instance;

export interface EntityMaterializerSourceParameters$instance {
    instanceName: string;
    queryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    structuralType: ITypeBase;
    deconstruct(StructuralType: ITypeBase, InstanceName: string, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): void;
    equals(obj: unknown): boolean;
    equals(other: EntityMaterializerSourceParameters): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const EntityMaterializerSourceParameters: {
    new(StructuralType: ITypeBase, InstanceName: string, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): EntityMaterializerSourceParameters;
};


export type EntityMaterializerSourceParameters = EntityMaterializerSourceParameters$instance;

export interface PathSegment$instance {
    readonly arrayIndex: SqlExpression | undefined;
    readonly propertyName: string | undefined;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    quote(): Expression;
    toString(): string;
}


export const PathSegment: {
    new(propertyName: string): PathSegment;
    new(arrayIndex: SqlExpression): PathSegment;
};


export interface __PathSegment$views {
    As_IRelationalQuotableExpression(): IRelationalQuotableExpression$instance;
}

export interface PathSegment$instance extends IRelationalQuotableExpression$instance {}

export type PathSegment = PathSegment$instance & __PathSegment$views;


export interface StructuralTypeMaterializerSourceParameters$instance {
    clrType: Type;
    instanceName: string;
    isNullable: boolean;
    queryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    structuralType: ITypeBase;
    deconstruct(StructuralType: ITypeBase, InstanceName: string, ClrType: Type, IsNullable: boolean, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): void;
    equals(obj: unknown): boolean;
    equals(other: StructuralTypeMaterializerSourceParameters): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const StructuralTypeMaterializerSourceParameters: {
    new(StructuralType: ITypeBase, InstanceName: string, ClrType: Type, IsNullable: boolean, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): StructuralTypeMaterializerSourceParameters;
};


export type StructuralTypeMaterializerSourceParameters = StructuralTypeMaterializerSourceParameters$instance;

export interface CollectionResultExpression$instance extends Expression {
    readonly elementType: Type;
    readonly navigation: INavigationBase;
    readonly nodeType: ExpressionType;
    readonly projectionBindingExpression: ProjectionBindingExpression;
    readonly queryExpression: Expression;
    readonly structuralProperty: IPropertyBase | undefined;
    readonly type_: Type;
    print(expressionPrinter: ExpressionPrinter): void;
    update(queryExpression: Expression): CollectionResultExpression;
}


export const CollectionResultExpression: {
    new(queryExpression: Expression, structuralProperty: IPropertyBase, elementType: Type): CollectionResultExpression;
};


export interface __CollectionResultExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface CollectionResultExpression$instance extends IPrintableExpression$instance {}

export type CollectionResultExpression = CollectionResultExpression$instance & __CollectionResultExpression$views;


export interface CompiledQueryCacheKeyGenerator$instance {
    generateCacheKey(query: Expression, async_: boolean): unknown;
}


export const CompiledQueryCacheKeyGenerator: {
    new(dependencies: CompiledQueryCacheKeyGeneratorDependencies): CompiledQueryCacheKeyGenerator;
};


export interface __CompiledQueryCacheKeyGenerator$views {
    As_ICompiledQueryCacheKeyGenerator(): ICompiledQueryCacheKeyGenerator$instance;
}

export interface CompiledQueryCacheKeyGenerator$instance extends ICompiledQueryCacheKeyGenerator$instance {}

export type CompiledQueryCacheKeyGenerator = CompiledQueryCacheKeyGenerator$instance & __CompiledQueryCacheKeyGenerator$views;


export interface CompiledQueryCacheKeyGeneratorDependencies$instance {
    currentContext: ICurrentDbContext;
    isRetryingExecutionStrategy: boolean;
    model: IModel;
    _Clone_$(): CompiledQueryCacheKeyGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: CompiledQueryCacheKeyGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const CompiledQueryCacheKeyGeneratorDependencies: {
    new(model: IModel, currentContext: ICurrentDbContext, executionStrategy: IExecutionStrategy): CompiledQueryCacheKeyGeneratorDependencies;
};


export type CompiledQueryCacheKeyGeneratorDependencies = CompiledQueryCacheKeyGeneratorDependencies$instance;

export interface EntityQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly canReduce: boolean;
    readonly entityType: IEntityType;
    readonly nodeType: ExpressionType;
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    print(expressionPrinter: ExpressionPrinter): void;
    updateEntityType(entityType: IEntityType): EntityQueryRootExpression;
}


export const EntityQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, entityType: IEntityType): EntityQueryRootExpression;
    new(entityType: IEntityType): EntityQueryRootExpression;
};


export interface __EntityQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface EntityQueryRootExpression$instance extends IPrintableExpression$instance {}

export type EntityQueryRootExpression = EntityQueryRootExpression$instance & __EntityQueryRootExpression$views;


export interface EnumerableExpression$instance extends Expression {
    readonly isDistinct: boolean;
    readonly nodeType: ExpressionType;
    readonly orderings: IReadOnlyList<OrderingExpression>;
    readonly predicate: SqlExpression | undefined;
    readonly selector: Expression;
    readonly type_: Type;
    appendOrdering(orderingExpression: OrderingExpression): EnumerableExpression;
    applyOrdering(orderingExpression: OrderingExpression): EnumerableExpression;
    applyPredicate(sqlExpression: SqlExpression): EnumerableExpression;
    applySelector(expression: Expression): EnumerableExpression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    print(expressionPrinter: ExpressionPrinter): void;
    setDistinct(value: boolean): EnumerableExpression;
}


export const EnumerableExpression: {
    new(selector: Expression): EnumerableExpression;
};


export interface __EnumerableExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface EnumerableExpression$instance extends IPrintableExpression$instance {}

export type EnumerableExpression = EnumerableExpression$instance & __EnumerableExpression$views;


export interface EvaluatableExpressionFilter$instance {
    isEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export const EvaluatableExpressionFilter: {
    new(dependencies: EvaluatableExpressionFilterDependencies): EvaluatableExpressionFilter;
};


export interface __EvaluatableExpressionFilter$views {
    As_IEvaluatableExpressionFilter(): IEvaluatableExpressionFilter$instance;
}

export interface EvaluatableExpressionFilter$instance extends IEvaluatableExpressionFilter$instance {}

export type EvaluatableExpressionFilter = EvaluatableExpressionFilter$instance & __EvaluatableExpressionFilter$views;


export interface EvaluatableExpressionFilterDependencies$instance {
    plugins: IEnumerable__System_Collections_Generic<IEvaluatableExpressionFilterPlugin>;
    _Clone_$(): EvaluatableExpressionFilterDependencies;
    equals(obj: unknown): boolean;
    equals(other: EvaluatableExpressionFilterDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const EvaluatableExpressionFilterDependencies: {
    new(plugins: IEnumerable__System_Collections_Generic<IEvaluatableExpressionFilterPlugin>): EvaluatableExpressionFilterDependencies;
};


export type EvaluatableExpressionFilterDependencies = EvaluatableExpressionFilterDependencies$instance;

export interface ExpressionEqualityComparer$instance {
    equals(x: Expression, y: Expression): boolean;
    getHashCode(obj: Expression): int;
}


export const ExpressionEqualityComparer: {
    new(): ExpressionEqualityComparer;
    readonly instance: ExpressionEqualityComparer;
};


export type ExpressionEqualityComparer = ExpressionEqualityComparer$instance;

export interface ExpressionPrinter$instance extends ExpressionVisitor {
    append(value: string): ExpressionPrinter;
    appendLine(): ExpressionPrinter;
    appendLine(value: string): ExpressionPrinter;
    appendLines(value: string, skipFinalNewline?: boolean): ExpressionPrinter;
    generateBinaryOperator(expressionType: ExpressionType): string;
    indent(): IDisposable;
    printExpression(expression: Expression, characterLimit?: Nullable<System_Internal.Int32>): string;
    printExpressionDebug(expression: Expression): string;
    toString(): string;
    visit(expression: Expression): Expression | undefined;
    visitCollection<T extends Expression>(items: IReadOnlyCollection<T>, joinAction?: Action<ExpressionPrinter>): void;
}


export const ExpressionPrinter: {
    new(): ExpressionPrinter;
    print(expression: Expression): string;
    printDebug(expression: Expression): string;
};


export type ExpressionPrinter = ExpressionPrinter$instance;

export interface GroupByShaperExpression$instance extends Expression {
    readonly groupingEnumerable: ShapedQueryExpression;
    readonly keySelector: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    print(expressionPrinter: ExpressionPrinter): void;
    update(keySelector: Expression, groupingEnumerable: ShapedQueryExpression): GroupByShaperExpression;
}


export const GroupByShaperExpression: {
    new(keySelector: Expression, groupingEnumerable: ShapedQueryExpression): GroupByShaperExpression;
};


export interface __GroupByShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface GroupByShaperExpression$instance extends IPrintableExpression$instance {}

export type GroupByShaperExpression = GroupByShaperExpression$instance & __GroupByShaperExpression$views;


export interface IncludeExpression$instance extends Expression {
    readonly entityExpression: Expression;
    readonly navigation: INavigationBase;
    readonly navigationExpression: Expression;
    readonly nodeType: ExpressionType;
    readonly setLoaded: boolean;
    readonly type_: Type;
    update(entityExpression: Expression, navigationExpression: Expression): IncludeExpression;
}


export const IncludeExpression: {
    new(entityExpression: Expression, navigationExpression: Expression, navigation: INavigationBase): IncludeExpression;
    new(entityExpression: Expression, navigationExpression: Expression, navigation: INavigationBase, setLoaded: boolean): IncludeExpression;
};


export interface __IncludeExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface IncludeExpression$instance extends IPrintableExpression$instance {}

export type IncludeExpression = IncludeExpression$instance & __IncludeExpression$views;


export interface InlineQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly values: IReadOnlyList<Expression>;
    detachQueryProvider(): Expression;
    print(expressionPrinter: ExpressionPrinter): void;
    update(values: IReadOnlyList<Expression>): InlineQueryRootExpression;
}


export const InlineQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, values: IReadOnlyList<Expression>, elementType: Type): InlineQueryRootExpression;
    new(values: IReadOnlyList<Expression>, elementType: Type): InlineQueryRootExpression;
};


export interface __InlineQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface InlineQueryRootExpression$instance extends IPrintableExpression$instance {}

export type InlineQueryRootExpression = InlineQueryRootExpression$instance & __InlineQueryRootExpression$views;


export interface JsonQueryExpression$instance extends Expression {
    readonly isCollection: boolean;
    readonly isNullable: boolean;
    readonly jsonColumn: ColumnExpression;
    readonly keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression> | undefined;
    readonly nodeType: ExpressionType;
    readonly path: IReadOnlyList<PathSegment>;
    readonly structuralType: ITypeBase;
    readonly type_: Type;
    bindCollectionElement(collectionIndexExpression: SqlExpression): JsonQueryExpression;
    bindProperty(property: IProperty): SqlExpression;
    bindStructuralProperty(structuralProperty: IPropertyBase): JsonQueryExpression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    makeNullable(): JsonQueryExpression;
    print(expressionPrinter: ExpressionPrinter): void;
    update(jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>): JsonQueryExpression;
}


export const JsonQueryExpression: {
    new(structuralType: ITypeBase, jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>, type_: Type, collection: boolean): JsonQueryExpression;
    new(structuralType: ITypeBase, jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>, path: IReadOnlyList<PathSegment>, type_: Type, collection: boolean, nullable: boolean): JsonQueryExpression;
};


export interface __JsonQueryExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface JsonQueryExpression$instance extends IPrintableExpression$instance {}

export type JsonQueryExpression = JsonQueryExpression$instance & __JsonQueryExpression$views;


export interface LiftableConstantExpression$instance extends Expression {
    readonly nodeType: ExpressionType;
    readonly originalExpression: ConstantExpression;
    readonly resolverExpression: LambdaExpression;
    readonly type_: Type;
    readonly variableName: string;
    print(expressionPrinter: ExpressionPrinter): void;
    update(resolverExpression: LambdaExpression): LiftableConstantExpression;
}


export const LiftableConstantExpression: {
    new(originalValue: unknown, resolverExpression: LambdaExpression, variableName: string, type_: Type): LiftableConstantExpression;
};


export interface __LiftableConstantExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface LiftableConstantExpression$instance extends IPrintableExpression$instance {}

export type LiftableConstantExpression = LiftableConstantExpression$instance & __LiftableConstantExpression$views;


export interface LiftableConstantExpressionDependencies$instance {
    _Clone_$(): LiftableConstantExpressionDependencies;
    equals(obj: unknown): boolean;
    equals(other: LiftableConstantExpressionDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const LiftableConstantExpressionDependencies: {
    new(): LiftableConstantExpressionDependencies;
};


export type LiftableConstantExpressionDependencies = LiftableConstantExpressionDependencies$instance;

export interface LiftableConstantFactory$instance {
    readonly dependencies: LiftableConstantExpressionDependencies;
    createLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type_: Type): Expression;
}


export const LiftableConstantFactory: {
    new(dependencies: LiftableConstantExpressionDependencies): LiftableConstantFactory;
};


export interface __LiftableConstantFactory$views {
    As_ILiftableConstantFactory(): ILiftableConstantFactory$instance;
}

export interface LiftableConstantFactory$instance extends ILiftableConstantFactory$instance {}

export type LiftableConstantFactory = LiftableConstantFactory$instance & __LiftableConstantFactory$views;


export interface LiftableConstantProcessor$instance extends ExpressionVisitor {
    readonly liftedConstants: IReadOnlyList<ValueTuple<ParameterExpression, Expression>>;
    inlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    liftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
}


export const LiftableConstantProcessor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies): LiftableConstantProcessor;
};


export interface __LiftableConstantProcessor$views {
    As_ILiftableConstantProcessor(): ILiftableConstantProcessor$instance;
}

export interface LiftableConstantProcessor$instance extends ILiftableConstantProcessor$instance {}

export type LiftableConstantProcessor = LiftableConstantProcessor$instance & __LiftableConstantProcessor$views;


export interface MaterializeCollectionNavigationExpression$instance extends Expression {
    readonly navigation: INavigationBase;
    readonly nodeType: ExpressionType;
    readonly subquery: Expression;
    readonly type_: Type;
    update(subquery: Expression): MaterializeCollectionNavigationExpression;
}


export const MaterializeCollectionNavigationExpression: {
    new(subquery: Expression, navigation: INavigationBase): MaterializeCollectionNavigationExpression;
};


export interface __MaterializeCollectionNavigationExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface MaterializeCollectionNavigationExpression$instance extends IPrintableExpression$instance {}

export type MaterializeCollectionNavigationExpression = MaterializeCollectionNavigationExpression$instance & __MaterializeCollectionNavigationExpression$views;


export interface MaterializerLiftableConstantContext$instance {
    dependencies: ShapedQueryCompilingExpressionVisitorDependencies;
    _Clone_$(): MaterializerLiftableConstantContext;
    deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): void;
    equals(obj: unknown): boolean;
    equals(other: MaterializerLiftableConstantContext): boolean;
    getHashCode(): int;
    toString(): string;
}


export const MaterializerLiftableConstantContext: {
    new(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): MaterializerLiftableConstantContext;
};


export type MaterializerLiftableConstantContext = MaterializerLiftableConstantContext$instance;

export interface NavigationExpansionExtensibilityHelper$instance {
    areQueryRootsCompatible(first: EntityQueryRootExpression, second: EntityQueryRootExpression): boolean;
    createQueryRoot(entityType: IEntityType, source: EntityQueryRootExpression): EntityQueryRootExpression;
    validateQueryRootCreation(entityType: IEntityType, source: EntityQueryRootExpression): void;
}


export const NavigationExpansionExtensibilityHelper: {
    new(dependencies: NavigationExpansionExtensibilityHelperDependencies): NavigationExpansionExtensibilityHelper;
};


export interface __NavigationExpansionExtensibilityHelper$views {
    As_INavigationExpansionExtensibilityHelper(): INavigationExpansionExtensibilityHelper$instance;
}

export interface NavigationExpansionExtensibilityHelper$instance extends INavigationExpansionExtensibilityHelper$instance {}

export type NavigationExpansionExtensibilityHelper = NavigationExpansionExtensibilityHelper$instance & __NavigationExpansionExtensibilityHelper$views;


export interface NavigationExpansionExtensibilityHelperDependencies$instance {
    _Clone_$(): NavigationExpansionExtensibilityHelperDependencies;
    equals(obj: unknown): boolean;
    equals(other: NavigationExpansionExtensibilityHelperDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const NavigationExpansionExtensibilityHelperDependencies: {
    new(): NavigationExpansionExtensibilityHelperDependencies;
};


export type NavigationExpansionExtensibilityHelperDependencies = NavigationExpansionExtensibilityHelperDependencies$instance;

export interface NotParameterizedAttribute$instance extends Attribute {
}


export const NotParameterizedAttribute: {
    new(): NotParameterizedAttribute;
};


export type NotParameterizedAttribute = NotParameterizedAttribute$instance;

export interface ParameterQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly parameterExpression: ParameterExpression;
    readonly queryParameterExpression: QueryParameterExpression;
    detachQueryProvider(): Expression;
    print(expressionPrinter: ExpressionPrinter): void;
}


export const ParameterQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, elementType: Type, queryParameterExpression: QueryParameterExpression): ParameterQueryRootExpression;
    new(elementType: Type, queryParameterExpression: QueryParameterExpression): ParameterQueryRootExpression;
    new(asyncQueryProvider: IAsyncQueryProvider, elementType: Type, parameterExpression: ParameterExpression): ParameterQueryRootExpression;
    new(elementType: Type, parameterExpression: ParameterExpression): ParameterQueryRootExpression;
};


export interface __ParameterQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface ParameterQueryRootExpression$instance extends IPrintableExpression$instance {}

export type ParameterQueryRootExpression = ParameterQueryRootExpression$instance & __ParameterQueryRootExpression$views;


export interface ParametersCacheDecorator$instance {
    readonly canCache: boolean;
    getAndDisableCaching(): Dictionary<System_Internal.String, unknown | undefined>;
    isNull(parameterName: string): boolean;
}


export const ParametersCacheDecorator: {
    new(parameters: Dictionary<System_Internal.String, unknown>): ParametersCacheDecorator;
};


export type ParametersCacheDecorator = ParametersCacheDecorator$instance;

export interface ProjectionBindingExpression$instance extends Expression {
    readonly index: Nullable<System_Internal.Int32>;
    readonly nodeType: ExpressionType;
    readonly projectionMember: ProjectionMember | undefined;
    readonly queryExpression: Expression;
    readonly type_: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const ProjectionBindingExpression: {
    new(queryExpression: Expression, projectionMember: ProjectionMember, type_: Type): ProjectionBindingExpression;
    new(queryExpression: Expression, index: int, type_: Type): ProjectionBindingExpression;
};


export interface __ProjectionBindingExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface ProjectionBindingExpression$instance extends IPrintableExpression$instance {}

export type ProjectionBindingExpression = ProjectionBindingExpression$instance & __ProjectionBindingExpression$views;


export interface ProjectionMember$instance {
    readonly last: MemberInfo | undefined;
    append(member: MemberInfo): ProjectionMember;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    prepend(member: MemberInfo): ProjectionMember;
    toString(): string;
}


export const ProjectionMember: {
    new(): ProjectionMember;
};


export type ProjectionMember = ProjectionMember$instance;

export interface QueryableMethodTranslatingExpressionVisitor$instance extends ExpressionVisitor {
    readonly translationErrorDetails: string | undefined;
    translate(expression: Expression): Expression;
    translateSubquery(expression: Expression): ShapedQueryExpression | undefined;
}


export const QueryableMethodTranslatingExpressionVisitor: {
};


export type QueryableMethodTranslatingExpressionVisitor = QueryableMethodTranslatingExpressionVisitor$instance;

export interface QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter$instance {
    propertySelector: LambdaExpression;
    valueExpression: Expression;
    _Clone_$(): QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter;
    deconstruct(PropertySelector: LambdaExpression, ValueExpression: Expression): void;
    equals(obj: unknown): boolean;
    equals(other: QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter: {
    new(PropertySelector: LambdaExpression, ValueExpression: Expression): QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter;
};


export type QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter = QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter$instance;

export interface QueryableMethodTranslatingExpressionVisitorDependencies$instance {
    _Clone_$(): QueryableMethodTranslatingExpressionVisitorDependencies;
    equals(obj: unknown): boolean;
    equals(other: QueryableMethodTranslatingExpressionVisitorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryableMethodTranslatingExpressionVisitorDependencies: {
    new(): QueryableMethodTranslatingExpressionVisitorDependencies;
};


export type QueryableMethodTranslatingExpressionVisitorDependencies = QueryableMethodTranslatingExpressionVisitorDependencies$instance;

export interface QueryCompilationContext$instance {
    readonly contextOptions: IDbContextOptions;
    readonly contextType: Type;
    readonly ignoreAutoIncludes: boolean;
    readonly ignoredQueryFilters: HashSet<System_Internal.String> | undefined;
    readonly ignoreQueryFilters: boolean;
    readonly isAsync: boolean;
    readonly isBuffering: boolean;
    readonly isPrecompiling: boolean;
    readonly logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    readonly model: IModel;
    readonly queryTrackingBehavior: QueryTrackingBehavior;
    readonly supportsPrecompiledQuery: boolean;
    readonly tags: ISet<System_Internal.String>;
    addTag(tag: string): void;
    createQueryExecutor<TResult>(query: Expression): Func<QueryContext, TResult>;
    createQueryExecutorExpression<TResult>(query: Expression): Expression<Func<QueryContext, TResult>>;
    registerRuntimeParameter(name: string, valueExtractor: LambdaExpression): QueryParameterExpression;
}


export const QueryCompilationContext: {
    new(dependencies: QueryCompilationContextDependencies, async_: boolean): QueryCompilationContext;
    new(dependencies: QueryCompilationContextDependencies, async_: boolean, precompiling: boolean): QueryCompilationContext;
    readonly queryContextParameter: ParameterExpression;
    readonly notTranslatedExpression: Expression;
};


export type QueryCompilationContext = QueryCompilationContext$instance;

export interface QueryCompilationContextDependencies$instance {
    readonly context: DbContext;
    contextOptions: IDbContextOptions;
    readonly contextType: Type;
    readonly interceptors: IInterceptors;
    isRetryingExecutionStrategy: boolean;
    liftableConstantFactory: ILiftableConstantFactory;
    liftableConstantProcessor: ILiftableConstantProcessor;
    logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    model: IModel;
    queryableMethodTranslatingExpressionVisitorFactory: IQueryableMethodTranslatingExpressionVisitorFactory;
    readonly queryTrackingBehavior: QueryTrackingBehavior;
    queryTranslationPostprocessorFactory: IQueryTranslationPostprocessorFactory;
    queryTranslationPreprocessorFactory: IQueryTranslationPreprocessorFactory;
    shapedQueryCompilingExpressionVisitorFactory: IShapedQueryCompilingExpressionVisitorFactory;
    _Clone_$(): QueryCompilationContextDependencies;
    equals(obj: unknown): boolean;
    equals(other: QueryCompilationContextDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryCompilationContextDependencies: {
    new(model: IModel, queryTranslationPreprocessorFactory: IQueryTranslationPreprocessorFactory, queryableMethodTranslatingExpressionVisitorFactory: IQueryableMethodTranslatingExpressionVisitorFactory, queryTranslationPostprocessorFactory: IQueryTranslationPostprocessorFactory, shapedQueryCompilingExpressionVisitorFactory: IShapedQueryCompilingExpressionVisitorFactory, liftableConstantFactory: ILiftableConstantFactory, liftableConstantProcessor: ILiftableConstantProcessor, executionStrategy: IExecutionStrategy, currentContext: ICurrentDbContext, contextOptions: IDbContextOptions, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>, interceptors: IInterceptors): QueryCompilationContextDependencies;
};


export type QueryCompilationContextDependencies = QueryCompilationContextDependencies$instance;

export interface QueryContext$instance {
    cancellationToken: CancellationToken;
    readonly commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command> | IRelationalCommandDiagnosticsLogger;
    readonly concurrencyDetector: IConcurrencyDetector;
    readonly context: DbContext;
    readonly exceptionDetector: IExceptionDetector;
    readonly executionStrategy: IExecutionStrategy;
    readonly parameters: Dictionary<System_Internal.String, unknown | undefined>;
    readonly queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    initializeStateManager(standAlone?: boolean): void;
    setNavigationIsLoaded(entity: unknown, navigation: INavigationBase): void;
    startTracking(entityType: IEntityType, entity: unknown, snapshot: ISnapshot): InternalEntityEntry;
    tryGetEntry(key: IKey, keyValues: unknown[], throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
}


export const QueryContext: {
};


export type QueryContext = QueryContext$instance;

export interface QueryContextDependencies$instance {
    commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>;
    concurrencyDetector: IConcurrencyDetector;
    currentContext: ICurrentDbContext;
    exceptionDetector: IExceptionDetector;
    executionStrategy: IExecutionStrategy;
    queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    readonly stateManager: IStateManager;
    _Clone_$(): QueryContextDependencies;
    equals(obj: unknown): boolean;
    equals(other: QueryContextDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryContextDependencies: {
    new(currentContext: ICurrentDbContext, executionStrategy: IExecutionStrategy, concurrencyDetector: IConcurrencyDetector, exceptionDetector: IExceptionDetector, commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>, queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): QueryContextDependencies;
};


export type QueryContextDependencies = QueryContextDependencies$instance;

export interface QueryParameterExpression$instance extends Expression {
    readonly isNonNullableReferenceType: boolean;
    readonly name: string;
    readonly nodeType: ExpressionType;
    readonly translationMode: Nullable<ParameterTranslationMode>;
    readonly type_: Type;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    print(expressionPrinter: ExpressionPrinter): void;
}


export const QueryParameterExpression: {
    new(name: string, type_: Type): QueryParameterExpression;
    new(name: string, type_: Type, translationMode: ParameterTranslationMode): QueryParameterExpression;
    new(name: string, type_: Type, translationMode: Nullable<ParameterTranslationMode>, isNonNullableReferenceType: boolean): QueryParameterExpression;
};


export interface __QueryParameterExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface QueryParameterExpression$instance extends IPrintableExpression$instance {}

export type QueryParameterExpression = QueryParameterExpression$instance & __QueryParameterExpression$views;


export interface QueryRootExpression$instance extends Expression {
    readonly canReduce: boolean;
    readonly elementType: Type;
    readonly nodeType: ExpressionType;
    readonly queryProvider: IAsyncQueryProvider | undefined;
    readonly type_: Type;
    detachQueryProvider(): Expression;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const QueryRootExpression: {
};


export interface __QueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface QueryRootExpression$instance extends IPrintableExpression$instance {}

export type QueryRootExpression = QueryRootExpression$instance & __QueryRootExpression$views;


export interface QueryRootProcessor$instance extends ExpressionVisitor {
}


export const QueryRootProcessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryRootProcessor;
};


export type QueryRootProcessor = QueryRootProcessor$instance;

export interface QuerySqlGenerator$instance extends SqlExpressionVisitor {
    getCommand(queryExpression: Expression): IRelationalCommand;
}


export const QuerySqlGenerator: {
    new(dependencies: QuerySqlGeneratorDependencies): QuerySqlGenerator;
};


export type QuerySqlGenerator = QuerySqlGenerator$instance;

export interface QuerySqlGeneratorDependencies$instance {
    relationalCommandBuilderFactory: IRelationalCommandBuilderFactory;
    sqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): QuerySqlGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: QuerySqlGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QuerySqlGeneratorDependencies: {
    new(relationalCommandBuilderFactory: IRelationalCommandBuilderFactory, sqlGenerationHelper: ISqlGenerationHelper): QuerySqlGeneratorDependencies;
};


export type QuerySqlGeneratorDependencies = QuerySqlGeneratorDependencies$instance;

export interface QueryTranslationPostprocessor$instance {
    process(query: Expression): Expression;
}


export const QueryTranslationPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryTranslationPostprocessor;
};


export type QueryTranslationPostprocessor = QueryTranslationPostprocessor$instance;

export interface QueryTranslationPostprocessorDependencies$instance {
    _Clone_$(): QueryTranslationPostprocessorDependencies;
    equals(obj: unknown): boolean;
    equals(other: QueryTranslationPostprocessorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryTranslationPostprocessorDependencies: {
    new(): QueryTranslationPostprocessorDependencies;
};


export type QueryTranslationPostprocessorDependencies = QueryTranslationPostprocessorDependencies$instance;

export interface QueryTranslationPreprocessor$instance {
    normalizeQueryableMethod(expression: Expression): Expression;
    process(query: Expression): Expression;
}


export const QueryTranslationPreprocessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryTranslationPreprocessor;
};


export type QueryTranslationPreprocessor = QueryTranslationPreprocessor$instance;

export interface QueryTranslationPreprocessorDependencies$instance {
    evaluatableExpressionFilter: IEvaluatableExpressionFilter;
    navigationExpansionExtensibilityHelper: INavigationExpansionExtensibilityHelper;
    typeMappingSource: ITypeMappingSource;
    _Clone_$(): QueryTranslationPreprocessorDependencies;
    equals(obj: unknown): boolean;
    equals(other: QueryTranslationPreprocessorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const QueryTranslationPreprocessorDependencies: {
    new(typeMappingSource: ITypeMappingSource, evaluatableExpressionFilter: IEvaluatableExpressionFilter, navigationExpansionExtensibilityHelper: INavigationExpansionExtensibilityHelper): QueryTranslationPreprocessorDependencies;
};


export type QueryTranslationPreprocessorDependencies = QueryTranslationPreprocessorDependencies$instance;

export interface RelationalAggregateMethodCallTranslatorProvider$instance {
    translate(model: IModel, method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalAggregateMethodCallTranslatorProvider: {
    new(dependencies: RelationalAggregateMethodCallTranslatorProviderDependencies): RelationalAggregateMethodCallTranslatorProvider;
};


export interface __RelationalAggregateMethodCallTranslatorProvider$views {
    As_IAggregateMethodCallTranslatorProvider(): IAggregateMethodCallTranslatorProvider$instance;
}

export interface RelationalAggregateMethodCallTranslatorProvider$instance extends IAggregateMethodCallTranslatorProvider$instance {}

export type RelationalAggregateMethodCallTranslatorProvider = RelationalAggregateMethodCallTranslatorProvider$instance & __RelationalAggregateMethodCallTranslatorProvider$views;


export interface RelationalAggregateMethodCallTranslatorProviderDependencies$instance {
    plugins: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslatorPlugin>;
    relationalTypeMappingSource: IRelationalTypeMappingSource;
    sqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalAggregateMethodCallTranslatorProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalAggregateMethodCallTranslatorProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalAggregateMethodCallTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslatorPlugin>, typeMappingSource: IRelationalTypeMappingSource): RelationalAggregateMethodCallTranslatorProviderDependencies;
};


export type RelationalAggregateMethodCallTranslatorProviderDependencies = RelationalAggregateMethodCallTranslatorProviderDependencies$instance;

export interface RelationalCollectionShaperExpression$instance extends Expression {
    readonly elementType: Type;
    readonly innerShaper: Expression;
    readonly navigation: INavigationBase;
    readonly nodeType: ExpressionType;
    readonly outerIdentifier: Expression;
    readonly outerIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly parentIdentifier: Expression;
    readonly parentIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly selfIdentifier: Expression;
    readonly selfIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly type_: Type;
    update(parentIdentifier: Expression, outerIdentifier: Expression, selfIdentifier: Expression, innerShaper: Expression): RelationalCollectionShaperExpression;
}


export const RelationalCollectionShaperExpression: {
    new(parentIdentifier: Expression, outerIdentifier: Expression, selfIdentifier: Expression, parentIdentifierValueComparers: IReadOnlyList<ValueComparer>, outerIdentifierValueComparers: IReadOnlyList<ValueComparer>, selfIdentifierValueComparers: IReadOnlyList<ValueComparer>, innerShaper: Expression, navigation: INavigationBase, elementType: Type): RelationalCollectionShaperExpression;
};


export interface __RelationalCollectionShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalCollectionShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalCollectionShaperExpression = RelationalCollectionShaperExpression$instance & __RelationalCollectionShaperExpression$views;


export interface RelationalCompiledQueryCacheKeyGenerator$instance extends CompiledQueryCacheKeyGenerator$instance {
    generateCacheKey(query: Expression, async_: boolean): unknown;
}


export const RelationalCompiledQueryCacheKeyGenerator: {
    new(dependencies: CompiledQueryCacheKeyGeneratorDependencies, relationalDependencies: RelationalCompiledQueryCacheKeyGeneratorDependencies): RelationalCompiledQueryCacheKeyGenerator;
};


export interface __RelationalCompiledQueryCacheKeyGenerator$views {
    As_ICompiledQueryCacheKeyGenerator(): ICompiledQueryCacheKeyGenerator$instance;
}

export type RelationalCompiledQueryCacheKeyGenerator = RelationalCompiledQueryCacheKeyGenerator$instance & __RelationalCompiledQueryCacheKeyGenerator$views;


export interface RelationalCompiledQueryCacheKeyGeneratorDependencies$instance {
    contextOptions: IDbContextOptions;
    _Clone_$(): RelationalCompiledQueryCacheKeyGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalCompiledQueryCacheKeyGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalCompiledQueryCacheKeyGeneratorDependencies: {
    new(contextOptions: IDbContextOptions): RelationalCompiledQueryCacheKeyGeneratorDependencies;
};


export type RelationalCompiledQueryCacheKeyGeneratorDependencies = RelationalCompiledQueryCacheKeyGeneratorDependencies$instance;

export interface RelationalEvaluatableExpressionFilter$instance extends EvaluatableExpressionFilter$instance {
    isEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export const RelationalEvaluatableExpressionFilter: {
    new(dependencies: EvaluatableExpressionFilterDependencies, relationalDependencies: RelationalEvaluatableExpressionFilterDependencies): RelationalEvaluatableExpressionFilter;
};


export interface __RelationalEvaluatableExpressionFilter$views {
    As_IEvaluatableExpressionFilter(): IEvaluatableExpressionFilter$instance;
}

export type RelationalEvaluatableExpressionFilter = RelationalEvaluatableExpressionFilter$instance & __RelationalEvaluatableExpressionFilter$views;


export interface RelationalEvaluatableExpressionFilterDependencies$instance {
    _Clone_$(): RelationalEvaluatableExpressionFilterDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalEvaluatableExpressionFilterDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalEvaluatableExpressionFilterDependencies: {
    new(): RelationalEvaluatableExpressionFilterDependencies;
};


export type RelationalEvaluatableExpressionFilterDependencies = RelationalEvaluatableExpressionFilterDependencies$instance;

export interface RelationalGroupByResultExpression$instance extends Expression {
    readonly elementShaper: Expression;
    readonly keyIdentifier: Expression;
    readonly keyIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly keyShaper: Expression;
    readonly nodeType: ExpressionType;
    readonly type_: Type;
    update(keyIdentifier: Expression, keyShaper: Expression, elementShaper: Expression): RelationalGroupByResultExpression;
}


export const RelationalGroupByResultExpression: {
    new(keyIdentifier: Expression, keyIdentifierValueComparers: IReadOnlyList<ValueComparer>, keyShaper: Expression, elementShaper: Expression): RelationalGroupByResultExpression;
};


export interface __RelationalGroupByResultExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalGroupByResultExpression$instance extends IPrintableExpression$instance {}

export type RelationalGroupByResultExpression = RelationalGroupByResultExpression$instance & __RelationalGroupByResultExpression$views;


export interface RelationalGroupByShaperExpression$instance extends GroupByShaperExpression$instance {
    readonly elementSelector: Expression;
    print(expressionPrinter: ExpressionPrinter): void;
}


export const RelationalGroupByShaperExpression: {
    new(keySelector: Expression, elementSelector: Expression, groupingEnumerable: ShapedQueryExpression): RelationalGroupByShaperExpression;
};


export interface __RelationalGroupByShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export type RelationalGroupByShaperExpression = RelationalGroupByShaperExpression$instance & __RelationalGroupByShaperExpression$views;


export interface RelationalLiftableConstantExpressionDependencies$instance {
    _Clone_$(): RelationalLiftableConstantExpressionDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalLiftableConstantExpressionDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalLiftableConstantExpressionDependencies: {
    new(): RelationalLiftableConstantExpressionDependencies;
};


export type RelationalLiftableConstantExpressionDependencies = RelationalLiftableConstantExpressionDependencies$instance;

export interface RelationalLiftableConstantFactory$instance extends LiftableConstantFactory$instance {
    readonly relationalDependencies: RelationalLiftableConstantExpressionDependencies;
    createLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type_: Type): Expression;
}


export const RelationalLiftableConstantFactory: {
    new(dependencies: LiftableConstantExpressionDependencies, relationalDependencies: RelationalLiftableConstantExpressionDependencies): RelationalLiftableConstantFactory;
};


export interface __RelationalLiftableConstantFactory$views {
    As_ILiftableConstantFactory(): ILiftableConstantFactory$instance;
    As_IRelationalLiftableConstantFactory(): IRelationalLiftableConstantFactory$instance;
}

export type RelationalLiftableConstantFactory = RelationalLiftableConstantFactory$instance & __RelationalLiftableConstantFactory$views;


export interface RelationalLiftableConstantProcessor$instance extends LiftableConstantProcessor$instance {
    inlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    liftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
}


export const RelationalLiftableConstantProcessor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies, relationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, commandBuilderDependencies: RelationalCommandBuilderDependencies): RelationalLiftableConstantProcessor;
};


export interface __RelationalLiftableConstantProcessor$views {
    As_ILiftableConstantProcessor(): ILiftableConstantProcessor$instance;
}

export type RelationalLiftableConstantProcessor = RelationalLiftableConstantProcessor$instance & __RelationalLiftableConstantProcessor$views;


export interface RelationalMaterializerLiftableConstantContext$instance extends MaterializerLiftableConstantContext {
    commandBuilderDependencies: RelationalCommandBuilderDependencies;
    relationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies;
    _Clone_$(): RelationalMaterializerLiftableConstantContext;
    _Clone_$(): MaterializerLiftableConstantContext;
    deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies, RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, CommandBuilderDependencies: RelationalCommandBuilderDependencies): void;
    deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): void;
    equals(obj: unknown): boolean;
    equals(other: MaterializerLiftableConstantContext): boolean;
    equals(other: RelationalMaterializerLiftableConstantContext): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalMaterializerLiftableConstantContext: {
    new(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies, RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, CommandBuilderDependencies: RelationalCommandBuilderDependencies): RelationalMaterializerLiftableConstantContext;
};


export type RelationalMaterializerLiftableConstantContext = RelationalMaterializerLiftableConstantContext$instance;

export interface RelationalMemberTranslatorProvider$instance {
    translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalMemberTranslatorProvider: {
    new(dependencies: RelationalMemberTranslatorProviderDependencies): RelationalMemberTranslatorProvider;
};


export interface __RelationalMemberTranslatorProvider$views {
    As_IMemberTranslatorProvider(): IMemberTranslatorProvider$instance;
}

export interface RelationalMemberTranslatorProvider$instance extends IMemberTranslatorProvider$instance {}

export type RelationalMemberTranslatorProvider = RelationalMemberTranslatorProvider$instance & __RelationalMemberTranslatorProvider$views;


export interface RelationalMemberTranslatorProviderDependencies$instance {
    plugins: IEnumerable__System_Collections_Generic<IMemberTranslatorPlugin>;
    sqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalMemberTranslatorProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalMemberTranslatorProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalMemberTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IMemberTranslatorPlugin>): RelationalMemberTranslatorProviderDependencies;
};


export type RelationalMemberTranslatorProviderDependencies = RelationalMemberTranslatorProviderDependencies$instance;

export interface RelationalMethodCallTranslatorProvider$instance {
    translate(model: IModel, instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalMethodCallTranslatorProvider: {
    new(dependencies: RelationalMethodCallTranslatorProviderDependencies): RelationalMethodCallTranslatorProvider;
};


export interface __RelationalMethodCallTranslatorProvider$views {
    As_IMethodCallTranslatorProvider(): IMethodCallTranslatorProvider$instance;
}

export interface RelationalMethodCallTranslatorProvider$instance extends IMethodCallTranslatorProvider$instance {}

export type RelationalMethodCallTranslatorProvider = RelationalMethodCallTranslatorProvider$instance & __RelationalMethodCallTranslatorProvider$views;


export interface RelationalMethodCallTranslatorProviderDependencies$instance {
    plugins: IEnumerable__System_Collections_Generic<IMethodCallTranslatorPlugin>;
    relationalTypeMappingSource: IRelationalTypeMappingSource;
    sqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalMethodCallTranslatorProviderDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalMethodCallTranslatorProviderDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalMethodCallTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IMethodCallTranslatorPlugin>, typeMappingSource: IRelationalTypeMappingSource): RelationalMethodCallTranslatorProviderDependencies;
};


export type RelationalMethodCallTranslatorProviderDependencies = RelationalMethodCallTranslatorProviderDependencies$instance;

export interface RelationalParameterBasedSqlProcessor$instance {
    optimize(queryExpression: Expression, parametersValues: IReadOnlyDictionary<System_Internal.String, unknown>, canCache: boolean): Expression;
    process(queryExpression: Expression, parameters: Dictionary<System_Internal.String, unknown>, canCache: boolean): Expression;
    process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
}


export const RelationalParameterBasedSqlProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters): RelationalParameterBasedSqlProcessor;
};


export type RelationalParameterBasedSqlProcessor = RelationalParameterBasedSqlProcessor$instance;

export interface RelationalParameterBasedSqlProcessorDependencies$instance {
    parameterNameGeneratorFactory: IParameterNameGeneratorFactory;
    sqlExpressionFactory: ISqlExpressionFactory;
    sqlGenerationHelper: ISqlGenerationHelper;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalParameterBasedSqlProcessorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalParameterBasedSqlProcessorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalParameterBasedSqlProcessorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource, sqlGenerationHelper: ISqlGenerationHelper, parameterNameGeneratorFactory: IParameterNameGeneratorFactory): RelationalParameterBasedSqlProcessorDependencies;
};


export type RelationalParameterBasedSqlProcessorDependencies = RelationalParameterBasedSqlProcessorDependencies$instance;

export interface RelationalParameterBasedSqlProcessorParameters$instance {
    collectionParameterTranslationMode: ParameterTranslationMode;
    useRelationalNulls: boolean;
    _Clone_$(): RelationalParameterBasedSqlProcessorParameters;
    equals(obj: unknown): boolean;
    equals(other: RelationalParameterBasedSqlProcessorParameters): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalParameterBasedSqlProcessorParameters: {
    new(useRelationalNulls: boolean, collectionParameterTranslationMode: ParameterTranslationMode): RelationalParameterBasedSqlProcessorParameters;
};


export type RelationalParameterBasedSqlProcessorParameters = RelationalParameterBasedSqlProcessorParameters$instance;

export interface RelationalQueryableMethodTranslatingExpressionVisitor$instance extends QueryableMethodTranslatingExpressionVisitor {
}


export const RelationalQueryableMethodTranslatingExpressionVisitor: {
    new(dependencies: QueryableMethodTranslatingExpressionVisitorDependencies, relationalDependencies: RelationalQueryableMethodTranslatingExpressionVisitorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalQueryableMethodTranslatingExpressionVisitor;
    readonly valuesOrderingColumnName: string;
    readonly valuesValueColumnName: string;
};


export type RelationalQueryableMethodTranslatingExpressionVisitor = RelationalQueryableMethodTranslatingExpressionVisitor$instance;

export interface RelationalQueryableMethodTranslatingExpressionVisitorDependencies$instance {
    model: IModel;
    relationalSqlTranslatingExpressionVisitorFactory: IRelationalSqlTranslatingExpressionVisitorFactory;
    sqlExpressionFactory: ISqlExpressionFactory;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryableMethodTranslatingExpressionVisitorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalQueryableMethodTranslatingExpressionVisitorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalQueryableMethodTranslatingExpressionVisitorDependencies: {
    new(relationalSqlTranslatingExpressionVisitorFactory: IRelationalSqlTranslatingExpressionVisitorFactory, sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource, model: IModel): RelationalQueryableMethodTranslatingExpressionVisitorDependencies;
};


export type RelationalQueryableMethodTranslatingExpressionVisitorDependencies = RelationalQueryableMethodTranslatingExpressionVisitorDependencies$instance;

export interface RelationalQueryCompilationContext$instance extends QueryCompilationContext {
    readonly querySplittingBehavior: Nullable<QuerySplittingBehavior>;
    readonly sqlAliasManager: SqlAliasManager;
}


export const RelationalQueryCompilationContext: {
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async_: boolean): RelationalQueryCompilationContext;
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async_: boolean, precompiling: boolean): RelationalQueryCompilationContext;
};


export type RelationalQueryCompilationContext = RelationalQueryCompilationContext$instance;

export interface RelationalQueryCompilationContextDependencies$instance {
    sqlAliasManagerFactory: ISqlAliasManagerFactory;
    _Clone_$(): RelationalQueryCompilationContextDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalQueryCompilationContextDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalQueryCompilationContextDependencies: {
    new(sqlAliasManagerFactory: ISqlAliasManagerFactory): RelationalQueryCompilationContextDependencies;
};


export type RelationalQueryCompilationContextDependencies = RelationalQueryCompilationContextDependencies$instance;

export interface RelationalQueryContext$instance extends QueryContext {
    readonly commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command> | IRelationalCommandDiagnosticsLogger;
    readonly connection: IRelationalConnection;
    readonly relationalQueryStringFactory: IRelationalQueryStringFactory;
}


export const RelationalQueryContext: {
    new(dependencies: QueryContextDependencies, relationalDependencies: RelationalQueryContextDependencies): RelationalQueryContext;
};


export type RelationalQueryContext = RelationalQueryContext$instance;

export interface RelationalQueryContextDependencies$instance {
    relationalConnection: IRelationalConnection;
    relationalQueryStringFactory: IRelationalQueryStringFactory;
    _Clone_$(): RelationalQueryContextDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalQueryContextDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalQueryContextDependencies: {
    new(relationalConnection: IRelationalConnection, relationalQueryStringFactory: IRelationalQueryStringFactory): RelationalQueryContextDependencies;
};


export type RelationalQueryContextDependencies = RelationalQueryContextDependencies$instance;

export interface RelationalQueryRootProcessor$instance extends QueryRootProcessor {
}


export const RelationalQueryRootProcessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, relationalDependencies: RelationalQueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): RelationalQueryRootProcessor;
};


export type RelationalQueryRootProcessor = RelationalQueryRootProcessor$instance;

export interface RelationalQueryTranslationPostprocessor$instance extends QueryTranslationPostprocessor {
    process(query: Expression): Expression;
}


export const RelationalQueryTranslationPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalQueryTranslationPostprocessor;
};


export type RelationalQueryTranslationPostprocessor = RelationalQueryTranslationPostprocessor$instance;

export interface RelationalQueryTranslationPostprocessorDependencies$instance {
    sqlExpressionFactory: ISqlExpressionFactory;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryTranslationPostprocessorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalQueryTranslationPostprocessorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalQueryTranslationPostprocessorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): RelationalQueryTranslationPostprocessorDependencies;
};


export type RelationalQueryTranslationPostprocessorDependencies = RelationalQueryTranslationPostprocessorDependencies$instance;

export interface RelationalQueryTranslationPreprocessor$instance extends QueryTranslationPreprocessor {
    normalizeQueryableMethod(expression: Expression): Expression;
}


export const RelationalQueryTranslationPreprocessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, relationalDependencies: RelationalQueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): RelationalQueryTranslationPreprocessor;
};


export type RelationalQueryTranslationPreprocessor = RelationalQueryTranslationPreprocessor$instance;

export interface RelationalQueryTranslationPreprocessorDependencies$instance {
    relationalTypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryTranslationPreprocessorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalQueryTranslationPreprocessorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalQueryTranslationPreprocessorDependencies: {
    new(relationalTypeMappingSource: IRelationalTypeMappingSource): RelationalQueryTranslationPreprocessorDependencies;
};


export type RelationalQueryTranslationPreprocessorDependencies = RelationalQueryTranslationPreprocessorDependencies$instance;

export interface RelationalShapedQueryCompilingExpressionVisitor$instance extends ShapedQueryCompilingExpressionVisitor {
    addStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
    addStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
}


export const RelationalShapedQueryCompilingExpressionVisitor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies, relationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext): RelationalShapedQueryCompilingExpressionVisitor;
    nonQueryResult(relationalQueryContext: RelationalQueryContext, relationalCommandResolver: RelationalCommandResolver, contextType: Type, commandSource: CommandSource, threadSafetyChecksEnabled: boolean): int;
    nonQueryResultAsync(relationalQueryContext: RelationalQueryContext, relationalCommandResolver: RelationalCommandResolver, contextType: Type, commandSource: CommandSource, threadSafetyChecksEnabled: boolean): Task<System_Internal.Int32>;
};


export type RelationalShapedQueryCompilingExpressionVisitor = RelationalShapedQueryCompilingExpressionVisitor$instance;

export interface RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor$instance extends ExpressionVisitor {
    processRelationalGroupingResult(relationalGroupByResultExpression: RelationalGroupByResultExpression, relationalCommandResolver: Expression, readerColumns: IReadOnlyList<ReaderColumn>, keySelector: LambdaExpression, keyIdentifier: LambdaExpression, relatedDataLoaders: LambdaExpression, collectionId: int): LambdaExpression;
    processShaper(shaperExpression: Expression, relationalCommandResolver: Expression, readerColumns: IReadOnlyList<ReaderColumn>, relatedDataLoaders: LambdaExpression, collectionId: int): LambdaExpression;
}


export const RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor: {
    new(parentVisitor: RelationalShapedQueryCompilingExpressionVisitor, selectExpression: SelectExpression, tags: ISet<System_Internal.String>, splitQuery: boolean, indexMap: boolean): RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor;
    readonly getFieldValueMethod: MethodInfo;
    any_(source: IEnumerable): boolean;
    includeJsonEntityCollection<TIncludingEntity, TIncludedCollectionElement>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, entity: TIncludingEntity, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TIncludedCollectionElement>, getOrCreateCollectionObject: Action<TIncludingEntity>, fixup: Action<TIncludingEntity, TIncludedCollectionElement>, performFixup: boolean): void;
    includeJsonEntityReference<TStructural, TRelatedStructural>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, structuralType: TStructural, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TRelatedStructural>, fixup: Action<TStructural, TRelatedStructural>, performFixup: boolean): void;
    includeReference<TEntity, TIncludingEntity extends TEntity, TIncludedEntity>(queryContext: QueryContext, entity: TEntity, relatedEntity: TIncludedEntity, navigation: INavigationBase, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    initializeCollection<TElement, TCollection extends ICollection<TElement>>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, clrCollectionAccessor: IClrCollectionAccessor): TCollection;
    initializeIncludeCollection<TParent, TNavigationEntity extends TParent>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, entity: TParent, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, navigation: INavigationBase, clrCollectionAccessor: IClrCollectionAccessor, trackingQuery: boolean, setLoaded: boolean): void;
    initializeSplitCollection<TElement, TCollection extends ICollection<TElement>>(collectionId: int, queryContext: QueryContext, parentDataReader: DbDataReader, resultCoordinator: SplitQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, clrCollectionAccessor: IClrCollectionAccessor): TCollection;
    initializeSplitIncludeCollection<TParent, TNavigationEntity extends TParent>(collectionId: int, queryContext: QueryContext, parentDataReader: DbDataReader, resultCoordinator: SplitQueryResultCoordinator, entity: TParent, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, navigation: INavigationBase, clrCollectionAccessor: IClrCollectionAccessor, trackingQuery: boolean, setLoaded: boolean): void;
    inverseCollectionFixup<TCollectionElement, TEntity>(collection: ICollection<TCollectionElement>, entity: TEntity, elementFixup: Action<TCollectionElement, TEntity>): void;
    materializeJsonEntityCollection<TEntity, TResult>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, structuralProperty: IPropertyBase, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TEntity>): TResult | undefined;
    materializeJsonNullableValueStructuralType<TStructural extends unknown>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, nullable: boolean, shaper: Func<QueryContext, unknown[], JsonReaderData, TStructural>): Nullable<TStructural>;
    materializeJsonStructuralType<TStructural>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, nullable: boolean, shaper: Func<QueryContext, unknown[], JsonReaderData, TStructural>): TStructural | undefined;
    populateCollection<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, selfIdentifier: Func<QueryContext, DbDataReader, unknown[]>, parentIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, outerIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, selfIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator, TRelatedEntity>): void;
    populateIncludeCollection<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, selfIdentifier: Func<QueryContext, DbDataReader, unknown[]>, parentIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, outerIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, selfIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator, TIncludedEntity>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    populateSplitCollection<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TRelatedEntity>, relatedDataLoaders: Action<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator>): void;
    populateSplitCollectionAsync<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TRelatedEntity>, relatedDataLoaders: Func<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator, Task>): Task;
    populateSplitIncludeCollection<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TIncludedEntity>, relatedDataLoaders: Action<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    populateSplitIncludeCollectionAsync<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TIncludedEntity>, relatedDataLoaders: Func<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator, Task>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): Task;
    taskAwaiter(taskFactories: Func<Task>[]): Task;
    throwReadValueException<TValue>(exception: Exception, value: unknown, expectedType: Type, property?: IPropertyBase): TValue;
};


export type RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor = RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor$instance;

export interface RelationalShapedQueryCompilingExpressionVisitorDependencies$instance {
    querySqlGeneratorFactory: IQuerySqlGeneratorFactory;
    relationalLiftableConstantFactory: IRelationalLiftableConstantFactory;
    relationalParameterBasedSqlProcessorFactory: IRelationalParameterBasedSqlProcessorFactory;
    _Clone_$(): RelationalShapedQueryCompilingExpressionVisitorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalShapedQueryCompilingExpressionVisitorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalShapedQueryCompilingExpressionVisitorDependencies: {
    new(querySqlGeneratorFactory: IQuerySqlGeneratorFactory, relationalParameterBasedSqlProcessorFactory: IRelationalParameterBasedSqlProcessorFactory, relationalLiftableConstantFactory: IRelationalLiftableConstantFactory): RelationalShapedQueryCompilingExpressionVisitorDependencies;
};


export type RelationalShapedQueryCompilingExpressionVisitorDependencies = RelationalShapedQueryCompilingExpressionVisitorDependencies$instance;

export interface RelationalSplitCollectionShaperExpression$instance extends Expression {
    readonly childIdentifier: Expression;
    readonly elementType: Type;
    readonly identifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly innerShaper: Expression;
    readonly navigation: INavigationBase;
    readonly nodeType: ExpressionType;
    readonly parentIdentifier: Expression;
    readonly selectExpression: SelectExpression;
    readonly type_: Type;
    update(parentIdentifier: Expression, childIdentifier: Expression, selectExpression: SelectExpression, innerShaper: Expression): RelationalSplitCollectionShaperExpression;
}


export const RelationalSplitCollectionShaperExpression: {
    new(parentIdentifier: Expression, childIdentifier: Expression, identifierValueComparers: IReadOnlyList<ValueComparer>, selectExpression: SelectExpression, innerShaper: Expression, navigation: INavigationBase, elementType: Type): RelationalSplitCollectionShaperExpression;
};


export interface __RelationalSplitCollectionShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalSplitCollectionShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalSplitCollectionShaperExpression = RelationalSplitCollectionShaperExpression$instance & __RelationalSplitCollectionShaperExpression$views;


export interface RelationalSqlTranslatingExpressionVisitor$instance extends ExpressionVisitor {
    readonly translationErrorDetails: string | undefined;
    generateGreatest(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
    generateLeast(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
    translate(expression: Expression, applyDefaultTypeMapping?: boolean): SqlExpression | undefined;
    translateProjection(expression: Expression, applyDefaultTypeMapping?: boolean): Expression | undefined;
    tryBindMember(source: Expression, member: MemberIdentity, expression: Expression, property: IPropertyBase): boolean;
}


export const RelationalSqlTranslatingExpressionVisitor: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
    parameterListValueExtractor<TEntity, TProperty>(context: QueryContext, baseParameterName: string, property: IProperty): List<TProperty | undefined> | undefined;
    parameterValueExtractor<T>(context: QueryContext, baseParameterName: string, complexPropertyChain: List<IComplexProperty>, property: IProperty): T | undefined;
};


export type RelationalSqlTranslatingExpressionVisitor = RelationalSqlTranslatingExpressionVisitor$instance;

export interface RelationalSqlTranslatingExpressionVisitorDependencies$instance {
    readonly aggregateMethodCallTranslatorProvider: IAggregateMethodCallTranslatorProvider;
    memberTranslatorProvider: IMemberTranslatorProvider;
    methodCallTranslatorProvider: IMethodCallTranslatorProvider;
    model: IModel;
    sqlExpressionFactory: ISqlExpressionFactory;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalSqlTranslatingExpressionVisitorDependencies;
    equals(obj: unknown): boolean;
    equals(other: RelationalSqlTranslatingExpressionVisitorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const RelationalSqlTranslatingExpressionVisitorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, model: IModel, typeMappingSource: IRelationalTypeMappingSource, memberTranslatorProvider: IMemberTranslatorProvider, methodCallTranslatorProvider: IMethodCallTranslatorProvider, aggregateMethodCallTranslatorProvider: IAggregateMethodCallTranslatorProvider): RelationalSqlTranslatingExpressionVisitorDependencies;
};


export type RelationalSqlTranslatingExpressionVisitorDependencies = RelationalSqlTranslatingExpressionVisitorDependencies$instance;

export interface RelationalSqlTranslatingExpressionVisitorFactory$instance {
    create(queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
}


export const RelationalSqlTranslatingExpressionVisitorFactory: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies): RelationalSqlTranslatingExpressionVisitorFactory;
};


export interface __RelationalSqlTranslatingExpressionVisitorFactory$views {
    As_IRelationalSqlTranslatingExpressionVisitorFactory(): IRelationalSqlTranslatingExpressionVisitorFactory$instance;
}

export interface RelationalSqlTranslatingExpressionVisitorFactory$instance extends IRelationalSqlTranslatingExpressionVisitorFactory$instance {}

export type RelationalSqlTranslatingExpressionVisitorFactory = RelationalSqlTranslatingExpressionVisitorFactory$instance & __RelationalSqlTranslatingExpressionVisitorFactory$views;


export interface RelationalStructuralTypeShaperExpression$instance extends StructuralTypeShaperExpression$instance {
    makeClrTypeNonNullable(): StructuralTypeShaperExpression;
    makeClrTypeNullable(): StructuralTypeShaperExpression;
    makeNullable(nullable?: boolean): StructuralTypeShaperExpression;
    print(expressionPrinter: ExpressionPrinter): void;
    update(valueBufferExpression: Expression): StructuralTypeShaperExpression;
    withType(type_: ITypeBase): StructuralTypeShaperExpression;
}


export const RelationalStructuralTypeShaperExpression: {
    new(structuralType: ITypeBase, valueBufferExpression: Expression, nullable: boolean): RelationalStructuralTypeShaperExpression;
};


export interface __RelationalStructuralTypeShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalStructuralTypeShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalStructuralTypeShaperExpression = RelationalStructuralTypeShaperExpression$instance & __RelationalStructuralTypeShaperExpression$views;


export interface RelationalTypeMappingPostprocessor$instance extends ExpressionVisitor {
    process(expression: Expression): Expression;
}


export const RelationalTypeMappingPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalTypeMappingPostprocessor;
};


export type RelationalTypeMappingPostprocessor = RelationalTypeMappingPostprocessor$instance;

export interface ReplacingExpressionVisitor$instance extends ExpressionVisitor {
    visit(expression: Expression): Expression | undefined;
}


export const ReplacingExpressionVisitor: {
    new(originals: IReadOnlyList<Expression>, replacements: IReadOnlyList<Expression>): ReplacingExpressionVisitor;
    replace(originals: IReadOnlyList<Expression>, replacements: IReadOnlyList<Expression>, tree: Expression): Expression;
    replace(original: Expression, replacement: Expression, tree: Expression): Expression;
};


export type ReplacingExpressionVisitor = ReplacingExpressionVisitor$instance;

export interface ShapedQueryCompilingExpressionVisitor$instance extends ExpressionVisitor {
    addStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
}


export const ShapedQueryCompilingExpressionVisitor: {
    createNullKeyValueInNoTrackingQuery(entityType: IEntityType, properties: IReadOnlyList<IProperty>, keyValues: unknown[]): Exception;
    singleAsync<TSource>(asyncEnumerable: IAsyncEnumerable<TSource>, cancellationToken?: CancellationToken): Task<TSource>;
    singleOrDefaultAsync<TSource>(asyncEnumerable: IAsyncEnumerable<TSource>, cancellationToken?: CancellationToken): Task<TSource | undefined>;
};


export type ShapedQueryCompilingExpressionVisitor = ShapedQueryCompilingExpressionVisitor$instance;

export interface ShapedQueryCompilingExpressionVisitorDependencies$instance {
    contextServices: IDbContextServices;
    coreSingletonOptions: ICoreSingletonOptions;
    entityMaterializerSource: IStructuralTypeMaterializerSource;
    liftableConstantFactory: ILiftableConstantFactory;
    memoryCache: IMemoryCache;
    model: IModel;
    queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    singletonInterceptors: IEnumerable__System_Collections_Generic<ISingletonInterceptor>;
    typeMappingSource: ITypeMappingSource;
    _Clone_$(): ShapedQueryCompilingExpressionVisitorDependencies;
    equals(obj: unknown): boolean;
    equals(other: ShapedQueryCompilingExpressionVisitorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ShapedQueryCompilingExpressionVisitorDependencies: {
    new(entityMaterializerSource: IStructuralTypeMaterializerSource, typeMappingSource: ITypeMappingSource, memoryCache: IMemoryCache, coreSingletonOptions: ICoreSingletonOptions, model: IModel, liftableConstantFactory: ILiftableConstantFactory, queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>, singletonInterceptors: IEnumerable__System_Collections_Generic<ISingletonInterceptor>, contextServices: IDbContextServices): ShapedQueryCompilingExpressionVisitorDependencies;
};


export type ShapedQueryCompilingExpressionVisitorDependencies = ShapedQueryCompilingExpressionVisitorDependencies$instance;

export interface ShapedQueryExpression$instance extends Expression {
    readonly nodeType: ExpressionType;
    readonly queryExpression: Expression;
    readonly resultCardinality: ResultCardinality;
    readonly shaperExpression: Expression;
    readonly type_: Type;
    update(queryExpression: Expression, shaperExpression: Expression): ShapedQueryExpression;
    updateQueryExpression(queryExpression: Expression): ShapedQueryExpression;
    updateResultCardinality(resultCardinality: ResultCardinality): ShapedQueryExpression;
    updateShaperExpression(shaperExpression: Expression): ShapedQueryExpression;
}


export const ShapedQueryExpression: {
    new(queryExpression: Expression, shaperExpression: Expression): ShapedQueryExpression;
};


export interface __ShapedQueryExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface ShapedQueryExpression$instance extends IPrintableExpression$instance {}

export type ShapedQueryExpression = ShapedQueryExpression$instance & __ShapedQueryExpression$views;


export interface SqlAliasManager$instance {
    generateTableAlias(name: string): string;
    generateTableAlias(modelTable: ITableBase): string;
    postprocessAliases(expression: Expression): Expression;
}


export const SqlAliasManager: {
    new(): SqlAliasManager;
};


export type SqlAliasManager = SqlAliasManager$instance;

export interface SqlAliasManagerFactory$instance {
    create(): SqlAliasManager;
}


export const SqlAliasManagerFactory: {
    new(): SqlAliasManagerFactory;
};


export interface __SqlAliasManagerFactory$views {
    As_ISqlAliasManagerFactory(): ISqlAliasManagerFactory$instance;
}

export interface SqlAliasManagerFactory$instance extends ISqlAliasManagerFactory$instance {}

export type SqlAliasManagerFactory = SqlAliasManagerFactory$instance & __SqlAliasManagerFactory$views;


export interface SqlExpressionFactory$instance {
    add(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    and(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    andAlso(left: SqlExpression, right: SqlExpression): SqlExpression;
    applyDefaultTypeMapping(sqlExpression: SqlExpression): SqlExpression | undefined;
    applyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
    case_(operand: SqlExpression, whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression, existingExpression?: SqlExpression): SqlExpression;
    case_(whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression): SqlExpression;
    coalesce(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, type_: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    constant(value: unknown, type_: Type, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    convert(operand: SqlExpression, type_: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    divide(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    equal(left: SqlExpression, right: SqlExpression): SqlExpression;
    exists(subquery: SelectExpression): SqlExpression;
    fragment(sql: string, type_?: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(schema: string, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    function_(instance: SqlExpression, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, instancePropagatesNullability: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    greaterThan(left: SqlExpression, right: SqlExpression): SqlExpression;
    greaterThanOrEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    in_(item: SqlExpression, subquery: SelectExpression): SqlExpression;
    in_(item: SqlExpression, values: IReadOnlyList<SqlExpression>): SqlExpression;
    in_(item: SqlExpression, valuesParameter: SqlParameterExpression): SqlExpression;
    isNotNull(operand: SqlExpression): SqlExpression;
    isNull(operand: SqlExpression): SqlExpression;
    lessThan(left: SqlExpression, right: SqlExpression): SqlExpression;
    lessThanOrEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    like(match: SqlExpression, pattern: SqlExpression, escapeChar?: SqlExpression): SqlExpression;
    makeBinary(operatorType: ExpressionType, left: SqlExpression, right: SqlExpression, typeMapping: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    makeUnary(operatorType: ExpressionType, operand: SqlExpression, type_: Type, typeMapping?: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    modulo(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    multiply(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    negate(operand: SqlExpression): SqlExpression;
    niladicFunction(name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    niladicFunction(schema: string, name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    niladicFunction(instance: SqlExpression, name: string, nullable: boolean, instancePropagatesNullability: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    not(operand: SqlExpression): SqlExpression;
    notEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    or(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    orElse(left: SqlExpression, right: SqlExpression): SqlExpression;
    subtract(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
}


export const SqlExpressionFactory: {
    new(dependencies: SqlExpressionFactoryDependencies): SqlExpressionFactory;
};


export interface __SqlExpressionFactory$views {
    As_ISqlExpressionFactory(): ISqlExpressionFactory$instance;
}

export type SqlExpressionFactory = SqlExpressionFactory$instance & __SqlExpressionFactory$views;


export interface SqlExpressionFactoryDependencies$instance {
    model: IModel;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): SqlExpressionFactoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: SqlExpressionFactoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const SqlExpressionFactoryDependencies: {
    new(model: IModel, typeMappingSource: IRelationalTypeMappingSource): SqlExpressionFactoryDependencies;
};


export type SqlExpressionFactoryDependencies = SqlExpressionFactoryDependencies$instance;

export interface SqlExpressionVisitor$instance extends ExpressionVisitor {
}


export const SqlExpressionVisitor: {
};


export type SqlExpressionVisitor = SqlExpressionVisitor$instance;

export interface SqlNullabilityProcessor$instance extends ExpressionVisitor {
    readonly collectionParameterTranslationMode: ParameterTranslationMode;
    process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
}


export const SqlNullabilityProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters): SqlNullabilityProcessor;
};


export type SqlNullabilityProcessor = SqlNullabilityProcessor$instance;

export interface SqlTreePruner$instance extends ExpressionVisitor {
    prune(expression: Expression): Expression;
}


export const SqlTreePruner: {
    new(): SqlTreePruner;
};


export type SqlTreePruner = SqlTreePruner$instance;

export interface StructuralTypeProjectionExpression$instance extends Expression {
    readonly discriminatorExpression: SqlExpression | undefined;
    readonly isNullable: boolean;
    readonly nodeType: ExpressionType;
    readonly structuralType: ITypeBase;
    readonly tableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>;
    readonly type_: Type;
    addNavigationBinding(navigation: INavigation, shaper: StructuralTypeShaperExpression): void;
    bindComplexProperty(complexProperty: IComplexProperty): Expression;
    bindNavigation(navigation: INavigation): StructuralTypeShaperExpression | undefined;
    bindProperty(property: IProperty): ColumnExpression;
    makeNullable(): StructuralTypeProjectionExpression;
    toString(): string;
    updateEntityType(derivedType: IEntityType): StructuralTypeProjectionExpression;
    updateTableMap(newTableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>): StructuralTypeProjectionExpression;
}


export const StructuralTypeProjectionExpression: {
    new(type_: ITypeBase, propertyExpressionMap: IReadOnlyDictionary<IProperty, ColumnExpression>, tableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>, nullable: boolean, discriminatorExpression: SqlExpression): StructuralTypeProjectionExpression;
    new(type_: ITypeBase, propertyExpressionMap: IReadOnlyDictionary<IProperty, ColumnExpression>, complexPropertyCache: Dictionary<IComplexProperty, Expression>, tableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>, nullable: boolean, discriminatorExpression: SqlExpression): StructuralTypeProjectionExpression;
};


export type StructuralTypeProjectionExpression = StructuralTypeProjectionExpression$instance;

export interface StructuralTypeShaperExpression$instance extends Expression {
    readonly isNullable: boolean;
    readonly materializationCondition: LambdaExpression;
    readonly nodeType: ExpressionType;
    readonly structuralType: ITypeBase;
    readonly type_: Type;
    readonly valueBufferExpression: Expression;
    debuggerDisplay(): string;
    makeClrTypeNonNullable(): StructuralTypeShaperExpression;
    makeClrTypeNullable(): StructuralTypeShaperExpression;
    makeNullable(nullable?: boolean): StructuralTypeShaperExpression;
    update(valueBufferExpression: Expression): StructuralTypeShaperExpression;
    withType(type_: ITypeBase): StructuralTypeShaperExpression;
}


export const StructuralTypeShaperExpression: {
    new(type_: ITypeBase, valueBufferExpression: Expression, nullable: boolean): StructuralTypeShaperExpression;
    createUnableToDiscriminateException(type_: ITypeBase, discriminator: unknown): Exception;
};


export interface __StructuralTypeShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface StructuralTypeShaperExpression$instance extends IPrintableExpression$instance {}

export type StructuralTypeShaperExpression = StructuralTypeShaperExpression$instance & __StructuralTypeShaperExpression$views;


export interface UpdateSettersBuilder$instance {
    buildSettersExpression(): NewArrayExpression;
    setProperty(propertyExpression: LambdaExpression, valueExpression: LambdaExpression): UpdateSettersBuilder;
    setProperty(propertyExpression: LambdaExpression, valueExpression: Expression): UpdateSettersBuilder;
}


export const UpdateSettersBuilder: {
    new(): UpdateSettersBuilder;
};


export type UpdateSettersBuilder = UpdateSettersBuilder$instance;

export interface UpdateSettersBuilder_1$instance<TSource> extends UpdateSettersBuilder {
    setProperty<TProperty>(propertyExpression: Expression<Func<TSource, TProperty>>, valueExpression: Expression<Func<TSource, TProperty>>): UpdateSettersBuilder_1<TSource>;
    setProperty<TProperty>(propertyExpression: Expression<Func<TSource, TProperty>>, valueExpression: TProperty): UpdateSettersBuilder_1<TSource>;
    setProperty(propertyExpression: LambdaExpression, valueExpression: LambdaExpression): UpdateSettersBuilder;
    setProperty(propertyExpression: LambdaExpression, valueExpression: Expression): UpdateSettersBuilder;
}


export const UpdateSettersBuilder_1: {
    new<TSource>(): UpdateSettersBuilder_1<TSource>;
};


export type UpdateSettersBuilder_1<TSource> = UpdateSettersBuilder_1$instance<TSource>;

export abstract class ExpressionExtensions$instance {
    static inferTypeMapping(...expressions: SqlExpression[]): RelationalTypeMapping | undefined;
    static inferTypeMapping(expressions: IReadOnlyList<SqlExpression>): RelationalTypeMapping | undefined;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class LiftableConstantExpressionHelpers$instance {
    static buildClrCollectionAccessor(structuralProperty: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static buildClrCollectionAccessorLambda(structuralProperty: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static buildMemberAccessForEntityOrComplexType(targetType: ITypeBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static buildMemberAccessForProperty(property: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static buildMemberAccessLambdaForProperty(property: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static buildMemberAccessLambdaForStructuralType(type_: ITypeBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static buildStructuralPropertyAccess(structuralProperty: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static buildStructuralPropertyAccessLambda(structuralProperty: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static isLiteral(value: unknown): boolean;
}


export type LiftableConstantExpressionHelpers = LiftableConstantExpressionHelpers$instance;

export abstract class QueryableMethods$instance {
    static readonly all: MethodInfo;
    static readonly anyWithoutPredicate: MethodInfo;
    static readonly anyWithPredicate: MethodInfo;
    static readonly asQueryable: MethodInfo;
    static readonly cast: MethodInfo;
    static readonly concat: MethodInfo;
    static readonly contains: MethodInfo;
    static readonly countWithoutPredicate: MethodInfo;
    static readonly countWithPredicate: MethodInfo;
    static readonly defaultIfEmptyWithoutArgument: MethodInfo;
    static readonly defaultIfEmptyWithArgument: MethodInfo;
    static readonly distinct: MethodInfo;
    static readonly elementAt: MethodInfo;
    static readonly elementAtOrDefault: MethodInfo;
    static readonly except: MethodInfo;
    static readonly firstWithoutPredicate: MethodInfo;
    static readonly firstWithPredicate: MethodInfo;
    static readonly firstOrDefaultWithoutPredicate: MethodInfo;
    static readonly firstOrDefaultWithPredicate: MethodInfo;
    static readonly groupByWithKeySelector: MethodInfo;
    static readonly groupByWithKeyElementSelector: MethodInfo;
    static readonly groupByWithKeyElementResultSelector: MethodInfo;
    static readonly groupByWithKeyResultSelector: MethodInfo;
    static readonly groupJoin: MethodInfo;
    static readonly intersect: MethodInfo;
    static readonly join: MethodInfo;
    static readonly lastWithoutPredicate: MethodInfo;
    static readonly lastWithPredicate: MethodInfo;
    static readonly lastOrDefaultWithoutPredicate: MethodInfo;
    static readonly lastOrDefaultWithPredicate: MethodInfo;
    static readonly leftJoin: MethodInfo;
    static readonly longCountWithoutPredicate: MethodInfo;
    static readonly longCountWithPredicate: MethodInfo;
    static readonly maxWithoutSelector: MethodInfo;
    static readonly maxWithSelector: MethodInfo;
    static readonly minWithoutSelector: MethodInfo;
    static readonly minWithSelector: MethodInfo;
    static readonly ofType: MethodInfo;
    static readonly order: MethodInfo;
    static readonly orderBy: MethodInfo;
    static readonly orderByDescending: MethodInfo;
    static readonly orderDescending: MethodInfo;
    static readonly reverse: MethodInfo;
    static readonly rightJoin: MethodInfo;
    static readonly select: MethodInfo;
    static readonly selectManyWithoutCollectionSelector: MethodInfo;
    static readonly selectManyWithCollectionSelector: MethodInfo;
    static readonly singleWithoutPredicate: MethodInfo;
    static readonly singleWithPredicate: MethodInfo;
    static readonly singleOrDefaultWithoutPredicate: MethodInfo;
    static readonly singleOrDefaultWithPredicate: MethodInfo;
    static readonly skip: MethodInfo;
    static readonly skipWhile: MethodInfo;
    static readonly take: MethodInfo;
    static readonly takeWhile: MethodInfo;
    static readonly thenBy: MethodInfo;
    static readonly thenByDescending: MethodInfo;
    static readonly union: MethodInfo;
    static readonly where: MethodInfo;
    static getAverageWithoutSelector(type_: Type): MethodInfo;
    static getAverageWithSelector(type_: Type): MethodInfo;
    static getSumWithoutSelector(type_: Type): MethodInfo;
    static getSumWithSelector(type_: Type): MethodInfo;
    static isAverageWithoutSelector(methodInfo: MethodInfo): boolean;
    static isAverageWithSelector(methodInfo: MethodInfo): boolean;
    static isSumWithoutSelector(methodInfo: MethodInfo): boolean;
    static isSumWithSelector(methodInfo: MethodInfo): boolean;
}


export type QueryableMethods = QueryableMethods$instance;

export abstract class RelationalExpressionQuotingUtilities$instance {
    static quoteAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, IAnnotation>): Expression;
    static quoteOrNull<T extends IRelationalQuotableExpression>(expression: T): Expression;
    static quoteTableBase(tableBase: ITableBase): Expression;
    static quoteTags(tags: ISet<System_Internal.String>): Expression;
    static quoteTypeMapping(typeMapping: RelationalTypeMapping): Expression;
}


export type RelationalExpressionQuotingUtilities = RelationalExpressionQuotingUtilities$instance;

export abstract class TransparentIdentifierFactory$instance {
    static create(outerType: Type, innerType: Type): Type;
}


export type TransparentIdentifierFactory = TransparentIdentifierFactory$instance;

