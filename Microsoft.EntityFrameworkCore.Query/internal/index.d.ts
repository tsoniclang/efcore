// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Query
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Abstractions, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { InternalEntityEntry, ISnapshot, IStateManager } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { ValueComparer } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { CommandSource, IDiagnosticsLogger_1, IInterceptors, IRelationalCommandDiagnosticsLogger, ISingletonInterceptor } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import type { IAnnotation, IConcurrencyDetector, ICoreSingletonOptions, ICurrentDbContext, IDbContextOptions } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IDbContextServices } from "../../Microsoft.EntityFrameworkCore.Internal/internal/index.js";
import type { IClrCollectionAccessor, IComplexProperty, IComplexType, IEntityType, IKey, IModel, INavigation, INavigationBase, IProperty, IPropertyBase, ITableBase, ITypeBase, MemberIdentity } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { RelationalCommandResolver, ResultContext, SingleQueryResultCoordinator, SplitQueryResultCoordinator } from "../../Microsoft.EntityFrameworkCore.Query.Internal/internal/index.js";
import type { AtTimeZoneExpression, CaseExpression, CaseWhenClause, CollateExpression, ColumnExpression, ColumnValueSetter, CrossApplyExpression, CrossJoinExpression, DeleteExpression, DistinctExpression, ExceptExpression, ExistsExpression, FromSqlExpression, InExpression, InnerJoinExpression, IntersectExpression, JsonScalarExpression, LeftJoinExpression, LikeExpression, OrderingExpression, OuterApplyExpression, ProjectionExpression, RightJoinExpression, RowNumberExpression, RowValueExpression, ScalarSubqueryExpression, SelectExpression, SetOperationBase, SqlBinaryExpression, SqlConstantExpression, SqlExpression, SqlFragmentExpression, SqlFunctionExpression, SqlParameterExpression, SqlUnaryExpression, TableExpression, TableExpressionBase, TableValuedFunctionExpression, UnionExpression, UpdateExpression, ValuesExpression } from "../../Microsoft.EntityFrameworkCore.Query.SqlExpressions/internal/index.js";
import type { JsonReaderData } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import type { IExceptionDetector, IExecutionStrategy, IntTypeMapping, IParameterNameGeneratorFactory, IRelationalCommand, IRelationalCommandBuilder, IRelationalCommandBuilderFactory, IRelationalConnection, IRelationalTypeMappingSource, ISqlGenerationHelper, ITypeMappingSource, MaterializationContext, ReaderColumn, RelationalCommandBuilderDependencies, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { DbContext, DbLoggerCategory_Database_Command, DbLoggerCategory_Query, ParameterTranslationMode, QuerySplittingBehavior, QueryTrackingBehavior } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Dictionary, HashSet, IAsyncEnumerable, ICollection, IEnumerable as IEnumerable__System_Collections_Generic, IEqualityComparer, IReadOnlyCollection, IReadOnlyDictionary, IReadOnlyList, IReadOnlySet, ISet, List } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import type { DbCommand, DbDataReader } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Attribute, Boolean as ClrBoolean, Char, Enum, Exception, Func, IComparable, IConvertible, IDisposable, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, ReadOnlySpan, String as ClrString, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Linq_Expressions_Internal from "@tsonic/dotnet/System.Linq.Expressions.js";
import type { BinaryExpression, BlockExpression, ConditionalExpression, ConstantExpression, DefaultExpression, Expression, ExpressionType, ExpressionVisitor, GotoExpression, IndexExpression, InvocationExpression, LabelExpression, LambdaExpression, ListInitExpression, LoopExpression, MemberExpression, MemberInitExpression, MethodCallExpression, NewArrayExpression, NewExpression, ParameterExpression, SwitchExpression, TryExpression, TypeBinaryExpression, UnaryExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import * as System_Linq_Internal from "@tsonic/dotnet/System.Linq.js";
import type { IQueryable, IQueryProvider } from "@tsonic/dotnet/System.Linq.js";
import type { MemberInfo, MethodInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";
import type { IMemoryCache } from "@tsonic/microsoft-extensions/Microsoft.Extensions.Caching.Memory.js";

export enum ResultCardinality {
    Enumerable = 0,
    Single = 1,
    SingleOrDefault = 2
}


export interface IAggregateMethodCallTranslator$instance {
    Translate(method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IAggregateMethodCallTranslator = IAggregateMethodCallTranslator$instance;

export interface IAggregateMethodCallTranslatorPlugin$instance {
    readonly Translators: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslator>;
}


export type IAggregateMethodCallTranslatorPlugin = IAggregateMethodCallTranslatorPlugin$instance;

export interface IAggregateMethodCallTranslatorProvider$instance {
    Translate(model: IModel, method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IAggregateMethodCallTranslatorProvider = IAggregateMethodCallTranslatorProvider$instance;

export interface IAsyncQueryProvider$instance extends IQueryProvider {
    ExecuteAsync<TResult>(expression: Expression, cancellationToken?: CancellationToken): TResult;
}


export interface IAsyncQueryProvider$instance extends System_Linq_Internal.IQueryProvider {}

export type IAsyncQueryProvider = IAsyncQueryProvider$instance;

export interface ICompiledQueryCacheKeyGenerator$instance {
    GenerateCacheKey(query: Expression, async: boolean): unknown;
}


export type ICompiledQueryCacheKeyGenerator = ICompiledQueryCacheKeyGenerator$instance;

export interface IEntityMaterializerSource$instance {
}


export type IEntityMaterializerSource = IEntityMaterializerSource$instance;

export interface IEvaluatableExpressionFilter$instance {
    IsEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export type IEvaluatableExpressionFilter = IEvaluatableExpressionFilter$instance;

export interface IEvaluatableExpressionFilterPlugin$instance {
    IsEvaluatableExpression(expression: Expression): boolean;
}


export type IEvaluatableExpressionFilterPlugin = IEvaluatableExpressionFilterPlugin$instance;

export interface IIncludableQueryable_2$instance<TEntity, TProperty> extends IQueryable<TEntity>, IEnumerable__System_Collections_Generic<TEntity>, IEnumerable, IQueryable {
}


export interface IIncludableQueryable_2$instance<TEntity, TProperty> extends System_Collections_Generic_Internal.IEnumerable<TEntity>, System_Linq_Internal.IQueryable<TEntity> {}

export type IIncludableQueryable_2<TEntity, TProperty> = IIncludableQueryable_2$instance<TEntity, TProperty>;

export interface ILiftableConstantFactory$instance {
    CreateLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type: Type): Expression;
}


export type ILiftableConstantFactory = ILiftableConstantFactory$instance;

export interface ILiftableConstantProcessor$instance {
    readonly LiftedConstants: IReadOnlyList<ValueTuple<ParameterExpression, Expression>>;
    InlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    LiftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
}


export type ILiftableConstantProcessor = ILiftableConstantProcessor$instance;

export interface IMemberTranslator$instance {
    Translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMemberTranslator = IMemberTranslator$instance;

export interface IMemberTranslatorPlugin$instance {
    readonly Translators: IEnumerable__System_Collections_Generic<IMemberTranslator>;
}


export type IMemberTranslatorPlugin = IMemberTranslatorPlugin$instance;

export interface IMemberTranslatorProvider$instance {
    Translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMemberTranslatorProvider = IMemberTranslatorProvider$instance;

export interface IMethodCallTranslator$instance {
    Translate(instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMethodCallTranslator = IMethodCallTranslator$instance;

export interface IMethodCallTranslatorPlugin$instance {
    readonly Translators: IEnumerable__System_Collections_Generic<IMethodCallTranslator>;
}


export type IMethodCallTranslatorPlugin = IMethodCallTranslatorPlugin$instance;

export interface IMethodCallTranslatorProvider$instance {
    Translate(model: IModel, instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export type IMethodCallTranslatorProvider = IMethodCallTranslatorProvider$instance;

export interface INavigationExpansionExtensibilityHelper$instance {
    AreQueryRootsCompatible(first: EntityQueryRootExpression, second: EntityQueryRootExpression): boolean;
    CreateQueryRoot(entityType: IEntityType, source: EntityQueryRootExpression): EntityQueryRootExpression;
    ValidateQueryRootCreation(entityType: IEntityType, source: EntityQueryRootExpression): void;
}


export type INavigationExpansionExtensibilityHelper = INavigationExpansionExtensibilityHelper$instance;

export interface IPrintableExpression$instance {
    Print(expressionPrinter: ExpressionPrinter): void;
}


export type IPrintableExpression = IPrintableExpression$instance;

export interface IQueryableMethodTranslatingExpressionVisitorFactory$instance {
    Create(queryCompilationContext: QueryCompilationContext): QueryableMethodTranslatingExpressionVisitor;
}


export type IQueryableMethodTranslatingExpressionVisitorFactory = IQueryableMethodTranslatingExpressionVisitorFactory$instance;

export interface IQueryCompilationContextFactory$instance {
    Create(async: boolean): QueryCompilationContext;
}


export type IQueryCompilationContextFactory = IQueryCompilationContextFactory$instance;

export interface IQueryContextFactory$instance {
    Create(): QueryContext;
}


export type IQueryContextFactory = IQueryContextFactory$instance;

export interface IQueryingEnumerable$instance {
    ToQueryString(): string;
}


export type IQueryingEnumerable = IQueryingEnumerable$instance;

export interface IQuerySqlGeneratorFactory$instance {
    Create(): QuerySqlGenerator;
}


export type IQuerySqlGeneratorFactory = IQuerySqlGeneratorFactory$instance;

export interface IQueryTranslationPostprocessorFactory$instance {
    Create(queryCompilationContext: QueryCompilationContext): QueryTranslationPostprocessor;
}


export type IQueryTranslationPostprocessorFactory = IQueryTranslationPostprocessorFactory$instance;

export interface IQueryTranslationPreprocessorFactory$instance {
    Create(queryCompilationContext: QueryCompilationContext): QueryTranslationPreprocessor;
}


export type IQueryTranslationPreprocessorFactory = IQueryTranslationPreprocessorFactory$instance;

export interface IRelationalLiftableConstantFactory$instance extends ILiftableConstantFactory {
    CreateLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type: Type): Expression;
    CreateLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<RelationalMaterializerLiftableConstantContext, unknown>>, variableName: string, type: Type): LiftableConstantExpression;
}


export interface IRelationalLiftableConstantFactory$instance extends ILiftableConstantFactory$instance {}

export type IRelationalLiftableConstantFactory = IRelationalLiftableConstantFactory$instance;

export interface IRelationalParameterBasedSqlProcessorFactory$instance {
    Create(parameters: RelationalParameterBasedSqlProcessorParameters): RelationalParameterBasedSqlProcessor;
}


export type IRelationalParameterBasedSqlProcessorFactory = IRelationalParameterBasedSqlProcessorFactory$instance;

export interface IRelationalQueryStringFactory$instance {
    Create(command: DbCommand): string;
}


export type IRelationalQueryStringFactory = IRelationalQueryStringFactory$instance;

export interface IRelationalQuotableExpression$instance {
    Quote(): Expression;
}


export type IRelationalQuotableExpression = IRelationalQuotableExpression$instance;

export interface IRelationalSqlTranslatingExpressionVisitorFactory$instance {
    Create(queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
}


export type IRelationalSqlTranslatingExpressionVisitorFactory = IRelationalSqlTranslatingExpressionVisitorFactory$instance;

export interface IShapedQueryCompilingExpressionVisitorFactory$instance {
    Create(queryCompilationContext: QueryCompilationContext): ShapedQueryCompilingExpressionVisitor;
}


export type IShapedQueryCompilingExpressionVisitorFactory = IShapedQueryCompilingExpressionVisitorFactory$instance;

export interface ISqlAliasManagerFactory$instance {
    Create(): SqlAliasManager;
}


export type ISqlAliasManagerFactory = ISqlAliasManagerFactory$instance;

export interface ISqlExpressionFactory$instance {
    Add(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    ApplyDefaultTypeMapping(sqlExpression: SqlExpression): SqlExpression | undefined;
    ApplyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
    Case(operand: SqlExpression, whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression, existingExpression?: SqlExpression): SqlExpression;
    Case(whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression): SqlExpression;
    Constant(value: unknown, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, type: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, type: Type, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    Convert(operand: SqlExpression, type: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Equal(left: SqlExpression, right: SqlExpression): SqlExpression;
    Exists(subquery: SelectExpression): SqlExpression;
    Fragment(sql: string, type?: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(instance: SqlExpression, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, instancePropagatesNullability: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(schema: string, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    In(item: SqlExpression, subquery: SelectExpression): SqlExpression;
    In(item: SqlExpression, valuesParameter: SqlParameterExpression): SqlExpression;
    In(item: SqlExpression, values: IReadOnlyList<SqlExpression>): SqlExpression;
    Like(match: SqlExpression, pattern: SqlExpression, escapeChar?: SqlExpression): SqlExpression;
    MakeBinary(operatorType: ExpressionType, left: SqlExpression, right: SqlExpression, typeMapping: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    MakeUnary(operatorType: ExpressionType, operand: SqlExpression, type: Type, typeMapping?: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    NiladicFunction(instance: SqlExpression, name: string, nullable: boolean, instancePropagatesNullability: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    NiladicFunction(name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    NiladicFunction(schema: string, name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
}


export type ISqlExpressionFactory = ISqlExpressionFactory$instance;

export interface IStructuralTypeMaterializerSource$instance {
    CreateMaterializeExpression(parameters: StructuralTypeMaterializerSourceParameters, materializationExpression: Expression): Expression;
    GetMaterializer(complexType: IComplexType): Func<MaterializationContext, unknown>;
    GetMaterializer(entityType: IEntityType): Func<MaterializationContext, unknown>;
}


export type IStructuralTypeMaterializerSource = IStructuralTypeMaterializerSource$instance;

export interface EntityMaterializerSourceParameters$instance {
    InstanceName: string;
    QueryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    StructuralType: ITypeBase;
    Deconstruct(StructuralType: ITypeBase, InstanceName: string, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): void;
    Equals(obj: unknown): boolean;
    Equals(other: EntityMaterializerSourceParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const EntityMaterializerSourceParameters: {
    new(StructuralType: ITypeBase, InstanceName: string, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): EntityMaterializerSourceParameters;
};


export type EntityMaterializerSourceParameters = EntityMaterializerSourceParameters$instance;

export interface PathSegment$instance {
    readonly ArrayIndex: SqlExpression | undefined;
    readonly PropertyName: string | undefined;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Quote(): Expression;
    ToString(): string;
}


export const PathSegment: {
    new(propertyName: string): PathSegment;
    new(arrayIndex: SqlExpression): PathSegment;
};


export interface __PathSegment$views {
    As_IRelationalQuotableExpression(): IRelationalQuotableExpression$instance;
}

export interface PathSegment$instance extends IRelationalQuotableExpression$instance {}

export type PathSegment = PathSegment$instance & __PathSegment$views;


export interface StructuralTypeMaterializerSourceParameters$instance {
    ClrType: Type;
    InstanceName: string;
    IsNullable: boolean;
    QueryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    StructuralType: ITypeBase;
    Deconstruct(StructuralType: ITypeBase, InstanceName: string, ClrType: Type, IsNullable: boolean, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): void;
    Equals(obj: unknown): boolean;
    Equals(other: StructuralTypeMaterializerSourceParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const StructuralTypeMaterializerSourceParameters: {
    new(StructuralType: ITypeBase, InstanceName: string, ClrType: Type, IsNullable: boolean, QueryTrackingBehavior: Nullable<QueryTrackingBehavior>): StructuralTypeMaterializerSourceParameters;
};


export type StructuralTypeMaterializerSourceParameters = StructuralTypeMaterializerSourceParameters$instance;

export interface CollectionResultExpression$instance extends Expression {
    readonly ElementType: Type;
    readonly Navigation: INavigationBase | undefined;
    readonly NodeType: ExpressionType;
    readonly ProjectionBindingExpression: ProjectionBindingExpression;
    readonly QueryExpression: Expression;
    readonly StructuralProperty: IPropertyBase | undefined;
    readonly Type: Type;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(queryExpression: Expression): CollectionResultExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const CollectionResultExpression: {
    new(queryExpression: Expression, structuralProperty: IPropertyBase, elementType: Type): CollectionResultExpression;
};


export interface __CollectionResultExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface CollectionResultExpression$instance extends IPrintableExpression$instance {}

export type CollectionResultExpression = CollectionResultExpression$instance & __CollectionResultExpression$views;


export interface CompiledQueryCacheKeyGenerator$instance {
    readonly Dependencies: CompiledQueryCacheKeyGeneratorDependencies;
    GenerateCacheKey(query: Expression, async: boolean): unknown;
}


export const CompiledQueryCacheKeyGenerator: {
    new(dependencies: CompiledQueryCacheKeyGeneratorDependencies): CompiledQueryCacheKeyGenerator;
};


export interface __CompiledQueryCacheKeyGenerator$views {
    As_ICompiledQueryCacheKeyGenerator(): ICompiledQueryCacheKeyGenerator$instance;
}

export interface CompiledQueryCacheKeyGenerator$instance extends ICompiledQueryCacheKeyGenerator$instance {}

export type CompiledQueryCacheKeyGenerator = CompiledQueryCacheKeyGenerator$instance & __CompiledQueryCacheKeyGenerator$views;


export interface CompiledQueryCacheKeyGeneratorDependencies$instance {
    CurrentContext: ICurrentDbContext;
    IsRetryingExecutionStrategy: boolean;
    Model: IModel;
    _Clone_$(): CompiledQueryCacheKeyGeneratorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: CompiledQueryCacheKeyGeneratorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CompiledQueryCacheKeyGeneratorDependencies: {
    new(model: IModel, currentContext: ICurrentDbContext, executionStrategy: IExecutionStrategy): CompiledQueryCacheKeyGeneratorDependencies;
};


export type CompiledQueryCacheKeyGeneratorDependencies = CompiledQueryCacheKeyGeneratorDependencies$instance;

export interface EntityQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly CanReduce: boolean;
    readonly EntityType: IEntityType;
    readonly NodeType: ExpressionType;
    DetachQueryProvider(): Expression;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Print(expressionPrinter: ExpressionPrinter): void;
    UpdateEntityType(entityType: IEntityType): EntityQueryRootExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const EntityQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, entityType: IEntityType): EntityQueryRootExpression;
    new(entityType: IEntityType): EntityQueryRootExpression;
};


export interface __EntityQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export type EntityQueryRootExpression = EntityQueryRootExpression$instance & __EntityQueryRootExpression$views;


export interface EnumerableExpression$instance extends Expression {
    readonly IsDistinct: boolean;
    readonly NodeType: ExpressionType;
    readonly Orderings: IReadOnlyList<OrderingExpression>;
    readonly Predicate: SqlExpression | undefined;
    readonly Selector: Expression;
    readonly Type: Type;
    AppendOrdering(orderingExpression: OrderingExpression): EnumerableExpression;
    ApplyOrdering(orderingExpression: OrderingExpression): EnumerableExpression;
    ApplyPredicate(sqlExpression: SqlExpression): EnumerableExpression;
    ApplySelector(expression: Expression): EnumerableExpression;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Print(expressionPrinter: ExpressionPrinter): void;
    SetDistinct(value: boolean): EnumerableExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const EnumerableExpression: {
    new(selector: Expression): EnumerableExpression;
};


export interface __EnumerableExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface EnumerableExpression$instance extends IPrintableExpression$instance {}

export type EnumerableExpression = EnumerableExpression$instance & __EnumerableExpression$views;


export interface EvaluatableExpressionFilter$instance {
    readonly Dependencies: EvaluatableExpressionFilterDependencies;
    IsEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export const EvaluatableExpressionFilter: {
    new(dependencies: EvaluatableExpressionFilterDependencies): EvaluatableExpressionFilter;
};


export interface __EvaluatableExpressionFilter$views {
    As_IEvaluatableExpressionFilter(): IEvaluatableExpressionFilter$instance;
}

export interface EvaluatableExpressionFilter$instance extends IEvaluatableExpressionFilter$instance {}

export type EvaluatableExpressionFilter = EvaluatableExpressionFilter$instance & __EvaluatableExpressionFilter$views;


export interface EvaluatableExpressionFilterDependencies$instance {
    Plugins: IEnumerable__System_Collections_Generic<IEvaluatableExpressionFilterPlugin>;
    _Clone_$(): EvaluatableExpressionFilterDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: EvaluatableExpressionFilterDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const EvaluatableExpressionFilterDependencies: {
    new(plugins: IEnumerable__System_Collections_Generic<IEvaluatableExpressionFilterPlugin>): EvaluatableExpressionFilterDependencies;
};


export type EvaluatableExpressionFilterDependencies = EvaluatableExpressionFilterDependencies$instance;

export interface ExpressionEqualityComparer$instance {
    Equals(x: Expression, y: Expression): boolean;
    GetHashCode(obj: Expression): int;
}


export const ExpressionEqualityComparer: {
    readonly Instance: ExpressionEqualityComparer;
};


export type ExpressionEqualityComparer = ExpressionEqualityComparer$instance;

export interface ExpressionPrinter$instance extends ExpressionVisitor {
    Append(value: string): ExpressionPrinter;
    AppendLine(): ExpressionPrinter;
    AppendLine(value: string): ExpressionPrinter;
    AppendLines(value: string, skipFinalNewline?: boolean): ExpressionPrinter;
    GenerateBinaryOperator(expressionType: ExpressionType): string;
    Indent(): IDisposable;
    PrintExpression(expression: Expression, characterLimit?: Nullable<System_Internal.Int32>): string;
    PrintExpressionDebug(expression: Expression): string;
    ToString(): string;
    Visit(expression: Expression): Expression | undefined;
    VisitBinary(binaryExpression: BinaryExpression): Expression;
    VisitBlock(blockExpression: BlockExpression): Expression;
    VisitCollection<T extends Expression>(items: IReadOnlyCollection<T>, joinAction?: Action<ExpressionPrinter>): void;
    VisitConditional(conditionalExpression: ConditionalExpression): Expression;
    VisitConstant(constantExpression: ConstantExpression): Expression;
    VisitDefault(defaultExpression: DefaultExpression): Expression;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitGoto(gotoExpression: GotoExpression): Expression;
    VisitIndex(indexExpression: IndexExpression): Expression;
    VisitInvocation(invocationExpression: InvocationExpression): Expression;
    VisitLabel(labelExpression: LabelExpression): Expression;
    VisitLambda<T>(lambdaExpression: Expression<T>): Expression;
    VisitLoop(loopExpression: LoopExpression): Expression;
    VisitMember(memberExpression: MemberExpression): Expression;
    VisitMemberInit(memberInitExpression: MemberInitExpression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
    VisitNew(newExpression: NewExpression): Expression;
    VisitNewArray(newArrayExpression: NewArrayExpression): Expression;
    VisitParameter(parameterExpression: ParameterExpression): Expression;
    VisitSwitch(switchExpression: SwitchExpression): Expression;
    VisitTry(tryExpression: TryExpression): Expression;
    VisitTypeBinary(typeBinaryExpression: TypeBinaryExpression): Expression;
    VisitUnary(unaryExpression: UnaryExpression): Expression;
}


export const ExpressionPrinter: {
    new(): ExpressionPrinter;
    Print(expression: Expression): string;
    PrintDebug(expression: Expression): string;
};


export type ExpressionPrinter = ExpressionPrinter$instance;

export interface GroupByShaperExpression$instance extends Expression {
    readonly GroupingEnumerable: ShapedQueryExpression;
    readonly KeySelector: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(keySelector: Expression, groupingEnumerable: ShapedQueryExpression): GroupByShaperExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const GroupByShaperExpression: {
    new(keySelector: Expression, groupingEnumerable: ShapedQueryExpression): GroupByShaperExpression;
};


export interface __GroupByShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface GroupByShaperExpression$instance extends IPrintableExpression$instance {}

export type GroupByShaperExpression = GroupByShaperExpression$instance & __GroupByShaperExpression$views;


export interface IncludeExpression$instance extends Expression {
    readonly EntityExpression: Expression;
    readonly Navigation: INavigationBase;
    readonly NavigationExpression: Expression;
    readonly NodeType: ExpressionType;
    readonly SetLoaded: boolean;
    readonly Type: Type;
    Update(entityExpression: Expression, navigationExpression: Expression): IncludeExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const IncludeExpression: {
    new(entityExpression: Expression, navigationExpression: Expression, navigation: INavigationBase): IncludeExpression;
    new(entityExpression: Expression, navigationExpression: Expression, navigation: INavigationBase, setLoaded: boolean): IncludeExpression;
};


export interface __IncludeExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface IncludeExpression$instance extends IPrintableExpression$instance {}

export type IncludeExpression = IncludeExpression$instance & __IncludeExpression$views;


export interface InlineQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly Values: IReadOnlyList<Expression>;
    DetachQueryProvider(): Expression;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(values: IReadOnlyList<Expression>): InlineQueryRootExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const InlineQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, values: IReadOnlyList<Expression>, elementType: Type): InlineQueryRootExpression;
    new(values: IReadOnlyList<Expression>, elementType: Type): InlineQueryRootExpression;
};


export interface __InlineQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export type InlineQueryRootExpression = InlineQueryRootExpression$instance & __InlineQueryRootExpression$views;


export interface JsonQueryExpression$instance extends Expression {
    readonly IsCollection: boolean;
    readonly IsNullable: boolean;
    readonly JsonColumn: ColumnExpression;
    readonly KeyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression> | undefined;
    readonly NodeType: ExpressionType;
    readonly Path: IReadOnlyList<PathSegment>;
    readonly StructuralType: ITypeBase;
    readonly Type: Type;
    BindCollectionElement(collectionIndexExpression: SqlExpression): JsonQueryExpression;
    BindProperty(property: IProperty): SqlExpression;
    BindStructuralProperty(structuralProperty: IPropertyBase): JsonQueryExpression;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    MakeNullable(): JsonQueryExpression;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>): JsonQueryExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const JsonQueryExpression: {
    new(structuralType: ITypeBase, jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>, type: Type, collection: boolean): JsonQueryExpression;
    new(structuralType: ITypeBase, jsonColumn: ColumnExpression, keyPropertyMap: IReadOnlyDictionary<IProperty, ColumnExpression>, path: IReadOnlyList<PathSegment>, type: Type, collection: boolean, nullable: boolean): JsonQueryExpression;
};


export interface __JsonQueryExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface JsonQueryExpression$instance extends IPrintableExpression$instance {}

export type JsonQueryExpression = JsonQueryExpression$instance & __JsonQueryExpression$views;


export interface LiftableConstantExpression$instance extends Expression {
    readonly NodeType: ExpressionType;
    readonly OriginalExpression: ConstantExpression;
    readonly ResolverExpression: LambdaExpression;
    readonly Type: Type;
    readonly VariableName: string;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(resolverExpression: LambdaExpression): LiftableConstantExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const LiftableConstantExpression: {
    new(originalValue: unknown, resolverExpression: LambdaExpression, variableName: string, type: Type): LiftableConstantExpression;
};


export interface __LiftableConstantExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface LiftableConstantExpression$instance extends IPrintableExpression$instance {}

export type LiftableConstantExpression = LiftableConstantExpression$instance & __LiftableConstantExpression$views;


export interface LiftableConstantExpressionDependencies$instance {
    _Clone_$(): LiftableConstantExpressionDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: LiftableConstantExpressionDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const LiftableConstantExpressionDependencies: {
    new(): LiftableConstantExpressionDependencies;
};


export type LiftableConstantExpressionDependencies = LiftableConstantExpressionDependencies$instance;

export interface LiftableConstantFactory$instance {
    readonly Dependencies: LiftableConstantExpressionDependencies;
    CreateLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type: Type): Expression;
}


export const LiftableConstantFactory: {
    new(dependencies: LiftableConstantExpressionDependencies): LiftableConstantFactory;
};


export interface __LiftableConstantFactory$views {
    As_ILiftableConstantFactory(): ILiftableConstantFactory$instance;
}

export interface LiftableConstantFactory$instance extends ILiftableConstantFactory$instance {}

export type LiftableConstantFactory = LiftableConstantFactory$instance & __LiftableConstantFactory$views;


export interface LiftableConstantProcessor$instance extends ExpressionVisitor {
    LiftedConstants: IReadOnlyList<ValueTuple<ParameterExpression, Expression>>;
    InlineConstant(liftableConstant: LiftableConstantExpression): ConstantExpression;
    InlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    LiftConstant(liftableConstant: LiftableConstantExpression): ParameterExpression;
    LiftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
    VisitBinary(binaryExpression: BinaryExpression): Expression;
    VisitExtension(node: Expression): Expression;
}


export const LiftableConstantProcessor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies): LiftableConstantProcessor;
};


export interface __LiftableConstantProcessor$views {
    As_ILiftableConstantProcessor(): ILiftableConstantProcessor$instance;
}

export type LiftableConstantProcessor = LiftableConstantProcessor$instance & __LiftableConstantProcessor$views;


export interface MaterializeCollectionNavigationExpression$instance extends Expression {
    readonly Navigation: INavigationBase;
    readonly NodeType: ExpressionType;
    readonly Subquery: Expression;
    readonly Type: Type;
    Update(subquery: Expression): MaterializeCollectionNavigationExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const MaterializeCollectionNavigationExpression: {
    new(subquery: Expression, navigation: INavigationBase): MaterializeCollectionNavigationExpression;
};


export interface __MaterializeCollectionNavigationExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface MaterializeCollectionNavigationExpression$instance extends IPrintableExpression$instance {}

export type MaterializeCollectionNavigationExpression = MaterializeCollectionNavigationExpression$instance & __MaterializeCollectionNavigationExpression$views;


export interface MaterializerLiftableConstantContext$instance {
    Dependencies: ShapedQueryCompilingExpressionVisitorDependencies;
    readonly EqualityContract: Type;
    _Clone_$(): MaterializerLiftableConstantContext;
    Deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): void;
    Equals(obj: unknown): boolean;
    Equals(other: MaterializerLiftableConstantContext): boolean;
    GetHashCode(): int;
    PrintMembers(builder: StringBuilder): boolean;
    ToString(): string;
}


export const MaterializerLiftableConstantContext: {
    new(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): MaterializerLiftableConstantContext;
};


export type MaterializerLiftableConstantContext = MaterializerLiftableConstantContext$instance;

export interface NavigationExpansionExtensibilityHelper$instance {
    readonly Dependencies: NavigationExpansionExtensibilityHelperDependencies;
    AreQueryRootsCompatible(first: EntityQueryRootExpression, second: EntityQueryRootExpression): boolean;
    CreateQueryRoot(entityType: IEntityType, source: EntityQueryRootExpression): EntityQueryRootExpression;
    ValidateQueryRootCreation(entityType: IEntityType, source: EntityQueryRootExpression): void;
}


export const NavigationExpansionExtensibilityHelper: {
    new(dependencies: NavigationExpansionExtensibilityHelperDependencies): NavigationExpansionExtensibilityHelper;
};


export interface __NavigationExpansionExtensibilityHelper$views {
    As_INavigationExpansionExtensibilityHelper(): INavigationExpansionExtensibilityHelper$instance;
}

export interface NavigationExpansionExtensibilityHelper$instance extends INavigationExpansionExtensibilityHelper$instance {}

export type NavigationExpansionExtensibilityHelper = NavigationExpansionExtensibilityHelper$instance & __NavigationExpansionExtensibilityHelper$views;


export interface NavigationExpansionExtensibilityHelperDependencies$instance {
    _Clone_$(): NavigationExpansionExtensibilityHelperDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: NavigationExpansionExtensibilityHelperDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NavigationExpansionExtensibilityHelperDependencies: {
    new(): NavigationExpansionExtensibilityHelperDependencies;
};


export type NavigationExpansionExtensibilityHelperDependencies = NavigationExpansionExtensibilityHelperDependencies$instance;

export interface NotParameterizedAttribute$instance extends Attribute {
}


export const NotParameterizedAttribute: {
    new(): NotParameterizedAttribute;
};


export type NotParameterizedAttribute = NotParameterizedAttribute$instance;

export interface ParameterQueryRootExpression$instance extends QueryRootExpression$instance {
    readonly ParameterExpression: ParameterExpression;
    readonly QueryParameterExpression: QueryParameterExpression;
    DetachQueryProvider(): Expression;
    Print(expressionPrinter: ExpressionPrinter): void;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const ParameterQueryRootExpression: {
    new(asyncQueryProvider: IAsyncQueryProvider, elementType: Type, queryParameterExpression: QueryParameterExpression): ParameterQueryRootExpression;
    new(elementType: Type, queryParameterExpression: QueryParameterExpression): ParameterQueryRootExpression;
    new(asyncQueryProvider: IAsyncQueryProvider, elementType: Type, parameterExpression: ParameterExpression): ParameterQueryRootExpression;
    new(elementType: Type, parameterExpression: ParameterExpression): ParameterQueryRootExpression;
};


export interface __ParameterQueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export type ParameterQueryRootExpression = ParameterQueryRootExpression$instance & __ParameterQueryRootExpression$views;


export interface ParametersCacheDecorator$instance {
    CanCache: boolean;
    GetAndDisableCaching(): Dictionary<System_Internal.String, unknown | undefined>;
    IsNull(parameterName: string): boolean;
}


export const ParametersCacheDecorator: {
    new(parameters: Dictionary<System_Internal.String, unknown>): ParametersCacheDecorator;
};


export type ParametersCacheDecorator = ParametersCacheDecorator$instance;

export interface ProjectionBindingExpression$instance extends Expression {
    readonly Index: Nullable<System_Internal.Int32>;
    readonly NodeType: ExpressionType;
    readonly ProjectionMember: ProjectionMember | undefined;
    readonly QueryExpression: Expression;
    readonly Type: Type;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const ProjectionBindingExpression: {
    new(queryExpression: Expression, projectionMember: ProjectionMember, type: Type): ProjectionBindingExpression;
    new(queryExpression: Expression, index: int, type: Type): ProjectionBindingExpression;
};


export interface __ProjectionBindingExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface ProjectionBindingExpression$instance extends IPrintableExpression$instance {}

export type ProjectionBindingExpression = ProjectionBindingExpression$instance & __ProjectionBindingExpression$views;


export interface ProjectionMember$instance {
    readonly Last: MemberInfo | undefined;
    Append(member: MemberInfo): ProjectionMember;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Prepend(member: MemberInfo): ProjectionMember;
    ToString(): string;
}


export const ProjectionMember: {
    new(): ProjectionMember;
};


export type ProjectionMember = ProjectionMember$instance;

export interface QueryableMethodTranslatingExpressionVisitor$instance extends ExpressionVisitor {
    readonly Dependencies: QueryableMethodTranslatingExpressionVisitorDependencies;
    readonly QueryCompilationContext: QueryCompilationContext;
    get TranslationErrorDetails(): string | undefined;
    set TranslationErrorDetails(value: string | undefined);
    AddTranslationErrorDetails(details: string): void;
    CreateShapedQueryExpression(entityType: IEntityType): ShapedQueryExpression | undefined;
    CreateSubqueryVisitor(): QueryableMethodTranslatingExpressionVisitor;
    MarkShaperNullable(shaperExpression: Expression): Expression;
    Translate(expression: Expression): Expression;
    TranslateAll(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateAny(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateAverage(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateCast(source: ShapedQueryExpression, castType: Type): ShapedQueryExpression | undefined;
    TranslateConcat(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateContains(source: ShapedQueryExpression, item: Expression): ShapedQueryExpression | undefined;
    TranslateCount(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateDefaultIfEmpty(source: ShapedQueryExpression, defaultValue: Expression): ShapedQueryExpression | undefined;
    TranslateDistinct(source: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateElementAtOrDefault(source: ShapedQueryExpression, index: Expression, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateExcept(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateExecuteDelete(source: ShapedQueryExpression): Expression | undefined;
    TranslateExecuteUpdate(source: ShapedQueryExpression, setters: IReadOnlyList<QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter>): Expression | undefined;
    TranslateFirstOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateGroupBy(source: ShapedQueryExpression, keySelector: LambdaExpression, elementSelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateGroupJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateInlineQueryRoot(inlineQueryRootExpression: InlineQueryRootExpression): ShapedQueryExpression | undefined;
    TranslateIntersect(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateLastOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateLeftJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateLongCount(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateMax(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateMemberAccess(source: Expression, member: MemberIdentity): ShapedQueryExpression | undefined;
    TranslateMin(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateOfType(source: ShapedQueryExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateOrderBy(source: ShapedQueryExpression, keySelector: LambdaExpression, ascending: boolean): ShapedQueryExpression | undefined;
    TranslateParameterQueryRoot(parameterQueryRootExpression: ParameterQueryRootExpression): ShapedQueryExpression | undefined;
    TranslateReverse(source: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateRightJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSelect(source: ShapedQueryExpression, selector: LambdaExpression): ShapedQueryExpression;
    TranslateSelectMany(source: ShapedQueryExpression, collectionSelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSelectMany(source: ShapedQueryExpression, selector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSingleOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateSkip(source: ShapedQueryExpression, count: Expression): ShapedQueryExpression | undefined;
    TranslateSkipWhile(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSubquery(expression: Expression): ShapedQueryExpression | undefined;
    TranslateSum(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateTake(source: ShapedQueryExpression, count: Expression): ShapedQueryExpression | undefined;
    TranslateTakeWhile(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateThenBy(source: ShapedQueryExpression, keySelector: LambdaExpression, ascending: boolean): ShapedQueryExpression | undefined;
    TranslateUnion(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateWhere(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitMember(memberExpression: MemberExpression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const QueryableMethodTranslatingExpressionVisitor: (abstract new(dependencies: QueryableMethodTranslatingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext, subquery: boolean) => QueryableMethodTranslatingExpressionVisitor) & {
};


export type QueryableMethodTranslatingExpressionVisitor = QueryableMethodTranslatingExpressionVisitor$instance;

export interface QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter$instance {
    PropertySelector: LambdaExpression;
    ValueExpression: Expression;
    _Clone_$(): QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter;
    Deconstruct(PropertySelector: LambdaExpression, ValueExpression: Expression): void;
    Equals(obj: unknown): boolean;
    Equals(other: QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter: {
    new(PropertySelector: LambdaExpression, ValueExpression: Expression): QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter;
};


export type QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter = QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter$instance;

export interface QueryableMethodTranslatingExpressionVisitorDependencies$instance {
    _Clone_$(): QueryableMethodTranslatingExpressionVisitorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QueryableMethodTranslatingExpressionVisitorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryableMethodTranslatingExpressionVisitorDependencies: {
    new(): QueryableMethodTranslatingExpressionVisitorDependencies;
};


export type QueryableMethodTranslatingExpressionVisitorDependencies = QueryableMethodTranslatingExpressionVisitorDependencies$instance;

export interface QueryCompilationContext$instance {
    readonly ContextOptions: IDbContextOptions;
    readonly ContextType: Type;
    readonly Dependencies: QueryCompilationContextDependencies;
    IgnoreAutoIncludes: boolean;
    get IgnoredQueryFilters(): HashSet<System_Internal.String> | undefined;
    set IgnoredQueryFilters(value: HashSet<System_Internal.String> | undefined);
    IgnoreQueryFilters: boolean;
    readonly IsAsync: boolean;
    readonly IsBuffering: boolean;
    readonly IsPrecompiling: boolean;
    readonly Logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    readonly Model: IModel;
    QueryTrackingBehavior: QueryTrackingBehavior;
    readonly SupportsPrecompiledQuery: boolean;
    readonly Tags: ISet<System_Internal.String>;
    AddTag(tag: string): void;
    CreateQueryExecutor<TResult>(query: Expression): Func<QueryContext, TResult>;
    CreateQueryExecutorExpression<TResult>(query: Expression): Expression<Func<QueryContext, TResult>>;
    RegisterRuntimeParameter(name: string, valueExtractor: LambdaExpression): QueryParameterExpression;
}


export const QueryCompilationContext: {
    new(dependencies: QueryCompilationContextDependencies, async: boolean): QueryCompilationContext;
    new(dependencies: QueryCompilationContextDependencies, async: boolean, precompiling: boolean): QueryCompilationContext;
    readonly QueryContextParameter: ParameterExpression;
    readonly NotTranslatedExpression: Expression;
};


export type QueryCompilationContext = QueryCompilationContext$instance;

export interface QueryCompilationContextDependencies$instance {
    readonly Context: DbContext;
    ContextOptions: IDbContextOptions;
    readonly ContextType: Type;
    readonly Interceptors: IInterceptors;
    IsRetryingExecutionStrategy: boolean;
    LiftableConstantFactory: ILiftableConstantFactory;
    LiftableConstantProcessor: ILiftableConstantProcessor;
    Logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    Model: IModel;
    QueryableMethodTranslatingExpressionVisitorFactory: IQueryableMethodTranslatingExpressionVisitorFactory;
    readonly QueryTrackingBehavior: QueryTrackingBehavior;
    QueryTranslationPostprocessorFactory: IQueryTranslationPostprocessorFactory;
    QueryTranslationPreprocessorFactory: IQueryTranslationPreprocessorFactory;
    ShapedQueryCompilingExpressionVisitorFactory: IShapedQueryCompilingExpressionVisitorFactory;
    _Clone_$(): QueryCompilationContextDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QueryCompilationContextDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryCompilationContextDependencies: {
    new(model: IModel, queryTranslationPreprocessorFactory: IQueryTranslationPreprocessorFactory, queryableMethodTranslatingExpressionVisitorFactory: IQueryableMethodTranslatingExpressionVisitorFactory, queryTranslationPostprocessorFactory: IQueryTranslationPostprocessorFactory, shapedQueryCompilingExpressionVisitorFactory: IShapedQueryCompilingExpressionVisitorFactory, liftableConstantFactory: ILiftableConstantFactory, liftableConstantProcessor: ILiftableConstantProcessor, executionStrategy: IExecutionStrategy, currentContext: ICurrentDbContext, contextOptions: IDbContextOptions, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>, interceptors: IInterceptors): QueryCompilationContextDependencies;
};


export type QueryCompilationContextDependencies = QueryCompilationContextDependencies$instance;

export interface QueryContext$instance {
    CancellationToken: CancellationToken;
    readonly CommandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command> | IRelationalCommandDiagnosticsLogger;
    readonly ConcurrencyDetector: IConcurrencyDetector;
    readonly Context: DbContext;
    readonly Dependencies: QueryContextDependencies;
    readonly ExceptionDetector: IExceptionDetector;
    readonly ExecutionStrategy: IExecutionStrategy;
    readonly Parameters: Dictionary<System_Internal.String, unknown | undefined>;
    readonly QueryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    InitializeStateManager(standAlone?: boolean): void;
    SetNavigationIsLoaded(entity: unknown, navigation: INavigationBase): void;
    StartTracking(entityType: IEntityType, entity: unknown, snapshot: ISnapshot): InternalEntityEntry;
    TryGetEntry(key: IKey, keyValues: unknown[], throwOnNullKey: boolean, hasNullKey: boolean): InternalEntityEntry | undefined;
}


export const QueryContext: (abstract new(dependencies: QueryContextDependencies) => QueryContext) & {
};


export type QueryContext = QueryContext$instance;

export interface QueryContextDependencies$instance {
    CommandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>;
    ConcurrencyDetector: IConcurrencyDetector;
    CurrentContext: ICurrentDbContext;
    ExceptionDetector: IExceptionDetector;
    ExecutionStrategy: IExecutionStrategy;
    QueryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    readonly StateManager: IStateManager;
    _Clone_$(): QueryContextDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QueryContextDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryContextDependencies: {
    new(currentContext: ICurrentDbContext, executionStrategy: IExecutionStrategy, concurrencyDetector: IConcurrencyDetector, exceptionDetector: IExceptionDetector, commandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command>, queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): QueryContextDependencies;
};


export type QueryContextDependencies = QueryContextDependencies$instance;

export interface QueryParameterExpression$instance extends Expression {
    readonly IsNonNullableReferenceType: boolean;
    readonly Name: string;
    readonly NodeType: ExpressionType;
    readonly TranslationMode: Nullable<ParameterTranslationMode>;
    readonly Type: Type;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Print(expressionPrinter: ExpressionPrinter): void;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const QueryParameterExpression: {
    new(name: string, type: Type): QueryParameterExpression;
    new(name: string, type: Type, translationMode: ParameterTranslationMode): QueryParameterExpression;
    new(name: string, type: Type, translationMode: Nullable<ParameterTranslationMode>, isNonNullableReferenceType: boolean): QueryParameterExpression;
};


export interface __QueryParameterExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface QueryParameterExpression$instance extends IPrintableExpression$instance {}

export type QueryParameterExpression = QueryParameterExpression$instance & __QueryParameterExpression$views;


export interface QueryRootExpression$instance extends Expression {
    readonly CanReduce: boolean;
    readonly ElementType: Type;
    readonly NodeType: ExpressionType;
    readonly QueryProvider: IAsyncQueryProvider | undefined;
    readonly Type: Type;
    DetachQueryProvider(): Expression;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Print(expressionPrinter: ExpressionPrinter): void;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const QueryRootExpression: (abstract new(asyncQueryProvider: IAsyncQueryProvider, elementType: Type) => QueryRootExpression) & (abstract new(elementType: Type) => QueryRootExpression) & {
};


export interface __QueryRootExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface QueryRootExpression$instance extends IPrintableExpression$instance {}

export type QueryRootExpression = QueryRootExpression$instance & __QueryRootExpression$views;


export interface QueryRootProcessor$instance extends ExpressionVisitor {
    ShouldConvertToInlineQueryRoot(expression: Expression): boolean;
    ShouldConvertToParameterQueryRoot(queryParameterExpression: QueryParameterExpression): boolean;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const QueryRootProcessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryRootProcessor;
};


export type QueryRootProcessor = QueryRootProcessor$instance;

export interface QuerySqlGenerator$instance extends SqlExpressionVisitor {
    readonly AliasSeparator: string;
    readonly Dependencies: QuerySqlGeneratorDependencies;
    readonly Sql: IRelationalCommandBuilder;
    CheckComposableSql(sql: string): void;
    CheckComposableSqlTrimmed(sql: ReadOnlySpan<System_Internal.Char>): void;
    GenerateEmptyProjection(selectExpression: SelectExpression): void;
    GenerateExists(existsExpression: ExistsExpression, negated: boolean): void;
    GenerateFrom(selectExpression: SelectExpression): void;
    GenerateIn(inExpression: InExpression, negated: boolean): void;
    GenerateLike(likeExpression: LikeExpression, negated: boolean): void;
    GenerateLimitOffset(selectExpression: SelectExpression): void;
    GenerateOrderings(selectExpression: SelectExpression): void;
    GenerateProjection(selectExpression: SelectExpression): void;
    GeneratePseudoFromClause(): void;
    GenerateRootCommand(queryExpression: Expression): void;
    GenerateSetOperation(setOperation: SetOperationBase): void;
    GenerateSetOperationOperand(setOperation: SetOperationBase, operand: SelectExpression): void;
    GenerateTagsHeaderComment(selectExpression: SelectExpression): void;
    GenerateTagsHeaderComment(tags: ISet<System_Internal.String>): void;
    GenerateTop(selectExpression: SelectExpression): void;
    GenerateValues(valuesExpression: ValuesExpression): void;
    GetCommand(queryExpression: Expression): IRelationalCommand;
    GetOperator(binaryExpression: SqlBinaryExpression): string;
    RequiresParentheses(outerExpression: SqlExpression, innerExpression: SqlExpression): boolean;
    TryGenerateWithoutWrappingSelect(selectExpression: SelectExpression): boolean;
    TryGetOperatorInfo(expression: SqlExpression, precedence: int, isAssociative: boolean): boolean;
    VisitAtTimeZone(atTimeZoneExpression: AtTimeZoneExpression): Expression;
    VisitCase(caseExpression: CaseExpression): Expression;
    VisitCollate(collateExpression: CollateExpression): Expression;
    VisitColumn(columnExpression: ColumnExpression): Expression;
    VisitCrossApply(crossApplyExpression: CrossApplyExpression): Expression;
    VisitCrossJoin(crossJoinExpression: CrossJoinExpression): Expression;
    VisitDelete(deleteExpression: DeleteExpression): Expression;
    VisitDistinct(distinctExpression: DistinctExpression): Expression;
    VisitExcept(exceptExpression: ExceptExpression): Expression;
    VisitExists(existsExpression: ExistsExpression): Expression;
    VisitFromSql(fromSqlExpression: FromSqlExpression): Expression;
    VisitIn(inExpression: InExpression): Expression;
    VisitInnerJoin(innerJoinExpression: InnerJoinExpression): Expression;
    VisitIntersect(intersectExpression: IntersectExpression): Expression;
    VisitJsonScalar(jsonScalarExpression: JsonScalarExpression): Expression;
    VisitLeftJoin(leftJoinExpression: LeftJoinExpression): Expression;
    VisitLike(likeExpression: LikeExpression): Expression;
    VisitOrdering(orderingExpression: OrderingExpression): Expression;
    VisitOuterApply(outerApplyExpression: OuterApplyExpression): Expression;
    VisitProjection(projectionExpression: ProjectionExpression): Expression;
    VisitRightJoin(rightJoinExpression: RightJoinExpression): Expression;
    VisitRowNumber(rowNumberExpression: RowNumberExpression): Expression;
    VisitRowValue(rowValueExpression: RowValueExpression): Expression;
    VisitScalarSubquery(scalarSubqueryExpression: ScalarSubqueryExpression): Expression;
    VisitSelect(selectExpression: SelectExpression): Expression;
    VisitSqlBinary(sqlBinaryExpression: SqlBinaryExpression): Expression;
    VisitSqlConstant(sqlConstantExpression: SqlConstantExpression): Expression;
    VisitSqlFragment(sqlFragmentExpression: SqlFragmentExpression): Expression;
    VisitSqlFunction(sqlFunctionExpression: SqlFunctionExpression): Expression;
    VisitSqlParameter(sqlParameterExpression: SqlParameterExpression): Expression;
    VisitSqlUnary(sqlUnaryExpression: SqlUnaryExpression): Expression;
    VisitTable(tableExpression: TableExpression): Expression;
    VisitTableValuedFunction(tableValuedFunctionExpression: TableValuedFunctionExpression): Expression;
    VisitUnion(unionExpression: UnionExpression): Expression;
    VisitUpdate(updateExpression: UpdateExpression): Expression;
    VisitValues(valuesExpression: ValuesExpression): Expression;
}


export const QuerySqlGenerator: {
    new(dependencies: QuerySqlGeneratorDependencies): QuerySqlGenerator;
};


export type QuerySqlGenerator = QuerySqlGenerator$instance;

export interface QuerySqlGeneratorDependencies$instance {
    RelationalCommandBuilderFactory: IRelationalCommandBuilderFactory;
    SqlGenerationHelper: ISqlGenerationHelper;
    _Clone_$(): QuerySqlGeneratorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QuerySqlGeneratorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QuerySqlGeneratorDependencies: {
    new(relationalCommandBuilderFactory: IRelationalCommandBuilderFactory, sqlGenerationHelper: ISqlGenerationHelper): QuerySqlGeneratorDependencies;
};


export type QuerySqlGeneratorDependencies = QuerySqlGeneratorDependencies$instance;

export interface QueryTranslationPostprocessor$instance {
    readonly Dependencies: QueryTranslationPostprocessorDependencies;
    readonly QueryCompilationContext: QueryCompilationContext;
    Process(query: Expression): Expression;
}


export const QueryTranslationPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryTranslationPostprocessor;
};


export type QueryTranslationPostprocessor = QueryTranslationPostprocessor$instance;

export interface QueryTranslationPostprocessorDependencies$instance {
    _Clone_$(): QueryTranslationPostprocessorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QueryTranslationPostprocessorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryTranslationPostprocessorDependencies: {
    new(): QueryTranslationPostprocessorDependencies;
};


export type QueryTranslationPostprocessorDependencies = QueryTranslationPostprocessorDependencies$instance;

export interface QueryTranslationPreprocessor$instance {
    readonly Dependencies: QueryTranslationPreprocessorDependencies;
    readonly IsEfConstantSupported: boolean;
    readonly QueryCompilationContext: QueryCompilationContext;
    NormalizeQueryableMethod(expression: Expression): Expression;
    Process(query: Expression): Expression;
    ProcessQueryRoots(expression: Expression): Expression;
}


export const QueryTranslationPreprocessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): QueryTranslationPreprocessor;
};


export type QueryTranslationPreprocessor = QueryTranslationPreprocessor$instance;

export interface QueryTranslationPreprocessorDependencies$instance {
    EvaluatableExpressionFilter: IEvaluatableExpressionFilter;
    NavigationExpansionExtensibilityHelper: INavigationExpansionExtensibilityHelper;
    TypeMappingSource: ITypeMappingSource;
    _Clone_$(): QueryTranslationPreprocessorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: QueryTranslationPreprocessorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const QueryTranslationPreprocessorDependencies: {
    new(typeMappingSource: ITypeMappingSource, evaluatableExpressionFilter: IEvaluatableExpressionFilter, navigationExpansionExtensibilityHelper: INavigationExpansionExtensibilityHelper): QueryTranslationPreprocessorDependencies;
};


export type QueryTranslationPreprocessorDependencies = QueryTranslationPreprocessorDependencies$instance;

export interface RelationalAggregateMethodCallTranslatorProvider$instance {
    readonly Dependencies: RelationalAggregateMethodCallTranslatorProviderDependencies;
    AddTranslators(translators: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslator>): void;
    Translate(model: IModel, method: MethodInfo, source: EnumerableExpression, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalAggregateMethodCallTranslatorProvider: {
    new(dependencies: RelationalAggregateMethodCallTranslatorProviderDependencies): RelationalAggregateMethodCallTranslatorProvider;
};


export interface __RelationalAggregateMethodCallTranslatorProvider$views {
    As_IAggregateMethodCallTranslatorProvider(): IAggregateMethodCallTranslatorProvider$instance;
}

export interface RelationalAggregateMethodCallTranslatorProvider$instance extends IAggregateMethodCallTranslatorProvider$instance {}

export type RelationalAggregateMethodCallTranslatorProvider = RelationalAggregateMethodCallTranslatorProvider$instance & __RelationalAggregateMethodCallTranslatorProvider$views;


export interface RelationalAggregateMethodCallTranslatorProviderDependencies$instance {
    Plugins: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslatorPlugin>;
    RelationalTypeMappingSource: IRelationalTypeMappingSource;
    SqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalAggregateMethodCallTranslatorProviderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalAggregateMethodCallTranslatorProviderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalAggregateMethodCallTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IAggregateMethodCallTranslatorPlugin>, typeMappingSource: IRelationalTypeMappingSource): RelationalAggregateMethodCallTranslatorProviderDependencies;
};


export type RelationalAggregateMethodCallTranslatorProviderDependencies = RelationalAggregateMethodCallTranslatorProviderDependencies$instance;

export interface RelationalCollectionShaperExpression$instance extends Expression {
    readonly ElementType: Type;
    readonly InnerShaper: Expression;
    readonly Navigation: INavigationBase | undefined;
    readonly NodeType: ExpressionType;
    readonly OuterIdentifier: Expression;
    readonly OuterIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly ParentIdentifier: Expression;
    readonly ParentIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly SelfIdentifier: Expression;
    readonly SelfIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly Type: Type;
    Update(parentIdentifier: Expression, outerIdentifier: Expression, selfIdentifier: Expression, innerShaper: Expression): RelationalCollectionShaperExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const RelationalCollectionShaperExpression: {
    new(parentIdentifier: Expression, outerIdentifier: Expression, selfIdentifier: Expression, parentIdentifierValueComparers: IReadOnlyList<ValueComparer>, outerIdentifierValueComparers: IReadOnlyList<ValueComparer>, selfIdentifierValueComparers: IReadOnlyList<ValueComparer>, innerShaper: Expression, navigation: INavigationBase, elementType: Type): RelationalCollectionShaperExpression;
};


export interface __RelationalCollectionShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalCollectionShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalCollectionShaperExpression = RelationalCollectionShaperExpression$instance & __RelationalCollectionShaperExpression$views;


export interface RelationalCompiledQueryCacheKeyGenerator$instance extends CompiledQueryCacheKeyGenerator$instance {
    readonly RelationalDependencies: RelationalCompiledQueryCacheKeyGeneratorDependencies;
    GenerateCacheKey(query: Expression, async: boolean): unknown;
}


export const RelationalCompiledQueryCacheKeyGenerator: {
    new(dependencies: CompiledQueryCacheKeyGeneratorDependencies, relationalDependencies: RelationalCompiledQueryCacheKeyGeneratorDependencies): RelationalCompiledQueryCacheKeyGenerator;
};


export interface __RelationalCompiledQueryCacheKeyGenerator$views {
    As_ICompiledQueryCacheKeyGenerator(): ICompiledQueryCacheKeyGenerator$instance;
}

export type RelationalCompiledQueryCacheKeyGenerator = RelationalCompiledQueryCacheKeyGenerator$instance & __RelationalCompiledQueryCacheKeyGenerator$views;


export interface RelationalCompiledQueryCacheKeyGeneratorDependencies$instance {
    ContextOptions: IDbContextOptions;
    _Clone_$(): RelationalCompiledQueryCacheKeyGeneratorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalCompiledQueryCacheKeyGeneratorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalCompiledQueryCacheKeyGeneratorDependencies: {
    new(contextOptions: IDbContextOptions): RelationalCompiledQueryCacheKeyGeneratorDependencies;
};


export type RelationalCompiledQueryCacheKeyGeneratorDependencies = RelationalCompiledQueryCacheKeyGeneratorDependencies$instance;

export interface RelationalEvaluatableExpressionFilter$instance extends EvaluatableExpressionFilter$instance {
    readonly RelationalDependencies: RelationalEvaluatableExpressionFilterDependencies;
    IsEvaluatableExpression(expression: Expression, model: IModel): boolean;
}


export const RelationalEvaluatableExpressionFilter: {
    new(dependencies: EvaluatableExpressionFilterDependencies, relationalDependencies: RelationalEvaluatableExpressionFilterDependencies): RelationalEvaluatableExpressionFilter;
};


export interface __RelationalEvaluatableExpressionFilter$views {
    As_IEvaluatableExpressionFilter(): IEvaluatableExpressionFilter$instance;
}

export type RelationalEvaluatableExpressionFilter = RelationalEvaluatableExpressionFilter$instance & __RelationalEvaluatableExpressionFilter$views;


export interface RelationalEvaluatableExpressionFilterDependencies$instance {
    _Clone_$(): RelationalEvaluatableExpressionFilterDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalEvaluatableExpressionFilterDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalEvaluatableExpressionFilterDependencies: {
    new(): RelationalEvaluatableExpressionFilterDependencies;
};


export type RelationalEvaluatableExpressionFilterDependencies = RelationalEvaluatableExpressionFilterDependencies$instance;

export interface RelationalGroupByResultExpression$instance extends Expression {
    readonly ElementShaper: Expression;
    readonly KeyIdentifier: Expression;
    readonly KeyIdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly KeyShaper: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Update(keyIdentifier: Expression, keyShaper: Expression, elementShaper: Expression): RelationalGroupByResultExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const RelationalGroupByResultExpression: {
    new(keyIdentifier: Expression, keyIdentifierValueComparers: IReadOnlyList<ValueComparer>, keyShaper: Expression, elementShaper: Expression): RelationalGroupByResultExpression;
};


export interface __RelationalGroupByResultExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalGroupByResultExpression$instance extends IPrintableExpression$instance {}

export type RelationalGroupByResultExpression = RelationalGroupByResultExpression$instance & __RelationalGroupByResultExpression$views;


export interface RelationalGroupByShaperExpression$instance extends GroupByShaperExpression$instance {
    readonly ElementSelector: Expression;
    Print(expressionPrinter: ExpressionPrinter): void;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const RelationalGroupByShaperExpression: {
    new(keySelector: Expression, elementSelector: Expression, groupingEnumerable: ShapedQueryExpression): RelationalGroupByShaperExpression;
};


export interface __RelationalGroupByShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export type RelationalGroupByShaperExpression = RelationalGroupByShaperExpression$instance & __RelationalGroupByShaperExpression$views;


export interface RelationalLiftableConstantExpressionDependencies$instance {
    _Clone_$(): RelationalLiftableConstantExpressionDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalLiftableConstantExpressionDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalLiftableConstantExpressionDependencies: {
    new(): RelationalLiftableConstantExpressionDependencies;
};


export type RelationalLiftableConstantExpressionDependencies = RelationalLiftableConstantExpressionDependencies$instance;

export interface RelationalLiftableConstantFactory$instance extends LiftableConstantFactory$instance {
    readonly RelationalDependencies: RelationalLiftableConstantExpressionDependencies;
    CreateLiftableConstant(originalValue: unknown, resolverExpression: Expression<Func<MaterializerLiftableConstantContext, unknown>>, variableName: string, type: Type): Expression;
}


export const RelationalLiftableConstantFactory: {
    new(dependencies: LiftableConstantExpressionDependencies, relationalDependencies: RelationalLiftableConstantExpressionDependencies): RelationalLiftableConstantFactory;
};


export interface __RelationalLiftableConstantFactory$views {
    As_ILiftableConstantFactory(): ILiftableConstantFactory$instance;
    As_IRelationalLiftableConstantFactory(): IRelationalLiftableConstantFactory$instance;
}

export type RelationalLiftableConstantFactory = RelationalLiftableConstantFactory$instance & __RelationalLiftableConstantFactory$views;


export interface RelationalLiftableConstantProcessor$instance extends LiftableConstantProcessor$instance {
    InlineConstant(liftableConstant: LiftableConstantExpression): ConstantExpression;
    InlineConstants(expression: Expression, supportsPrecompiledQuery: boolean): Expression;
    LiftConstants(expression: Expression, contextParameter: ParameterExpression, variableNames: HashSet<System_Internal.String>): Expression;
}


export const RelationalLiftableConstantProcessor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies, relationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, commandBuilderDependencies: RelationalCommandBuilderDependencies): RelationalLiftableConstantProcessor;
};


export interface __RelationalLiftableConstantProcessor$views {
    As_ILiftableConstantProcessor(): ILiftableConstantProcessor$instance;
}

export type RelationalLiftableConstantProcessor = RelationalLiftableConstantProcessor$instance & __RelationalLiftableConstantProcessor$views;


export interface RelationalMaterializerLiftableConstantContext$instance extends MaterializerLiftableConstantContext {
    CommandBuilderDependencies: RelationalCommandBuilderDependencies;
    readonly EqualityContract: Type;
    RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies;
    _Clone_$(): RelationalMaterializerLiftableConstantContext;
    _Clone_$(): MaterializerLiftableConstantContext;
    Deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies, RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, CommandBuilderDependencies: RelationalCommandBuilderDependencies): void;
    Deconstruct(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies): void;
    Equals(obj: unknown): boolean;
    Equals(other: MaterializerLiftableConstantContext): boolean;
    Equals(other: RelationalMaterializerLiftableConstantContext): boolean;
    GetHashCode(): int;
    PrintMembers(builder: StringBuilder): boolean;
    ToString(): string;
}


export const RelationalMaterializerLiftableConstantContext: {
    new(Dependencies: ShapedQueryCompilingExpressionVisitorDependencies, RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, CommandBuilderDependencies: RelationalCommandBuilderDependencies): RelationalMaterializerLiftableConstantContext;
};


export type RelationalMaterializerLiftableConstantContext = RelationalMaterializerLiftableConstantContext$instance;

export interface RelationalMemberTranslatorProvider$instance {
    readonly Dependencies: RelationalMemberTranslatorProviderDependencies;
    AddTranslators(translators: IEnumerable__System_Collections_Generic<IMemberTranslator>): void;
    Translate(instance: SqlExpression, member: MemberInfo, returnType: Type, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalMemberTranslatorProvider: {
    new(dependencies: RelationalMemberTranslatorProviderDependencies): RelationalMemberTranslatorProvider;
};


export interface __RelationalMemberTranslatorProvider$views {
    As_IMemberTranslatorProvider(): IMemberTranslatorProvider$instance;
}

export interface RelationalMemberTranslatorProvider$instance extends IMemberTranslatorProvider$instance {}

export type RelationalMemberTranslatorProvider = RelationalMemberTranslatorProvider$instance & __RelationalMemberTranslatorProvider$views;


export interface RelationalMemberTranslatorProviderDependencies$instance {
    Plugins: IEnumerable__System_Collections_Generic<IMemberTranslatorPlugin>;
    SqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalMemberTranslatorProviderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalMemberTranslatorProviderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalMemberTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IMemberTranslatorPlugin>): RelationalMemberTranslatorProviderDependencies;
};


export type RelationalMemberTranslatorProviderDependencies = RelationalMemberTranslatorProviderDependencies$instance;

export interface RelationalMethodCallTranslatorProvider$instance {
    readonly Dependencies: RelationalMethodCallTranslatorProviderDependencies;
    AddTranslators(translators: IEnumerable__System_Collections_Generic<IMethodCallTranslator>): void;
    Translate(model: IModel, instance: SqlExpression, method: MethodInfo, arguments: IReadOnlyList<SqlExpression>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Query>): SqlExpression | undefined;
}


export const RelationalMethodCallTranslatorProvider: {
    new(dependencies: RelationalMethodCallTranslatorProviderDependencies): RelationalMethodCallTranslatorProvider;
};


export interface __RelationalMethodCallTranslatorProvider$views {
    As_IMethodCallTranslatorProvider(): IMethodCallTranslatorProvider$instance;
}

export interface RelationalMethodCallTranslatorProvider$instance extends IMethodCallTranslatorProvider$instance {}

export type RelationalMethodCallTranslatorProvider = RelationalMethodCallTranslatorProvider$instance & __RelationalMethodCallTranslatorProvider$views;


export interface RelationalMethodCallTranslatorProviderDependencies$instance {
    Plugins: IEnumerable__System_Collections_Generic<IMethodCallTranslatorPlugin>;
    RelationalTypeMappingSource: IRelationalTypeMappingSource;
    SqlExpressionFactory: ISqlExpressionFactory;
    _Clone_$(): RelationalMethodCallTranslatorProviderDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalMethodCallTranslatorProviderDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalMethodCallTranslatorProviderDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, plugins: IEnumerable__System_Collections_Generic<IMethodCallTranslatorPlugin>, typeMappingSource: IRelationalTypeMappingSource): RelationalMethodCallTranslatorProviderDependencies;
};


export type RelationalMethodCallTranslatorProviderDependencies = RelationalMethodCallTranslatorProviderDependencies$instance;

export interface RelationalParameterBasedSqlProcessor$instance {
    readonly Dependencies: RelationalParameterBasedSqlProcessorDependencies;
    readonly Parameters: RelationalParameterBasedSqlProcessorParameters;
    ExpandFromSqlParameter(queryExpression: Expression, Decorator: ParametersCacheDecorator): Expression;
    Optimize(queryExpression: Expression, parametersValues: IReadOnlyDictionary<System_Internal.String, unknown>, canCache: boolean): Expression;
    Process(queryExpression: Expression, parameters: Dictionary<System_Internal.String, unknown>, canCache: boolean): Expression;
    Process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
    ProcessSqlNullability(queryExpression: Expression, Decorator: ParametersCacheDecorator): Expression;
}


export const RelationalParameterBasedSqlProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters): RelationalParameterBasedSqlProcessor;
};


export type RelationalParameterBasedSqlProcessor = RelationalParameterBasedSqlProcessor$instance;

export interface RelationalParameterBasedSqlProcessorDependencies$instance {
    ParameterNameGeneratorFactory: IParameterNameGeneratorFactory;
    SqlExpressionFactory: ISqlExpressionFactory;
    SqlGenerationHelper: ISqlGenerationHelper;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalParameterBasedSqlProcessorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalParameterBasedSqlProcessorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalParameterBasedSqlProcessorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource, sqlGenerationHelper: ISqlGenerationHelper, parameterNameGeneratorFactory: IParameterNameGeneratorFactory): RelationalParameterBasedSqlProcessorDependencies;
};


export type RelationalParameterBasedSqlProcessorDependencies = RelationalParameterBasedSqlProcessorDependencies$instance;

export interface RelationalParameterBasedSqlProcessorParameters$instance {
    CollectionParameterTranslationMode: ParameterTranslationMode;
    UseRelationalNulls: boolean;
    _Clone_$(): RelationalParameterBasedSqlProcessorParameters;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalParameterBasedSqlProcessorParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalParameterBasedSqlProcessorParameters: {
    new(useRelationalNulls: boolean, collectionParameterTranslationMode: ParameterTranslationMode): RelationalParameterBasedSqlProcessorParameters;
};


export type RelationalParameterBasedSqlProcessorParameters = RelationalParameterBasedSqlProcessorParameters$instance;

export interface RelationalQueryableMethodTranslatingExpressionVisitor$instance extends QueryableMethodTranslatingExpressionVisitor {
    readonly RelationalDependencies: RelationalQueryableMethodTranslatingExpressionVisitorDependencies;
    CreateSelect(entityType: IEntityType): SelectExpression;
    CreateSelect(jsonQueryExpression: JsonQueryExpression, tableExpressionBase: TableExpressionBase, identifierColumnName: string, identifierColumnType: Type, identifierColumnTypeMapping: RelationalTypeMapping): SelectExpression;
    CreateShapedQueryExpression(entityType: IEntityType): ShapedQueryExpression;
    CreateSubqueryVisitor(): QueryableMethodTranslatingExpressionVisitor;
    GenerateJsonPartialUpdateSetter(target: Expression, value: SqlExpression, existingSetterValue: SqlExpression): SqlExpression | undefined;
    IsNaturallyOrdered(selectExpression: SelectExpression): boolean;
    IsOrdered(selectExpression: SelectExpression): boolean;
    IsValidSelectExpressionForExecuteDelete(selectExpression: SelectExpression): boolean;
    IsValidSelectExpressionForExecuteDelete(selectExpression: SelectExpression, shaper: StructuralTypeShaperExpression, tableExpression: TableExpression): boolean;
    IsValidSelectExpressionForExecuteUpdate(selectExpression: SelectExpression, targetTable: TableExpressionBase, tableExpression: TableExpression): boolean;
    TransformJsonQueryToTable(jsonQueryExpression: JsonQueryExpression): ShapedQueryExpression | undefined;
    TranslateAll(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateAny(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateAverage(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateCast(source: ShapedQueryExpression, resultType: Type): ShapedQueryExpression;
    TranslateConcat(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression;
    TranslateContains(source: ShapedQueryExpression, item: Expression): ShapedQueryExpression | undefined;
    TranslateCount(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateDefaultIfEmpty(source: ShapedQueryExpression, defaultValue: Expression): ShapedQueryExpression | undefined;
    TranslateDistinct(source: ShapedQueryExpression): ShapedQueryExpression;
    TranslateElementAtOrDefault(source: ShapedQueryExpression, index: Expression, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateExcept(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression;
    TranslateExecuteDelete(source: ShapedQueryExpression): DeleteExpression | undefined;
    TranslateExecuteDelete(source: ShapedQueryExpression): Expression | undefined;
    TranslateExecuteUpdate(source: ShapedQueryExpression, setters: IReadOnlyList<QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter>): UpdateExpression | undefined;
    TranslateExecuteUpdate(source: ShapedQueryExpression, setters: IReadOnlyList<QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter>): Expression | undefined;
    TranslateExpression(expression: Expression, applyDefaultTypeMapping?: boolean): SqlExpression | undefined;
    TranslateFirstOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateGroupBy(source: ShapedQueryExpression, keySelector: LambdaExpression, elementSelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateGroupJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateInlineQueryRoot(inlineQueryRootExpression: InlineQueryRootExpression): ShapedQueryExpression | undefined;
    TranslateIntersect(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression;
    TranslateJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateLambdaExpression(shapedQueryExpression: ShapedQueryExpression, lambdaExpression: LambdaExpression): SqlExpression | undefined;
    TranslateLastOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateLeftJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateLongCount(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateMax(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateMemberAccess(source: Expression, member: MemberIdentity): ShapedQueryExpression | undefined;
    TranslateMin(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateOfType(source: ShapedQueryExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateOrderBy(source: ShapedQueryExpression, keySelector: LambdaExpression, ascending: boolean): ShapedQueryExpression | undefined;
    TranslateParameterQueryRoot(parameterQueryRootExpression: ParameterQueryRootExpression): ShapedQueryExpression | undefined;
    TranslatePrimitiveCollection(sqlExpression: SqlExpression, property: IProperty, tableAlias: string): ShapedQueryExpression | undefined;
    TranslateReverse(source: ShapedQueryExpression): ShapedQueryExpression | undefined;
    TranslateRightJoin(outer: ShapedQueryExpression, inner: ShapedQueryExpression, outerKeySelector: LambdaExpression, innerKeySelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSelect(source: ShapedQueryExpression, selector: LambdaExpression): ShapedQueryExpression;
    TranslateSelectMany(source: ShapedQueryExpression, collectionSelector: LambdaExpression, resultSelector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSelectMany(source: ShapedQueryExpression, selector: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSingleOrDefault(source: ShapedQueryExpression, predicate: LambdaExpression, returnType: Type, returnDefault: boolean): ShapedQueryExpression | undefined;
    TranslateSkip(source: ShapedQueryExpression, count: Expression): ShapedQueryExpression | undefined;
    TranslateSkipWhile(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateSum(source: ShapedQueryExpression, selector: LambdaExpression, resultType: Type): ShapedQueryExpression | undefined;
    TranslateTake(source: ShapedQueryExpression, count: Expression): ShapedQueryExpression | undefined;
    TranslateTakeWhile(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TranslateThenBy(source: ShapedQueryExpression, keySelector: LambdaExpression, ascending: boolean): ShapedQueryExpression | undefined;
    TranslateUnion(source1: ShapedQueryExpression, source2: ShapedQueryExpression): ShapedQueryExpression;
    TranslateWhere(source: ShapedQueryExpression, predicate: LambdaExpression): ShapedQueryExpression | undefined;
    TrySerializeScalarToJson(target: JsonScalarExpression, value: SqlExpression, jsonValue: SqlExpression): boolean;
    TryTranslateSetters(source: ShapedQueryExpression, setters: IReadOnlyList<QueryableMethodTranslatingExpressionVisitor_ExecuteUpdateSetter>, columnSetters: IReadOnlyList<ColumnValueSetter>, targetTable: TableExpressionBase): boolean;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const RelationalQueryableMethodTranslatingExpressionVisitor: {
    new(dependencies: QueryableMethodTranslatingExpressionVisitorDependencies, relationalDependencies: RelationalQueryableMethodTranslatingExpressionVisitorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalQueryableMethodTranslatingExpressionVisitor;
    readonly ValuesOrderingColumnName: string;
    readonly ValuesValueColumnName: string;
};


export type RelationalQueryableMethodTranslatingExpressionVisitor = RelationalQueryableMethodTranslatingExpressionVisitor$instance;

export interface RelationalQueryableMethodTranslatingExpressionVisitorDependencies$instance {
    Model: IModel;
    RelationalSqlTranslatingExpressionVisitorFactory: IRelationalSqlTranslatingExpressionVisitorFactory;
    SqlExpressionFactory: ISqlExpressionFactory;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryableMethodTranslatingExpressionVisitorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalQueryableMethodTranslatingExpressionVisitorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalQueryableMethodTranslatingExpressionVisitorDependencies: {
    new(relationalSqlTranslatingExpressionVisitorFactory: IRelationalSqlTranslatingExpressionVisitorFactory, sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource, model: IModel): RelationalQueryableMethodTranslatingExpressionVisitorDependencies;
};


export type RelationalQueryableMethodTranslatingExpressionVisitorDependencies = RelationalQueryableMethodTranslatingExpressionVisitorDependencies$instance;

export interface RelationalQueryCompilationContext$instance extends QueryCompilationContext {
    QuerySplittingBehavior: Nullable<QuerySplittingBehavior>;
    readonly RelationalDependencies: RelationalQueryCompilationContextDependencies;
    readonly SqlAliasManager: SqlAliasManager;
}


export const RelationalQueryCompilationContext: {
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async: boolean): RelationalQueryCompilationContext;
    new(dependencies: QueryCompilationContextDependencies, relationalDependencies: RelationalQueryCompilationContextDependencies, async: boolean, precompiling: boolean): RelationalQueryCompilationContext;
};


export type RelationalQueryCompilationContext = RelationalQueryCompilationContext$instance;

export interface RelationalQueryCompilationContextDependencies$instance {
    SqlAliasManagerFactory: ISqlAliasManagerFactory;
    _Clone_$(): RelationalQueryCompilationContextDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalQueryCompilationContextDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalQueryCompilationContextDependencies: {
    new(sqlAliasManagerFactory: ISqlAliasManagerFactory): RelationalQueryCompilationContextDependencies;
};


export type RelationalQueryCompilationContextDependencies = RelationalQueryCompilationContextDependencies$instance;

export interface RelationalQueryContext$instance extends QueryContext {
    readonly CommandLogger: IDiagnosticsLogger_1<DbLoggerCategory_Database_Command> | IRelationalCommandDiagnosticsLogger;
    readonly Connection: IRelationalConnection;
    readonly RelationalDependencies: RelationalQueryContextDependencies;
    readonly RelationalQueryStringFactory: IRelationalQueryStringFactory;
}


export const RelationalQueryContext: {
    new(dependencies: QueryContextDependencies, relationalDependencies: RelationalQueryContextDependencies): RelationalQueryContext;
};


export type RelationalQueryContext = RelationalQueryContext$instance;

export interface RelationalQueryContextDependencies$instance {
    RelationalConnection: IRelationalConnection;
    RelationalQueryStringFactory: IRelationalQueryStringFactory;
    _Clone_$(): RelationalQueryContextDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalQueryContextDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalQueryContextDependencies: {
    new(relationalConnection: IRelationalConnection, relationalQueryStringFactory: IRelationalQueryStringFactory): RelationalQueryContextDependencies;
};


export type RelationalQueryContextDependencies = RelationalQueryContextDependencies$instance;

export interface RelationalQueryRootProcessor$instance extends QueryRootProcessor {
    ShouldConvertToInlineQueryRoot(expression: Expression): boolean;
    ShouldConvertToParameterQueryRoot(queryParameterExpression: QueryParameterExpression): boolean;
    VisitExtension(node: Expression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const RelationalQueryRootProcessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, relationalDependencies: RelationalQueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): RelationalQueryRootProcessor;
};


export type RelationalQueryRootProcessor = RelationalQueryRootProcessor$instance;

export interface RelationalQueryTranslationPostprocessor$instance extends QueryTranslationPostprocessor {
    readonly RelationalDependencies: RelationalQueryTranslationPostprocessorDependencies;
    readonly RelationalQueryCompilationContext: RelationalQueryCompilationContext;
    Process(query: Expression): Expression;
    ProcessTypeMappings(expression: Expression): Expression;
    Prune(query: Expression): Expression;
}


export const RelationalQueryTranslationPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalQueryTranslationPostprocessor;
};


export type RelationalQueryTranslationPostprocessor = RelationalQueryTranslationPostprocessor$instance;

export interface RelationalQueryTranslationPostprocessorDependencies$instance {
    SqlExpressionFactory: ISqlExpressionFactory;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryTranslationPostprocessorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalQueryTranslationPostprocessorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalQueryTranslationPostprocessorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, typeMappingSource: IRelationalTypeMappingSource): RelationalQueryTranslationPostprocessorDependencies;
};


export type RelationalQueryTranslationPostprocessorDependencies = RelationalQueryTranslationPostprocessorDependencies$instance;

export interface RelationalQueryTranslationPreprocessor$instance extends QueryTranslationPreprocessor {
    readonly IsEfConstantSupported: boolean;
    readonly RelationalDependencies: RelationalQueryTranslationPreprocessorDependencies;
    NormalizeQueryableMethod(expression: Expression): Expression;
    ProcessQueryRoots(expression: Expression): Expression;
}


export const RelationalQueryTranslationPreprocessor: {
    new(dependencies: QueryTranslationPreprocessorDependencies, relationalDependencies: RelationalQueryTranslationPreprocessorDependencies, queryCompilationContext: QueryCompilationContext): RelationalQueryTranslationPreprocessor;
};


export type RelationalQueryTranslationPreprocessor = RelationalQueryTranslationPreprocessor$instance;

export interface RelationalQueryTranslationPreprocessorDependencies$instance {
    RelationalTypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalQueryTranslationPreprocessorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalQueryTranslationPreprocessorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalQueryTranslationPreprocessorDependencies: {
    new(relationalTypeMappingSource: IRelationalTypeMappingSource): RelationalQueryTranslationPreprocessorDependencies;
};


export type RelationalQueryTranslationPreprocessorDependencies = RelationalQueryTranslationPreprocessorDependencies$instance;

export interface RelationalShapedQueryCompilingExpressionVisitor$instance extends ShapedQueryCompilingExpressionVisitor {
    readonly MaxNullableParametersForPregeneratedSql: int;
    readonly RelationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies;
    AddStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
    AddStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitShapedQuery(shapedQueryExpression: ShapedQueryExpression): Expression;
}


export const RelationalShapedQueryCompilingExpressionVisitor: {
    new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies, relationalDependencies: RelationalShapedQueryCompilingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext): RelationalShapedQueryCompilingExpressionVisitor;
    NonQueryResult(relationalQueryContext: RelationalQueryContext, relationalCommandResolver: RelationalCommandResolver, contextType: Type, commandSource: CommandSource, threadSafetyChecksEnabled: boolean): int;
    NonQueryResultAsync(relationalQueryContext: RelationalQueryContext, relationalCommandResolver: RelationalCommandResolver, contextType: Type, commandSource: CommandSource, threadSafetyChecksEnabled: boolean): Task<System_Internal.Int32>;
};


export type RelationalShapedQueryCompilingExpressionVisitor = RelationalShapedQueryCompilingExpressionVisitor$instance;

export interface RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor$instance extends ExpressionVisitor {
    ProcessRelationalGroupingResult(relationalGroupByResultExpression: RelationalGroupByResultExpression, relationalCommandResolver: Expression, readerColumns: IReadOnlyList<ReaderColumn>, keySelector: LambdaExpression, keyIdentifier: LambdaExpression, relatedDataLoaders: LambdaExpression, collectionId: int): LambdaExpression;
    ProcessShaper(shaperExpression: Expression, relationalCommandResolver: Expression, readerColumns: IReadOnlyList<ReaderColumn>, relatedDataLoaders: LambdaExpression, collectionId: int): LambdaExpression;
    VisitBinary(binaryExpression: BinaryExpression): Expression;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor: {
    new(parentVisitor: RelationalShapedQueryCompilingExpressionVisitor, selectExpression: SelectExpression, tags: ISet<System_Internal.String>, splitQuery: boolean, indexMap: boolean): RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor;
    readonly GetFieldValueMethod: MethodInfo;
    Any(source: IEnumerable): boolean;
    IncludeJsonEntityCollection<TIncludingEntity, TIncludedCollectionElement>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, entity: TIncludingEntity, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TIncludedCollectionElement>, getOrCreateCollectionObject: Action<TIncludingEntity>, fixup: Action<TIncludingEntity, TIncludedCollectionElement>, performFixup: boolean): void;
    IncludeJsonEntityReference<TStructural, TRelatedStructural>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, structuralType: TStructural, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TRelatedStructural>, fixup: Action<TStructural, TRelatedStructural>, performFixup: boolean): void;
    IncludeReference<TEntity, TIncludingEntity extends TEntity, TIncludedEntity>(queryContext: QueryContext, entity: TEntity, relatedEntity: TIncludedEntity, navigation: INavigationBase, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    InitializeCollection<TElement, TCollection extends ICollection<TElement>>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, clrCollectionAccessor: IClrCollectionAccessor): TCollection;
    InitializeIncludeCollection<TParent, TNavigationEntity extends TParent>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, entity: TParent, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, navigation: INavigationBase, clrCollectionAccessor: IClrCollectionAccessor, trackingQuery: boolean, setLoaded: boolean): void;
    InitializeSplitCollection<TElement, TCollection extends ICollection<TElement>>(collectionId: int, queryContext: QueryContext, parentDataReader: DbDataReader, resultCoordinator: SplitQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, clrCollectionAccessor: IClrCollectionAccessor): TCollection;
    InitializeSplitIncludeCollection<TParent, TNavigationEntity extends TParent>(collectionId: int, queryContext: QueryContext, parentDataReader: DbDataReader, resultCoordinator: SplitQueryResultCoordinator, entity: TParent, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, navigation: INavigationBase, clrCollectionAccessor: IClrCollectionAccessor, trackingQuery: boolean, setLoaded: boolean): void;
    InverseCollectionFixup<TCollectionElement, TEntity>(collection: ICollection<TCollectionElement>, entity: TEntity, elementFixup: Action<TCollectionElement, TEntity>): void;
    MaterializeJsonEntityCollection<TEntity, TResult>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, structuralProperty: IPropertyBase, innerShaper: Func<QueryContext, unknown[], JsonReaderData, TEntity>): TResult | undefined;
    MaterializeJsonNullableValueStructuralType<TStructural extends unknown>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, nullable: boolean, shaper: Func<QueryContext, unknown[], JsonReaderData, TStructural>): Nullable<TStructural>;
    MaterializeJsonStructuralType<TStructural>(queryContext: QueryContext, keyPropertyValues: unknown[], jsonReaderData: JsonReaderData, nullable: boolean, shaper: Func<QueryContext, unknown[], JsonReaderData, TStructural>): TStructural | undefined;
    PopulateCollection<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, selfIdentifier: Func<QueryContext, DbDataReader, unknown[]>, parentIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, outerIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, selfIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator, TRelatedEntity>): void;
    PopulateIncludeCollection<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: QueryContext, dbDataReader: DbDataReader, resultCoordinator: SingleQueryResultCoordinator, parentIdentifier: Func<QueryContext, DbDataReader, unknown[]>, outerIdentifier: Func<QueryContext, DbDataReader, unknown[]>, selfIdentifier: Func<QueryContext, DbDataReader, unknown[]>, parentIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, outerIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, selfIdentifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator, TIncludedEntity>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    PopulateSplitCollection<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TRelatedEntity>, relatedDataLoaders: Action<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator>): void;
    PopulateSplitCollectionAsync<TCollection extends ICollection<TElement>, TElement, TRelatedEntity extends TElement>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TRelatedEntity>, relatedDataLoaders: Func<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator, Task>): Task;
    PopulateSplitIncludeCollection<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TIncludedEntity>, relatedDataLoaders: Action<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): void;
    PopulateSplitIncludeCollectionAsync<TIncludingEntity, TIncludedEntity>(collectionId: int, queryContext: RelationalQueryContext, executionStrategy: IExecutionStrategy, relationalCommandResolver: RelationalCommandResolver, readerColumns: IReadOnlyList<ReaderColumn>, detailedErrorsEnabled: boolean, resultCoordinator: SplitQueryResultCoordinator, childIdentifier: Func<QueryContext, DbDataReader, unknown[]>, identifierValueComparers: IReadOnlyList<Func<unknown, unknown, System_Internal.Boolean>>, innerShaper: Func<QueryContext, DbDataReader, ResultContext, SplitQueryResultCoordinator, TIncludedEntity>, relatedDataLoaders: Func<QueryContext, IExecutionStrategy, SplitQueryResultCoordinator, Task>, inverseNavigation: INavigationBase, fixup: Action<TIncludingEntity, TIncludedEntity>, trackingQuery: boolean): Task;
    TaskAwaiter(taskFactories: Func<Task>[]): Task;
    ThrowReadValueException<TValue>(exception: Exception, value: unknown, expectedType: Type, property?: IPropertyBase): TValue;
};


export type RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor = RelationalShapedQueryCompilingExpressionVisitor_ShaperProcessingExpressionVisitor$instance;

export interface RelationalShapedQueryCompilingExpressionVisitorDependencies$instance {
    QuerySqlGeneratorFactory: IQuerySqlGeneratorFactory;
    RelationalLiftableConstantFactory: IRelationalLiftableConstantFactory;
    RelationalParameterBasedSqlProcessorFactory: IRelationalParameterBasedSqlProcessorFactory;
    _Clone_$(): RelationalShapedQueryCompilingExpressionVisitorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalShapedQueryCompilingExpressionVisitorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalShapedQueryCompilingExpressionVisitorDependencies: {
    new(querySqlGeneratorFactory: IQuerySqlGeneratorFactory, relationalParameterBasedSqlProcessorFactory: IRelationalParameterBasedSqlProcessorFactory, relationalLiftableConstantFactory: IRelationalLiftableConstantFactory): RelationalShapedQueryCompilingExpressionVisitorDependencies;
};


export type RelationalShapedQueryCompilingExpressionVisitorDependencies = RelationalShapedQueryCompilingExpressionVisitorDependencies$instance;

export interface RelationalSplitCollectionShaperExpression$instance extends Expression {
    readonly ChildIdentifier: Expression;
    readonly ElementType: Type;
    readonly IdentifierValueComparers: IReadOnlyList<ValueComparer>;
    readonly InnerShaper: Expression;
    readonly Navigation: INavigationBase | undefined;
    readonly NodeType: ExpressionType;
    readonly ParentIdentifier: Expression;
    readonly SelectExpression: SelectExpression;
    readonly Type: Type;
    Update(parentIdentifier: Expression, childIdentifier: Expression, selectExpression: SelectExpression, innerShaper: Expression): RelationalSplitCollectionShaperExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const RelationalSplitCollectionShaperExpression: {
    new(parentIdentifier: Expression, childIdentifier: Expression, identifierValueComparers: IReadOnlyList<ValueComparer>, selectExpression: SelectExpression, innerShaper: Expression, navigation: INavigationBase, elementType: Type): RelationalSplitCollectionShaperExpression;
};


export interface __RelationalSplitCollectionShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalSplitCollectionShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalSplitCollectionShaperExpression = RelationalSplitCollectionShaperExpression$instance & __RelationalSplitCollectionShaperExpression$views;


export interface RelationalSqlTranslatingExpressionVisitor$instance extends ExpressionVisitor {
    readonly Dependencies: RelationalSqlTranslatingExpressionVisitorDependencies;
    get TranslationErrorDetails(): string | undefined;
    set TranslationErrorDetails(value: string | undefined);
    AddTranslationErrorDetails(details: string): void;
    GenerateGreatest(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
    GenerateLeast(expressions: IReadOnlyList<SqlExpression>, resultType: Type): SqlExpression | undefined;
    Translate(expression: Expression, applyDefaultTypeMapping?: boolean): SqlExpression | undefined;
    TranslateProjection(expression: Expression, applyDefaultTypeMapping?: boolean): Expression | undefined;
    TryBindMember(source: Expression, member: MemberIdentity, expression: Expression, property: IPropertyBase): boolean;
    TryTranslateAggregateMethodCall(methodCallExpression: MethodCallExpression, translation: SqlExpression): boolean;
    VisitBinary(binaryExpression: BinaryExpression): Expression;
    VisitConditional(conditionalExpression: ConditionalExpression): Expression;
    VisitConstant(constantExpression: ConstantExpression): Expression;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitInvocation(invocationExpression: InvocationExpression): Expression;
    VisitLambda<T>(lambdaExpression: Expression<T>): Expression;
    VisitListInit(listInitExpression: ListInitExpression): Expression;
    VisitMember(memberExpression: MemberExpression): Expression;
    VisitMemberInit(memberInitExpression: MemberInitExpression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
    VisitNew(newExpression: NewExpression): Expression;
    VisitNewArray(newArrayExpression: NewArrayExpression): Expression;
    VisitParameter(parameterExpression: ParameterExpression): Expression;
    VisitTypeBinary(typeBinaryExpression: TypeBinaryExpression): Expression;
    VisitUnary(unaryExpression: UnaryExpression): Expression;
}


export const RelationalSqlTranslatingExpressionVisitor: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
    ParameterListValueExtractor<TEntity, TProperty>(context: QueryContext, baseParameterName: string, property: IProperty): List<TProperty | undefined> | undefined;
    ParameterValueExtractor<T>(context: QueryContext, baseParameterName: string, complexPropertyChain: List<IComplexProperty>, property: IProperty): T | undefined;
};


export type RelationalSqlTranslatingExpressionVisitor = RelationalSqlTranslatingExpressionVisitor$instance;

export interface RelationalSqlTranslatingExpressionVisitorDependencies$instance {
    readonly AggregateMethodCallTranslatorProvider: IAggregateMethodCallTranslatorProvider;
    MemberTranslatorProvider: IMemberTranslatorProvider;
    MethodCallTranslatorProvider: IMethodCallTranslatorProvider;
    Model: IModel;
    SqlExpressionFactory: ISqlExpressionFactory;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): RelationalSqlTranslatingExpressionVisitorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: RelationalSqlTranslatingExpressionVisitorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RelationalSqlTranslatingExpressionVisitorDependencies: {
    new(sqlExpressionFactory: ISqlExpressionFactory, model: IModel, typeMappingSource: IRelationalTypeMappingSource, memberTranslatorProvider: IMemberTranslatorProvider, methodCallTranslatorProvider: IMethodCallTranslatorProvider, aggregateMethodCallTranslatorProvider: IAggregateMethodCallTranslatorProvider): RelationalSqlTranslatingExpressionVisitorDependencies;
};


export type RelationalSqlTranslatingExpressionVisitorDependencies = RelationalSqlTranslatingExpressionVisitorDependencies$instance;

export interface RelationalSqlTranslatingExpressionVisitorFactory$instance {
    readonly Dependencies: RelationalSqlTranslatingExpressionVisitorDependencies;
    Create(queryCompilationContext: QueryCompilationContext, queryableMethodTranslatingExpressionVisitor: QueryableMethodTranslatingExpressionVisitor): RelationalSqlTranslatingExpressionVisitor;
}


export const RelationalSqlTranslatingExpressionVisitorFactory: {
    new(dependencies: RelationalSqlTranslatingExpressionVisitorDependencies): RelationalSqlTranslatingExpressionVisitorFactory;
};


export interface __RelationalSqlTranslatingExpressionVisitorFactory$views {
    As_IRelationalSqlTranslatingExpressionVisitorFactory(): IRelationalSqlTranslatingExpressionVisitorFactory$instance;
}

export interface RelationalSqlTranslatingExpressionVisitorFactory$instance extends IRelationalSqlTranslatingExpressionVisitorFactory$instance {}

export type RelationalSqlTranslatingExpressionVisitorFactory = RelationalSqlTranslatingExpressionVisitorFactory$instance & __RelationalSqlTranslatingExpressionVisitorFactory$views;


export interface RelationalStructuralTypeShaperExpression$instance extends StructuralTypeShaperExpression$instance {
    GenerateMaterializationCondition(type: ITypeBase, nullable: boolean): LambdaExpression;
    MakeClrTypeNonNullable(): StructuralTypeShaperExpression;
    MakeClrTypeNullable(): StructuralTypeShaperExpression;
    MakeNullable(nullable?: boolean): StructuralTypeShaperExpression;
    Print(expressionPrinter: ExpressionPrinter): void;
    Update(valueBufferExpression: Expression): StructuralTypeShaperExpression;
    WithType(type: ITypeBase): StructuralTypeShaperExpression;
}


export const RelationalStructuralTypeShaperExpression: {
    new(structuralType: ITypeBase, valueBufferExpression: Expression, nullable: boolean): RelationalStructuralTypeShaperExpression;
};


export interface __RelationalStructuralTypeShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface RelationalStructuralTypeShaperExpression$instance extends IPrintableExpression$instance {}

export type RelationalStructuralTypeShaperExpression = RelationalStructuralTypeShaperExpression$instance & __RelationalStructuralTypeShaperExpression$views;


export interface RelationalTypeMappingPostprocessor$instance extends ExpressionVisitor {
    readonly Dependencies: QueryTranslationPostprocessorDependencies;
    readonly QueryCompilationContext: RelationalQueryCompilationContext;
    readonly RelationalDependencies: RelationalQueryTranslationPostprocessorDependencies;
    ApplyTypeMappingsOnValuesExpression(valuesExpression: ValuesExpression): ValuesExpression;
    Process(expression: Expression): Expression;
    TryGetInferredTypeMapping(tableAlias: string, columnName: string, inferredTypeMapping: RelationalTypeMapping): boolean;
    VisitExtension(expression: Expression): Expression;
}


export const RelationalTypeMappingPostprocessor: {
    new(dependencies: QueryTranslationPostprocessorDependencies, relationalDependencies: RelationalQueryTranslationPostprocessorDependencies, queryCompilationContext: RelationalQueryCompilationContext): RelationalTypeMappingPostprocessor;
};


export type RelationalTypeMappingPostprocessor = RelationalTypeMappingPostprocessor$instance;

export interface ReplacingExpressionVisitor$instance extends ExpressionVisitor {
    Visit(expression: Expression): Expression | undefined;
    VisitMember(memberExpression: MemberExpression): Expression;
    VisitMethodCall(methodCallExpression: MethodCallExpression): Expression;
}


export const ReplacingExpressionVisitor: {
    new(originals: IReadOnlyList<Expression>, replacements: IReadOnlyList<Expression>): ReplacingExpressionVisitor;
    Replace(originals: IReadOnlyList<Expression>, replacements: IReadOnlyList<Expression>, tree: Expression): Expression;
    Replace(original: Expression, replacement: Expression, tree: Expression): Expression;
};


export type ReplacingExpressionVisitor = ReplacingExpressionVisitor$instance;

export interface ShapedQueryCompilingExpressionVisitor$instance extends ExpressionVisitor {
    readonly Dependencies: ShapedQueryCompilingExpressionVisitorDependencies;
    readonly QueryCompilationContext: QueryCompilationContext;
    AddStructuralTypeInitialization(shaper: StructuralTypeShaperExpression, instanceVariable: ParameterExpression, variables: List<ParameterExpression>, expressions: List<Expression>): void;
    InjectEntityMaterializers(expression: Expression): Expression;
    InjectStructuralTypeMaterializers(expression: Expression): Expression;
    VerifyNoClientConstant(expression: Expression): void;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitShapedQuery(shapedQueryExpression: ShapedQueryExpression): Expression;
}


export const ShapedQueryCompilingExpressionVisitor: (abstract new(dependencies: ShapedQueryCompilingExpressionVisitorDependencies, queryCompilationContext: QueryCompilationContext) => ShapedQueryCompilingExpressionVisitor) & {
    CreateNullKeyValueInNoTrackingQuery(entityType: IEntityType, properties: IReadOnlyList<IProperty>, keyValues: unknown[]): Exception;
    SingleAsync<TSource>(asyncEnumerable: IAsyncEnumerable<TSource>, cancellationToken?: CancellationToken): Task<TSource>;
    SingleOrDefaultAsync<TSource>(asyncEnumerable: IAsyncEnumerable<TSource>, cancellationToken?: CancellationToken): Task<TSource | undefined>;
};


export type ShapedQueryCompilingExpressionVisitor = ShapedQueryCompilingExpressionVisitor$instance;

export interface ShapedQueryCompilingExpressionVisitorDependencies$instance {
    ContextServices: IDbContextServices;
    CoreSingletonOptions: ICoreSingletonOptions;
    EntityMaterializerSource: IStructuralTypeMaterializerSource;
    LiftableConstantFactory: ILiftableConstantFactory;
    MemoryCache: IMemoryCache;
    Model: IModel;
    QueryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>;
    SingletonInterceptors: IEnumerable__System_Collections_Generic<ISingletonInterceptor>;
    TypeMappingSource: ITypeMappingSource;
    _Clone_$(): ShapedQueryCompilingExpressionVisitorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ShapedQueryCompilingExpressionVisitorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ShapedQueryCompilingExpressionVisitorDependencies: {
    new(entityMaterializerSource: IStructuralTypeMaterializerSource, typeMappingSource: ITypeMappingSource, memoryCache: IMemoryCache, coreSingletonOptions: ICoreSingletonOptions, model: IModel, liftableConstantFactory: ILiftableConstantFactory, queryLogger: IDiagnosticsLogger_1<DbLoggerCategory_Query>, singletonInterceptors: IEnumerable__System_Collections_Generic<ISingletonInterceptor>, contextServices: IDbContextServices): ShapedQueryCompilingExpressionVisitorDependencies;
};


export type ShapedQueryCompilingExpressionVisitorDependencies = ShapedQueryCompilingExpressionVisitorDependencies$instance;

export interface ShapedQueryExpression$instance extends Expression {
    readonly NodeType: ExpressionType;
    readonly QueryExpression: Expression;
    readonly ResultCardinality: ResultCardinality;
    readonly ShaperExpression: Expression;
    readonly Type: Type;
    Update(queryExpression: Expression, shaperExpression: Expression): ShapedQueryExpression;
    UpdateQueryExpression(queryExpression: Expression): ShapedQueryExpression;
    UpdateResultCardinality(resultCardinality: ResultCardinality): ShapedQueryExpression;
    UpdateShaperExpression(shaperExpression: Expression): ShapedQueryExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const ShapedQueryExpression: {
    new(queryExpression: Expression, shaperExpression: Expression): ShapedQueryExpression;
};


export interface __ShapedQueryExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface ShapedQueryExpression$instance extends IPrintableExpression$instance {}

export type ShapedQueryExpression = ShapedQueryExpression$instance & __ShapedQueryExpression$views;


export interface SqlAliasManager$instance {
    GenerateTableAlias(name: string): string;
    GenerateTableAlias(modelTable: ITableBase): string;
    PostprocessAliases(expression: Expression): Expression;
    RemapTableAliases(usedAliases: IReadOnlySet<System_Internal.String>): Dictionary<System_Internal.String, System_Internal.String> | undefined;
}


export const SqlAliasManager: {
    new(): SqlAliasManager;
};


export type SqlAliasManager = SqlAliasManager$instance;

export interface SqlAliasManagerFactory$instance {
    Create(): SqlAliasManager;
}


export const SqlAliasManagerFactory: {
    new(): SqlAliasManagerFactory;
};


export interface __SqlAliasManagerFactory$views {
    As_ISqlAliasManagerFactory(): ISqlAliasManagerFactory$instance;
}

export interface SqlAliasManagerFactory$instance extends ISqlAliasManagerFactory$instance {}

export type SqlAliasManagerFactory = SqlAliasManagerFactory$instance & __SqlAliasManagerFactory$views;


export interface SqlExpressionFactory$instance {
    readonly Dependencies: SqlExpressionFactoryDependencies;
    Add(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    And(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    AndAlso(left: SqlExpression, right: SqlExpression): SqlExpression;
    ApplyDefaultTypeMapping(sqlExpression: SqlExpression): SqlExpression | undefined;
    ApplyTypeMapping(sqlExpression: SqlExpression, typeMapping: RelationalTypeMapping): SqlExpression | undefined;
    Case(operand: SqlExpression, whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression, existingExpression?: SqlExpression): SqlExpression;
    Case(whenClauses: IReadOnlyList<CaseWhenClause>, elseResult: SqlExpression): SqlExpression;
    Coalesce(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, type: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    Constant(value: unknown, type: Type, sensitive: boolean, typeMapping?: RelationalTypeMapping): SqlExpression;
    Convert(operand: SqlExpression, type: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Divide(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    Equal(left: SqlExpression, right: SqlExpression): SqlExpression;
    Exists(subquery: SelectExpression): SqlExpression;
    Fragment(sql: string, type?: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(schema: string, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Function(instance: SqlExpression, name: string, arguments: IEnumerable__System_Collections_Generic<SqlExpression>, nullable: boolean, instancePropagatesNullability: boolean, argumentsPropagateNullability: IEnumerable__System_Collections_Generic<System_Internal.Boolean>, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    GreaterThan(left: SqlExpression, right: SqlExpression): SqlExpression;
    GreaterThanOrEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    In(item: SqlExpression, subquery: SelectExpression): SqlExpression;
    In(item: SqlExpression, values: IReadOnlyList<SqlExpression>): SqlExpression;
    In(item: SqlExpression, valuesParameter: SqlParameterExpression): SqlExpression;
    IsNotNull(operand: SqlExpression): SqlExpression;
    IsNull(operand: SqlExpression): SqlExpression;
    LessThan(left: SqlExpression, right: SqlExpression): SqlExpression;
    LessThanOrEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    Like(match: SqlExpression, pattern: SqlExpression, escapeChar?: SqlExpression): SqlExpression;
    MakeBinary(operatorType: ExpressionType, left: SqlExpression, right: SqlExpression, typeMapping: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    MakeUnary(operatorType: ExpressionType, operand: SqlExpression, type: Type, typeMapping?: RelationalTypeMapping, existingExpression?: SqlExpression): SqlExpression | undefined;
    Modulo(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    Multiply(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    Negate(operand: SqlExpression): SqlExpression;
    NiladicFunction(name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    NiladicFunction(schema: string, name: string, nullable: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    NiladicFunction(instance: SqlExpression, name: string, nullable: boolean, instancePropagatesNullability: boolean, returnType: Type, typeMapping?: RelationalTypeMapping): SqlExpression;
    Not(operand: SqlExpression): SqlExpression;
    NotEqual(left: SqlExpression, right: SqlExpression): SqlExpression;
    Or(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
    OrElse(left: SqlExpression, right: SqlExpression): SqlExpression;
    Subtract(left: SqlExpression, right: SqlExpression, typeMapping?: RelationalTypeMapping): SqlExpression;
}


export const SqlExpressionFactory: {
    new(dependencies: SqlExpressionFactoryDependencies): SqlExpressionFactory;
};


export interface __SqlExpressionFactory$views {
    As_ISqlExpressionFactory(): ISqlExpressionFactory$instance;
}

export type SqlExpressionFactory = SqlExpressionFactory$instance & __SqlExpressionFactory$views;


export interface SqlExpressionFactoryDependencies$instance {
    Model: IModel;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): SqlExpressionFactoryDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: SqlExpressionFactoryDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const SqlExpressionFactoryDependencies: {
    new(model: IModel, typeMappingSource: IRelationalTypeMappingSource): SqlExpressionFactoryDependencies;
};


export type SqlExpressionFactoryDependencies = SqlExpressionFactoryDependencies$instance;

export interface SqlExpressionVisitor$instance extends ExpressionVisitor {
    VisitAtTimeZone(atTimeZoneExpression: AtTimeZoneExpression): Expression;
    VisitCase(caseExpression: CaseExpression): Expression;
    VisitCollate(collateExpression: CollateExpression): Expression;
    VisitColumn(columnExpression: ColumnExpression): Expression;
    VisitCrossApply(crossApplyExpression: CrossApplyExpression): Expression;
    VisitCrossJoin(crossJoinExpression: CrossJoinExpression): Expression;
    VisitDelete(deleteExpression: DeleteExpression): Expression;
    VisitDistinct(distinctExpression: DistinctExpression): Expression;
    VisitExcept(exceptExpression: ExceptExpression): Expression;
    VisitExists(existsExpression: ExistsExpression): Expression;
    VisitExtension(extensionExpression: Expression): Expression;
    VisitFromSql(fromSqlExpression: FromSqlExpression): Expression;
    VisitIn(inExpression: InExpression): Expression;
    VisitInnerJoin(innerJoinExpression: InnerJoinExpression): Expression;
    VisitIntersect(intersectExpression: IntersectExpression): Expression;
    VisitJsonScalar(jsonScalarExpression: JsonScalarExpression): Expression;
    VisitLeftJoin(leftJoinExpression: LeftJoinExpression): Expression;
    VisitLike(likeExpression: LikeExpression): Expression;
    VisitOrdering(orderingExpression: OrderingExpression): Expression;
    VisitOuterApply(outerApplyExpression: OuterApplyExpression): Expression;
    VisitProjection(projectionExpression: ProjectionExpression): Expression;
    VisitRightJoin(rightJoinExpression: RightJoinExpression): Expression;
    VisitRowNumber(rowNumberExpression: RowNumberExpression): Expression;
    VisitRowValue(rowValueExpression: RowValueExpression): Expression;
    VisitScalarSubquery(scalarSubqueryExpression: ScalarSubqueryExpression): Expression;
    VisitSelect(selectExpression: SelectExpression): Expression;
    VisitSqlBinary(sqlBinaryExpression: SqlBinaryExpression): Expression;
    VisitSqlConstant(sqlConstantExpression: SqlConstantExpression): Expression;
    VisitSqlFragment(sqlFragmentExpression: SqlFragmentExpression): Expression;
    VisitSqlFunction(sqlFunctionExpression: SqlFunctionExpression): Expression;
    VisitSqlParameter(sqlParameterExpression: SqlParameterExpression): Expression;
    VisitSqlUnary(sqlUnaryExpression: SqlUnaryExpression): Expression;
    VisitTable(tableExpression: TableExpression): Expression;
    VisitTableValuedFunction(tableValuedFunctionExpression: TableValuedFunctionExpression): Expression;
    VisitUnion(unionExpression: UnionExpression): Expression;
    VisitUpdate(updateExpression: UpdateExpression): Expression;
    VisitValues(valuesExpression: ValuesExpression): Expression;
}


export const SqlExpressionVisitor: (abstract new() => SqlExpressionVisitor) & {
};


export type SqlExpressionVisitor = SqlExpressionVisitor$instance;

export interface SqlNullabilityProcessor$instance extends ExpressionVisitor {
    readonly CollectionParameterTranslationMode: ParameterTranslationMode;
    readonly Dependencies: RelationalParameterBasedSqlProcessorDependencies;
    ParametersDecorator: ParametersCacheDecorator;
    readonly PreferExistsToInWithCoalesce: boolean;
    readonly UseRelationalNulls: boolean;
    AddNonNullableColumn(columnExpression: ColumnExpression): void;
    CalculateParameterBucketSize(count: int, elementTypeMapping: RelationalTypeMapping): int;
    IsCollectionTable(table: TableExpressionBase, collection: Expression): boolean;
    OptimizeNotExpression(expression: SqlExpression): SqlExpression;
    Process(queryExpression: Expression, parametersDecorator: ParametersCacheDecorator): Expression;
    ProcessValuesOrderingColumn(valuesExpression: ValuesExpression, expressions: IReadOnlyList<SqlExpression>, intTypeMapping: IntTypeMapping, counter: int): IReadOnlyList<SqlExpression>;
    TryMakeNonNullable(selectExpression: SelectExpression, rewrittenSelectExpression: SelectExpression, foundNull: Nullable<System_Internal.Boolean>): boolean;
    UpdateParameterCollection(table: TableExpressionBase, newCollectionParameter: SqlParameterExpression): TableExpressionBase;
    Visit(selectExpression: SelectExpression, visitProjection?: boolean): SelectExpression;
    Visit(sqlExpression: SqlExpression, nullable: boolean): SqlExpression | undefined;
    Visit(sqlExpression: SqlExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression | undefined;
    VisitAtTimeZone(atTimeZoneExpression: AtTimeZoneExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitCase(caseExpression: CaseExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitCollate(collateExpression: CollateExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitColumn(columnExpression: ColumnExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitCustomSqlExpression(sqlExpression: SqlExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitDistinct(distinctExpression: DistinctExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitExists(existsExpression: ExistsExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitExtension(node: Expression): Expression;
    VisitIn(inExpression: InExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitJsonScalar(jsonScalarExpression: JsonScalarExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitLike(likeExpression: LikeExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitRowNumber(rowNumberExpression: RowNumberExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitRowValue(rowValueExpression: RowValueExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitScalarSubquery(scalarSubqueryExpression: ScalarSubqueryExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlBinary(sqlBinaryExpression: SqlBinaryExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlConstant(sqlConstantExpression: SqlConstantExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlFragment(sqlFragmentExpression: SqlFragmentExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlFunction(sqlFunctionExpression: SqlFunctionExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlParameter(sqlParameterExpression: SqlParameterExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
    VisitSqlUnary(sqlUnaryExpression: SqlUnaryExpression, allowOptimizedExpansion: boolean, nullable: boolean): SqlExpression;
}


export const SqlNullabilityProcessor: {
    new(dependencies: RelationalParameterBasedSqlProcessorDependencies, parameters: RelationalParameterBasedSqlProcessorParameters): SqlNullabilityProcessor;
};


export type SqlNullabilityProcessor = SqlNullabilityProcessor$instance;

export interface SqlTreePruner$instance extends ExpressionVisitor {
    get CurrentTableAlias(): string | undefined;
    set CurrentTableAlias(value: string | undefined);
    readonly ReferencedColumnMap: IReadOnlyDictionary<System_Internal.String, HashSet<System_Internal.String>>;
    Prune(expression: Expression): Expression;
    PruneSelect(select: SelectExpression, preserveProjection: boolean): SelectExpression;
    PruneTopLevelSelect(select: SelectExpression): SelectExpression;
    PruneValues(values: ValuesExpression): ValuesExpression;
    VisitExtension(node: Expression): Expression;
}


export const SqlTreePruner: {
    new(): SqlTreePruner;
};


export type SqlTreePruner = SqlTreePruner$instance;

export interface StructuralTypeProjectionExpression$instance extends Expression {
    readonly DiscriminatorExpression: SqlExpression | undefined;
    readonly IsNullable: boolean;
    readonly NodeType: ExpressionType;
    readonly StructuralType: ITypeBase;
    readonly TableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>;
    readonly Type: Type;
    AddNavigationBinding(navigation: INavigation, shaper: StructuralTypeShaperExpression): void;
    BindComplexProperty(complexProperty: IComplexProperty): Expression;
    BindNavigation(navigation: INavigation): StructuralTypeShaperExpression | undefined;
    BindProperty(property: IProperty): ColumnExpression;
    MakeNullable(): StructuralTypeProjectionExpression;
    ToString(): string;
    UpdateEntityType(derivedType: IEntityType): StructuralTypeProjectionExpression;
    UpdateTableMap(newTableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>): StructuralTypeProjectionExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
}


export const StructuralTypeProjectionExpression: {
    new(type: ITypeBase, propertyExpressionMap: IReadOnlyDictionary<IProperty, ColumnExpression>, tableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>, nullable: boolean, discriminatorExpression: SqlExpression): StructuralTypeProjectionExpression;
    new(type: ITypeBase, propertyExpressionMap: IReadOnlyDictionary<IProperty, ColumnExpression>, complexPropertyCache: Dictionary<IComplexProperty, Expression>, tableMap: IReadOnlyDictionary<ITableBase, System_Internal.String>, nullable: boolean, discriminatorExpression: SqlExpression): StructuralTypeProjectionExpression;
};


export type StructuralTypeProjectionExpression = StructuralTypeProjectionExpression$instance;

export interface StructuralTypeShaperExpression$instance extends Expression {
    readonly IsNullable: boolean;
    readonly MaterializationCondition: LambdaExpression;
    readonly NodeType: ExpressionType;
    readonly StructuralType: ITypeBase;
    readonly Type: Type;
    readonly ValueBufferExpression: Expression;
    DebuggerDisplay(): string;
    GenerateMaterializationCondition(type: ITypeBase, nullable: boolean): LambdaExpression;
    MakeClrTypeNonNullable(): StructuralTypeShaperExpression;
    MakeClrTypeNullable(): StructuralTypeShaperExpression;
    MakeNullable(nullable?: boolean): StructuralTypeShaperExpression;
    Update(valueBufferExpression: Expression): StructuralTypeShaperExpression;
    VisitChildren(visitor: ExpressionVisitor): Expression;
    WithType(type: ITypeBase): StructuralTypeShaperExpression;
}


export const StructuralTypeShaperExpression: {
    new(type: ITypeBase, valueBufferExpression: Expression, nullable: boolean): StructuralTypeShaperExpression;
    CreateUnableToDiscriminateException(type: ITypeBase, discriminator: unknown): Exception;
    CreateUnableToDiscriminateExceptionExpression(type: ITypeBase, discriminatorValue: Expression): Expression;
};


export interface __StructuralTypeShaperExpression$views {
    As_IPrintableExpression(): IPrintableExpression$instance;
}

export interface StructuralTypeShaperExpression$instance extends IPrintableExpression$instance {}

export type StructuralTypeShaperExpression = StructuralTypeShaperExpression$instance & __StructuralTypeShaperExpression$views;


export interface UpdateSettersBuilder$instance {
    BuildSettersExpression(): NewArrayExpression;
    SetProperty(propertyExpression: LambdaExpression, valueExpression: LambdaExpression): UpdateSettersBuilder;
    SetProperty(propertyExpression: LambdaExpression, valueExpression: Expression): UpdateSettersBuilder;
}


export const UpdateSettersBuilder: {
    new(): UpdateSettersBuilder;
};


export type UpdateSettersBuilder = UpdateSettersBuilder$instance;

export interface UpdateSettersBuilder_1$instance<TSource> extends UpdateSettersBuilder {
    SetProperty<TProperty>(propertyExpression: Expression<Func<TSource, TProperty>>, valueExpression: Expression<Func<TSource, TProperty>>): UpdateSettersBuilder_1<TSource>;
    SetProperty<TProperty>(propertyExpression: Expression<Func<TSource, TProperty>>, valueExpression: TProperty): UpdateSettersBuilder_1<TSource>;
    SetProperty(propertyExpression: LambdaExpression, valueExpression: LambdaExpression): UpdateSettersBuilder;
    SetProperty(propertyExpression: LambdaExpression, valueExpression: Expression): UpdateSettersBuilder;
}


export const UpdateSettersBuilder_1: {
    new<TSource>(): UpdateSettersBuilder_1<TSource>;
};


export type UpdateSettersBuilder_1<TSource> = UpdateSettersBuilder_1$instance<TSource>;

export abstract class ExpressionExtensions$instance {
    static InferTypeMapping(...expressions: SqlExpression[]): RelationalTypeMapping | undefined;
    static InferTypeMapping(expressions: IReadOnlyList<SqlExpression>): RelationalTypeMapping | undefined;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class LiftableConstantExpressionHelpers$instance {
    static BuildClrCollectionAccessor(structuralProperty: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static BuildClrCollectionAccessorLambda(structuralProperty: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static BuildMemberAccessForEntityOrComplexType(targetType: ITypeBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static BuildMemberAccessForProperty(property: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static BuildMemberAccessLambdaForProperty(property: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static BuildMemberAccessLambdaForStructuralType(type: ITypeBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static BuildStructuralPropertyAccess(structuralProperty: IPropertyBase, liftableConstantContextParameter: ParameterExpression): Expression;
    static BuildStructuralPropertyAccessLambda(structuralProperty: IPropertyBase): Expression<Func<MaterializerLiftableConstantContext, unknown>>;
    static IsLiteral(value: unknown): boolean;
}


export type LiftableConstantExpressionHelpers = LiftableConstantExpressionHelpers$instance;

export abstract class QueryableMethods$instance {
    static readonly All: MethodInfo;
    static readonly AnyWithoutPredicate: MethodInfo;
    static readonly AnyWithPredicate: MethodInfo;
    static readonly AsQueryable: MethodInfo;
    static readonly Cast: MethodInfo;
    static readonly Concat: MethodInfo;
    static readonly Contains: MethodInfo;
    static readonly CountWithoutPredicate: MethodInfo;
    static readonly CountWithPredicate: MethodInfo;
    static readonly DefaultIfEmptyWithoutArgument: MethodInfo;
    static readonly DefaultIfEmptyWithArgument: MethodInfo;
    static readonly Distinct: MethodInfo;
    static readonly ElementAt: MethodInfo;
    static readonly ElementAtOrDefault: MethodInfo;
    static readonly Except: MethodInfo;
    static readonly FirstWithoutPredicate: MethodInfo;
    static readonly FirstWithPredicate: MethodInfo;
    static readonly FirstOrDefaultWithoutPredicate: MethodInfo;
    static readonly FirstOrDefaultWithPredicate: MethodInfo;
    static readonly GroupByWithKeySelector: MethodInfo;
    static readonly GroupByWithKeyElementSelector: MethodInfo;
    static readonly GroupByWithKeyElementResultSelector: MethodInfo;
    static readonly GroupByWithKeyResultSelector: MethodInfo;
    static readonly GroupJoin: MethodInfo;
    static readonly Intersect: MethodInfo;
    static readonly Join: MethodInfo;
    static readonly LastWithoutPredicate: MethodInfo;
    static readonly LastWithPredicate: MethodInfo;
    static readonly LastOrDefaultWithoutPredicate: MethodInfo;
    static readonly LastOrDefaultWithPredicate: MethodInfo;
    static readonly LeftJoin: MethodInfo;
    static readonly LongCountWithoutPredicate: MethodInfo;
    static readonly LongCountWithPredicate: MethodInfo;
    static readonly MaxWithoutSelector: MethodInfo;
    static readonly MaxWithSelector: MethodInfo;
    static readonly MinWithoutSelector: MethodInfo;
    static readonly MinWithSelector: MethodInfo;
    static readonly OfType: MethodInfo;
    static readonly Order: MethodInfo;
    static readonly OrderBy: MethodInfo;
    static readonly OrderByDescending: MethodInfo;
    static readonly OrderDescending: MethodInfo;
    static readonly Reverse: MethodInfo;
    static readonly RightJoin: MethodInfo;
    static readonly Select: MethodInfo;
    static readonly SelectManyWithoutCollectionSelector: MethodInfo;
    static readonly SelectManyWithCollectionSelector: MethodInfo;
    static readonly SingleWithoutPredicate: MethodInfo;
    static readonly SingleWithPredicate: MethodInfo;
    static readonly SingleOrDefaultWithoutPredicate: MethodInfo;
    static readonly SingleOrDefaultWithPredicate: MethodInfo;
    static readonly Skip: MethodInfo;
    static readonly SkipWhile: MethodInfo;
    static readonly Take: MethodInfo;
    static readonly TakeWhile: MethodInfo;
    static readonly ThenBy: MethodInfo;
    static readonly ThenByDescending: MethodInfo;
    static readonly Union: MethodInfo;
    static readonly Where: MethodInfo;
    static GetAverageWithoutSelector(type: Type): MethodInfo;
    static GetAverageWithSelector(type: Type): MethodInfo;
    static GetSumWithoutSelector(type: Type): MethodInfo;
    static GetSumWithSelector(type: Type): MethodInfo;
    static IsAverageWithoutSelector(methodInfo: MethodInfo): boolean;
    static IsAverageWithSelector(methodInfo: MethodInfo): boolean;
    static IsSumWithoutSelector(methodInfo: MethodInfo): boolean;
    static IsSumWithSelector(methodInfo: MethodInfo): boolean;
}


export type QueryableMethods = QueryableMethods$instance;

export abstract class RelationalExpressionQuotingUtilities$instance {
    static QuoteAnnotations(annotations: IReadOnlyDictionary<System_Internal.String, IAnnotation>): Expression;
    static QuoteOrNull<T extends IRelationalQuotableExpression>(expression: T): Expression;
    static QuoteTableBase(tableBase: ITableBase): Expression;
    static QuoteTags(tags: ISet<System_Internal.String>): Expression;
    static QuoteTypeMapping(typeMapping: RelationalTypeMapping): Expression;
}


export type RelationalExpressionQuotingUtilities = RelationalExpressionQuotingUtilities$instance;

export abstract class TransparentIdentifierFactory$instance {
    static Create(outerType: Type, innerType: Type): Type;
}


export type TransparentIdentifierFactory = TransparentIdentifierFactory$instance;

