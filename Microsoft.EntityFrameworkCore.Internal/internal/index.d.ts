// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Internal
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IChangeDetector, IEntityGraphAttacher, InternalEntityEntry, IStateManager } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { CascadeTiming, DetectChangesEventArgs, DetectedChangesEventArgs, DetectedEntityChangesEventArgs, DetectEntityChangesEventArgs, EntityEntry_1, EntityStateChangedEventArgs, EntityStateChangingEventArgs, EntityTrackedEventArgs, EntityTrackingEventArgs, LoadOptions, LocalView_1 } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IDiagnosticsLogger_1 } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { ICurrentDbContext, IDbContextOptions, IDbSetFinder, IInfrastructure_1, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { TypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import type { IComplexProperty, IEntityType, IModel, INavigation, IProperty, IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyTypeBase, ISkipNavigation, ITypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { RelationalCommandResolver } from "../../Microsoft.EntityFrameworkCore.Query.Internal/internal/index.js";
import type { IAsyncQueryProvider, RelationalQueryContext } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { ValueConverter } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { IExceptionDetector, IRelationalCommand, ValueBuffer } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Internal from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { AutoTransactionBehavior, DbContext, DbContextOptions, DbContextOptions_1, DbLoggerCategory_Infrastructure, DbLoggerCategory_Update, DbSet_1, IDbContextFactory_1, ModelConfigurationBuilder, QueryTrackingBehavior, SaveChangesFailedEventArgs, SavedChangesEventArgs, SavingChangesEventArgs } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IAsyncEnumerable, IAsyncEnumerator, IComparer, IEnumerable as IEnumerable__System_Collections_Generic, IEqualityComparer as IEqualityComparer__System_Collections_Generic, IReadOnlyDictionary, IReadOnlyList, ISet } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable, IEqualityComparer } from "@tsonic/dotnet/System.Collections.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { IListSource } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, EventHandler, Func, IAsyncDisposable, IDisposable, IEquatable, Int32, IServiceProvider, Nullable, Object as ClrObject, String as ClrString, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression, ParameterExpression, UnaryExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import * as System_Linq_Internal from "@tsonic/dotnet/System.Linq.js";
import type { IQueryable } from "@tsonic/dotnet/System.Linq.js";
import type { FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface ICollectionLoader$instance {
    load(entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(entry: InternalEntityEntry): IQueryable;
}


export type ICollectionLoader = ICollectionLoader$instance;

export interface ICollectionLoader_1$instance<TEntity> extends ICollectionLoader {
    load(entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(entry: InternalEntityEntry): IQueryable;
    query(entry: InternalEntityEntry): IQueryable<TEntity>;
}


export interface ICollectionLoader_1$instance<TEntity> extends ICollectionLoader$instance {}

export type ICollectionLoader_1<TEntity> = ICollectionLoader_1$instance<TEntity>;

export interface IDbContextDependencies$instance {
    readonly setSource: IDbSetSource;
    readonly entityFinderFactory: IEntityFinderFactory;
    readonly queryProvider: IAsyncQueryProvider;
    readonly stateManager: IStateManager;
    readonly changeDetector: IChangeDetector;
    readonly entityGraphAttacher: IEntityGraphAttacher;
    readonly exceptionDetector: IExceptionDetector;
    readonly updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    readonly infrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
}


export type IDbContextDependencies = IDbContextDependencies$instance;

export interface IDbContextFactorySource_1$instance<TContext extends DbContext> {
    readonly factory: Func<IServiceProvider, DbContextOptions_1<TContext>, TContext>;
}


export type IDbContextFactorySource_1<TContext extends DbContext> = IDbContextFactorySource_1$instance<TContext>;

export interface IDbContextPool$instance {
    rent(): IDbContextPoolable;
    return(context: IDbContextPoolable): void;
    returnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export type IDbContextPool = IDbContextPool$instance;

export interface IDbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool {
    rent(): IDbContextPoolable;
    return(context: IDbContextPoolable): void;
    returnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export interface IDbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool$instance {}

export type IDbContextPool_1<TContext extends DbContext> = IDbContextPool_1$instance<TContext>;

export interface IDbContextPoolable$instance extends IResettableService, IDisposable, IAsyncDisposable {
    clearLease(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
    setLease(lease: DbContextLease): void;
    setLeaseAsync(lease: DbContextLease, cancellationToken: CancellationToken): Task;
    resetState(): void;
}


export interface IDbContextPoolable$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type IDbContextPoolable = IDbContextPoolable$instance;

export interface IDbContextServices$instance {
    readonly currentContext: ICurrentDbContext;
    readonly model: IModel;
    readonly designTimeModel: IModel;
    readonly contextOptions: DbContextOptions;
    readonly internalServiceProvider: IServiceProvider;
    initialize(scopedProvider: IServiceProvider, contextOptions: DbContextOptions, context: DbContext): IDbContextServices;
}


export type IDbContextServices = IDbContextServices$instance;

export interface IDbSetCache$instance {
    getOrAddSet(source: IDbSetSource, entityTypeName: string, type: Type): unknown;
    getOrAddSet(source: IDbSetSource, type: Type): unknown;
    getSets(): IEnumerable__System_Collections_Generic<unknown>;
}


export type IDbSetCache = IDbSetCache$instance;

export interface IDbSetInitializer$instance {
    initializeSets(context: DbContext): void;
}


export type IDbSetInitializer = IDbSetInitializer$instance;

export interface IDbSetSource$instance {
    create(context: DbContext, name: string, type: Type): unknown;
    create(context: DbContext, type: Type): unknown;
}


export type IDbSetSource = IDbSetSource$instance;

export interface IEntityFinder$instance {
    find(keyValues: unknown[]): unknown | undefined;
    findAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<unknown>;
    findEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    findEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    findEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    findEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    getDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    getDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    getEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    getEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(navigation: INavigation, entry: InternalEntityEntry): IQueryable;
}


export type IEntityFinder = IEntityFinder$instance;

export interface IEntityFinder_1$instance<TEntity> extends IEntityFinder {
    find(keyValues: unknown[]): unknown | undefined;
    find(keyValues: unknown[]): TEntity | undefined;
    findAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<TEntity>;
    findAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<unknown>;
    findEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    findEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    findEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    findEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    getDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    getDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    getEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    getEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(navigation: INavigation, entry: InternalEntityEntry): IQueryable;
    query(navigation: INavigation, entry: InternalEntityEntry): IQueryable<TEntity>;
}


export type IEntityFinder_1<TEntity> = IEntityFinder_1$instance<TEntity>;

export interface IEntityFinderFactory$instance {
    create(type: IEntityType): IEntityFinder;
}


export type IEntityFinderFactory = IEntityFinderFactory$instance;

export interface IEntityFinderSource$instance {
    create(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, type: IEntityType): IEntityFinder;
}


export type IEntityFinderSource = IEntityFinderSource$instance;

export interface IInjectableService$instance {
    attaching(context: DbContext, entityType: IEntityType, entity: unknown): void;
    detaching(context: DbContext, entity: unknown): boolean;
    injected(context: DbContext, entity: unknown, queryTrackingBehavior: Nullable<QueryTrackingBehavior>, structuralType: ITypeBase): void;
}


export type IInjectableService = IInjectableService$instance;

export interface IPatchServiceInjectionSite$instance {
    injectServices(serviceProvider: IServiceProvider): void;
}


export type IPatchServiceInjectionSite = IPatchServiceInjectionSite$instance;

export interface IRegisteredServices$instance {
    readonly services: ISet<Type>;
}


export type IRegisteredServices = IRegisteredServices$instance;

export interface IScopedDbContextLease_1$instance<TContext extends DbContext> {
    readonly context: TContext;
}


export type IScopedDbContextLease_1<TContext extends DbContext> = IScopedDbContextLease_1$instance<TContext>;

export interface ISingletonOptionsInitializer$instance {
    ensureInitialized(serviceProvider: IServiceProvider, options: IDbContextOptions): void;
}


export type ISingletonOptionsInitializer = ISingletonOptionsInitializer$instance;

export interface DbContextLease$instance {
    readonly context: IDbContextPoolable;
    readonly isActive: boolean;
    readonly isStandalone: boolean;
    contextDisposed(): void;
    contextDisposedAsync(): ValueTask;
    release(): void;
    releaseAsync(): ValueTask;
}


export const DbContextLease: {
    new(contextPool: IDbContextPool, standalone: boolean): DbContextLease;
    readonly inactiveLease: DbContextLease;
};


export type DbContextLease = DbContextLease$instance;

export interface DbContextDependencies$instance {
    readonly changeDetector: IChangeDetector;
    readonly entityFinderFactory: IEntityFinderFactory;
    readonly entityGraphAttacher: IEntityGraphAttacher;
    readonly exceptionDetector: IExceptionDetector;
    readonly infrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
    readonly queryProvider: IAsyncQueryProvider;
    readonly setSource: IDbSetSource;
    readonly stateManager: IStateManager;
    readonly updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    _Clone_$(): DbContextDependencies;
    equals(obj: unknown): boolean;
    equals(other: DbContextDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const DbContextDependencies: {
    new(currentContext: ICurrentDbContext, changeDetector: IChangeDetector, setSource: IDbSetSource, entityFinderSource: IEntityFinderSource, entityGraphAttacher: IEntityGraphAttacher, queryProvider: IAsyncQueryProvider, stateManager: IStateManager, exceptionDetector: IExceptionDetector, updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>, infrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>): DbContextDependencies;
};


export interface __DbContextDependencies$views {
    As_IDbContextDependencies(): IDbContextDependencies$instance;
}

export interface DbContextDependencies$instance extends IDbContextDependencies$instance {}

export type DbContextDependencies = DbContextDependencies$instance & __DbContextDependencies$views;


export interface DbContextFactory_1$instance<TContext extends DbContext> {
    createDbContext(): TContext;
    createDbContextAsync(cancellationToken?: CancellationToken): Task<TContext>;
}


export const DbContextFactory_1: {
    new<TContext extends DbContext>(serviceProvider: IServiceProvider, options: DbContextOptions_1<TContext>, factorySource: IDbContextFactorySource_1<TContext>): DbContextFactory_1<TContext>;
};


export interface __DbContextFactory_1$views<TContext extends DbContext> {
    As_IDbContextFactory_1(): Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext>;
}

export interface DbContextFactory_1$instance<TContext extends DbContext> extends Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext> {}

export type DbContextFactory_1<TContext extends DbContext> = DbContextFactory_1$instance<TContext> & __DbContextFactory_1$views<TContext>;


export interface DbContextFactorySource_1$instance<TContext extends DbContext> {
    readonly factory: Func<IServiceProvider, DbContextOptions_1<TContext>, TContext>;
}


export const DbContextFactorySource_1: {
    new<TContext extends DbContext>(): DbContextFactorySource_1<TContext>;
};


export interface __DbContextFactorySource_1$views<TContext extends DbContext> {
    As_IDbContextFactorySource_1(): IDbContextFactorySource_1$instance<TContext>;
}

export interface DbContextFactorySource_1$instance<TContext extends DbContext> extends IDbContextFactorySource_1$instance<TContext> {}

export type DbContextFactorySource_1<TContext extends DbContext> = DbContextFactorySource_1$instance<TContext> & __DbContextFactorySource_1$views<TContext>;


export interface DbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool_1<TContext> {
    dispose(): void;
    disposeAsync(): ValueTask;
    rent(): IDbContextPoolable;
    return(context: IDbContextPoolable): void;
    returnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export const DbContextPool_1: {
    new<TContext extends DbContext>(options: DbContextOptions_1<TContext>, serviceProvider: IServiceProvider): DbContextPool_1<TContext>;
    readonly defaultPoolSize: int;
};


export interface __DbContextPool_1$views<TContext extends DbContext> {
    As_IDbContextPool(): IDbContextPool$instance;
}

export type DbContextPool_1<TContext extends DbContext> = DbContextPool_1$instance<TContext> & __DbContextPool_1$views<TContext>;


export interface DbContextPoolConfigurationSnapshot$instance {
    readonly autoDetectChangesEnabled: boolean;
    readonly autoSavepointsEnabled: boolean;
    readonly autoTransactionBehavior: AutoTransactionBehavior;
    readonly cascadeDeleteTiming: CascadeTiming;
    readonly deleteOrphansTiming: CascadeTiming;
    readonly detectedAllChanges: EventHandler<DetectedChangesEventArgs> | undefined;
    readonly detectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs> | undefined;
    readonly detectingAllChanges: EventHandler<DetectChangesEventArgs> | undefined;
    readonly detectingEntityChanges: EventHandler<DetectEntityChangesEventArgs> | undefined;
    readonly hasChangeDetectorConfiguration: boolean;
    readonly hasChangeTrackerConfiguration: boolean;
    readonly hasDatabaseConfiguration: boolean;
    readonly hasStateManagerConfiguration: boolean;
    readonly lazyLoadingEnabled: boolean;
    readonly queryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    readonly saveChangesFailed: EventHandler<SaveChangesFailedEventArgs> | undefined;
    readonly savedChanges: EventHandler<SavedChangesEventArgs> | undefined;
    readonly savingChanges: EventHandler<SavingChangesEventArgs> | undefined;
    readonly stateChanged: EventHandler<EntityStateChangedEventArgs> | undefined;
    readonly stateChanging: EventHandler<EntityStateChangingEventArgs> | undefined;
    readonly tracked: EventHandler<EntityTrackedEventArgs> | undefined;
    readonly tracking: EventHandler<EntityTrackingEventArgs> | undefined;
}


export const DbContextPoolConfigurationSnapshot: {
    new(hasDatabaseConfiguration: boolean, hasStateManagerConfiguration: boolean, hasChangeTrackerConfiguration: boolean, hasChangeDetectorConfiguration: boolean, autoDetectChangesEnabled: boolean, queryTrackingBehavior: Nullable<QueryTrackingBehavior>, autoTransactionBehavior: AutoTransactionBehavior, autoSavepointsEnabled: boolean, lazyLoadingEnabled: boolean, cascadeDeleteTiming: CascadeTiming, deleteOrphansTiming: CascadeTiming, savingChanges: EventHandler<SavingChangesEventArgs>, savedChanges: EventHandler<SavedChangesEventArgs>, saveChangesFailed: EventHandler<SaveChangesFailedEventArgs>, tracking: EventHandler<EntityTrackingEventArgs>, tracked: EventHandler<EntityTrackedEventArgs>, stateChanging: EventHandler<EntityStateChangingEventArgs>, stateChanged: EventHandler<EntityStateChangedEventArgs>, detectingAllChanges: EventHandler<DetectChangesEventArgs>, detectedAllChanges: EventHandler<DetectedChangesEventArgs>, detectingEntityChanges: EventHandler<DetectEntityChangesEventArgs>, detectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs>): DbContextPoolConfigurationSnapshot;
};


export type DbContextPoolConfigurationSnapshot = DbContextPoolConfigurationSnapshot$instance;

export interface DbContextServices$instance {
    readonly contextOptions: DbContextOptions;
    readonly currentContext: ICurrentDbContext;
    readonly designTimeModel: IModel;
    readonly internalServiceProvider: IServiceProvider;
    readonly model: IModel;
    initialize(scopedProvider: IServiceProvider, contextOptions: DbContextOptions, context: DbContext): IDbContextServices;
}


export const DbContextServices: {
    new(): DbContextServices;
};


export interface __DbContextServices$views {
    As_IDbContextServices(): IDbContextServices$instance;
}

export interface DbContextServices$instance extends IDbContextServices$instance {}

export type DbContextServices = DbContextServices$instance & __DbContextServices$views;


export interface DbSetInitializer$instance {
    initializeSets(context: DbContext): void;
}


export const DbSetInitializer: {
    new(setFinder: IDbSetFinder, setSource: IDbSetSource): DbSetInitializer;
};


export interface __DbSetInitializer$views {
    As_IDbSetInitializer(): IDbSetInitializer$instance;
}

export interface DbSetInitializer$instance extends IDbSetInitializer$instance {}

export type DbSetInitializer = DbSetInitializer$instance & __DbSetInitializer$views;


export interface DbSetSource$instance {
    create(context: DbContext, type: Type): unknown;
    create(context: DbContext, name: string, type: Type): unknown;
}


export const DbSetSource: {
    new(): DbSetSource;
};


export interface __DbSetSource$views {
    As_IDbSetSource(): IDbSetSource$instance;
}

export interface DbSetSource$instance extends IDbSetSource$instance {}

export type DbSetSource = DbSetSource$instance & __DbSetSource$views;


export interface EntityFinder_1$instance<TEntity> {
    find(keyValues: unknown[]): TEntity | undefined;
    findAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<TEntity>;
    findEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    findEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    findEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    findEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    getDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    getDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    getEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    getEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(navigation: INavigation, entry: InternalEntityEntry): IQueryable<TEntity>;
}


export const EntityFinder_1: {
    new<TEntity>(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, entityType: IEntityType): EntityFinder_1<TEntity>;
};


export interface __EntityFinder_1$views<TEntity> {
    As_IEntityFinder(): IEntityFinder$instance;
    As_IEntityFinder_1(): IEntityFinder_1$instance<TEntity>;
}

export type EntityFinder_1<TEntity> = EntityFinder_1$instance<TEntity> & __EntityFinder_1$views<TEntity>;


export interface EntityFinderCollectionLoaderAdapter$instance {
    load(entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(entry: InternalEntityEntry): IQueryable;
}


export const EntityFinderCollectionLoaderAdapter: {
    new(entityFinder: IEntityFinder, navigation: INavigation): EntityFinderCollectionLoaderAdapter;
};


export interface __EntityFinderCollectionLoaderAdapter$views {
    As_ICollectionLoader(): ICollectionLoader$instance;
}

export interface EntityFinderCollectionLoaderAdapter$instance extends ICollectionLoader$instance {}

export type EntityFinderCollectionLoaderAdapter = EntityFinderCollectionLoaderAdapter$instance & __EntityFinderCollectionLoaderAdapter$views;


export interface EntityFinderFactory$instance {
    create(type: IEntityType): IEntityFinder;
}


export const EntityFinderFactory: {
    new(entityFinderSource: IEntityFinderSource, stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache): EntityFinderFactory;
};


export interface __EntityFinderFactory$views {
    As_IEntityFinderFactory(): IEntityFinderFactory$instance;
}

export interface EntityFinderFactory$instance extends IEntityFinderFactory$instance {}

export type EntityFinderFactory = EntityFinderFactory$instance & __EntityFinderFactory$views;


export interface EntityFinderSource$instance {
    create(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, type: IEntityType): IEntityFinder;
}


export const EntityFinderSource: {
    new(): EntityFinderSource;
};


export interface __EntityFinderSource$views {
    As_IEntityFinderSource(): IEntityFinderSource$instance;
}

export interface EntityFinderSource$instance extends IEntityFinderSource$instance {}

export type EntityFinderSource = EntityFinderSource$instance & __EntityFinderSource$views;


export interface InternalDbSet_1$instance<TEntity> extends DbSet_1<TEntity> {
    readonly entityType: IEntityType;
    readonly local: LocalView_1<TEntity>;
    add(entity: TEntity): EntityEntry_1<TEntity>;
    add(entity: TEntity): EntityEntry_1<TEntity>;
    addAsync(entity: TEntity, cancellationToken?: CancellationToken): ValueTask<EntityEntry_1<TEntity>>;
    addAsync(entity: TEntity, cancellationToken?: CancellationToken): ValueTask<EntityEntry_1<TEntity>>;
    addRange(...entities: TEntity[]): void;
    addRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    addRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    addRangeAsync(...entities: TEntity[]): Task;
    addRangeAsync(entities: IEnumerable__System_Collections_Generic<TEntity>, cancellationToken?: CancellationToken): Task;
    addRangeAsync(entities: IEnumerable__System_Collections_Generic<TEntity>, cancellationToken?: CancellationToken): Task;
    attach(entity: TEntity): EntityEntry_1<TEntity>;
    attach(entity: TEntity): EntityEntry_1<TEntity>;
    attachRange(...entities: TEntity[]): void;
    attachRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    attachRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    entry(entity: TEntity): EntityEntry_1<TEntity>;
    entry(entity: TEntity): EntityEntry_1<TEntity>;
    find(...keyValues: unknown[]): TEntity | undefined;
    findAsync(...keyValues: unknown[]): ValueTask<TEntity>;
    findAsync(keyValues: unknown[], cancellationToken: CancellationToken): ValueTask<TEntity>;
    findAsync(...keyValues: unknown[]): ValueTask<TEntity>;
    findAsync(keyValues: unknown[], cancellationToken: CancellationToken): ValueTask<TEntity>;
    remove(entity: TEntity): EntityEntry_1<TEntity>;
    remove(entity: TEntity): EntityEntry_1<TEntity>;
    removeRange(...entities: TEntity[]): void;
    removeRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    removeRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    update(entity: TEntity): EntityEntry_1<TEntity>;
    update(entity: TEntity): EntityEntry_1<TEntity>;
    updateRange(...entities: TEntity[]): void;
    updateRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    updateRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
}


export const InternalDbSet_1: {
    new<TEntity>(context: DbContext, entityTypeName: string): InternalDbSet_1<TEntity>;
};


export interface __InternalDbSet_1$views<TEntity> {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<IServiceProvider>;
    As_IResettableService(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance;
}

export interface InternalDbSet_1$instance<TEntity> extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<IServiceProvider>, Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type InternalDbSet_1<TEntity> = InternalDbSet_1$instance<TEntity> & __InternalDbSet_1$views<TEntity>;


export interface ManyToManyLoader_2$instance<TEntity, TSourceEntity> {
    load(entry: InternalEntityEntry, options: LoadOptions): void;
    loadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    query(entry: InternalEntityEntry): IQueryable<TEntity>;
}


export const ManyToManyLoader_2: {
    new<TEntity, TSourceEntity>(skipNavigation: ISkipNavigation): ManyToManyLoader_2<TEntity, TSourceEntity>;
};


export interface __ManyToManyLoader_2$views<TEntity, TSourceEntity> {
    As_ICollectionLoader(): ICollectionLoader$instance;
    As_ICollectionLoader_1(): ICollectionLoader_1$instance<TEntity>;
}

export type ManyToManyLoader_2<TEntity, TSourceEntity> = ManyToManyLoader_2$instance<TEntity, TSourceEntity> & __ManyToManyLoader_2$views<TEntity, TSourceEntity>;


export interface ManyToManyLoaderFactory$instance {
    create(skipNavigation: ISkipNavigation): ICollectionLoader;
}


export const ManyToManyLoaderFactory: {
    new(): ManyToManyLoaderFactory;
    readonly instance: ManyToManyLoaderFactory;
};


export type ManyToManyLoaderFactory = ManyToManyLoaderFactory$instance;

export interface NullableComparerAdapter_1$instance<TNullableKey> {
    equals(x: TNullableKey, y: TNullableKey): boolean;
    getHashCode(obj: TNullableKey): int;
}


export const NullableComparerAdapter_1: {
    new<TNullableKey>(): NullableComparerAdapter_1<TNullableKey>;
    wrap<TNullableKey>(comparer: IEqualityComparer, valueConverter?: ValueConverter): IEqualityComparer__System_Collections_Generic<TNullableKey>;
};


export type NullableComparerAdapter_1<TNullableKey> = NullableComparerAdapter_1$instance<TNullableKey>;

export interface RegisteredServices$instance {
    readonly services: ISet<Type>;
}


export const RegisteredServices: {
    new(services: IEnumerable__System_Collections_Generic<Type>): RegisteredServices;
};


export interface __RegisteredServices$views {
    As_IRegisteredServices(): IRegisteredServices$instance;
}

export interface RegisteredServices$instance extends IRegisteredServices$instance {}

export type RegisteredServices = RegisteredServices$instance & __RegisteredServices$views;


export interface ScopedDbContextLease_1$instance<TContext extends DbContext> {
    readonly context: TContext;
}


export const ScopedDbContextLease_1: {
    new<TContext extends DbContext>(contextPool: IDbContextPool_1<TContext>): ScopedDbContextLease_1<TContext>;
};


export interface __ScopedDbContextLease_1$views<TContext extends DbContext> {
    As_IScopedDbContextLease_1(): IScopedDbContextLease_1$instance<TContext>;
}

export interface ScopedDbContextLease_1$instance<TContext extends DbContext> extends IScopedDbContextLease_1$instance<TContext> {}

export type ScopedDbContextLease_1<TContext extends DbContext> = ScopedDbContextLease_1$instance<TContext> & __ScopedDbContextLease_1$views<TContext>;


export interface SemanticVersionComparer$instance {
    compare(x: string, y: string): int;
}


export const SemanticVersionComparer: {
    new(): SemanticVersionComparer;
};


export type SemanticVersionComparer = SemanticVersionComparer$instance;

export interface ServiceProviderCache$instance {
    getOrAdd(options: IDbContextOptions, providerRequired: boolean): IServiceProvider;
}


export const ServiceProviderCache: {
    new(): ServiceProviderCache;
    readonly instance: ServiceProviderCache;
};


export type ServiceProviderCache = ServiceProviderCache$instance;

export interface SingletonOptionsInitializer$instance {
    ensureInitialized(serviceProvider: IServiceProvider, options: IDbContextOptions): void;
}


export const SingletonOptionsInitializer: {
    new(): SingletonOptionsInitializer;
};


export interface __SingletonOptionsInitializer$views {
    As_ISingletonOptionsInitializer(): ISingletonOptionsInitializer$instance;
}

export interface SingletonOptionsInitializer$instance extends ISingletonOptionsInitializer$instance {}

export type SingletonOptionsInitializer = SingletonOptionsInitializer$instance & __SingletonOptionsInitializer$views;


export interface TypeFullNameComparer$instance {
    compare(x: Type, y: Type): int;
    equals(x: Type, y: Type): boolean;
    getHashCode(obj: Type): int;
}


export const TypeFullNameComparer: {
    new(): TypeFullNameComparer;
    readonly instance: TypeFullNameComparer;
};


export type TypeFullNameComparer = TypeFullNameComparer$instance;

export abstract class DbContextDependenciesExtensions$instance {
    static getDependencies(currentContext: ICurrentDbContext): IDbContextDependencies;
    static getDependencies(context: IDbContextDependencies): IDbContextDependencies;
}


export type DbContextDependenciesExtensions = DbContextDependenciesExtensions$instance;

export abstract class DbContextExtensions$instance {
    static configureConventions(context: DbContext, configurationBuilder: ModelConfigurationBuilder): void;
}


export type DbContextExtensions = DbContextExtensions$instance;

export abstract class EntityTypeExtensions$instance {
    static isAdHoc(entityType: IEntityType): boolean;
}


export type EntityTypeExtensions = EntityTypeExtensions$instance;

export abstract class ExpressionExtensions$instance {
    static buildPredicate(keyProperties: IReadOnlyList<IReadOnlyProperty>, keyValues: ValueBuffer, entityParameter: ParameterExpression): Expression;
    static getLambdaOrNull(expression: Expression): LambdaExpression | undefined;
    static isLogicalNot(sqlUnaryExpression: UnaryExpression): boolean;
    static isLogicalOperation(expression: Expression): boolean;
    static makeHasSentinel(currentValueExpression: Expression, propertyBase: IReadOnlyPropertyBase): Expression;
    static matchMemberAccessList<TMemberInfo extends MemberInfo>(lambdaExpression: LambdaExpression, memberMatcher: Func<Expression, Expression, TMemberInfo>): IReadOnlyList<TMemberInfo> | undefined;
    static matchSimpleMemberAccess<TMemberInfo extends MemberInfo>(parameterExpression: Expression, memberAccessExpression: Expression): TMemberInfo | undefined;
    static removeTypeAs(expression: Expression): Expression | undefined;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static methodIsClosedFormOf(methodInfo: MethodInfo, genericMethod: MethodInfo): boolean;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class MethodInfoExtensions2$instance {
    static displayName(methodInfo: MethodInfo): string;
}


export type MethodInfoExtensions2 = MethodInfoExtensions2$instance;

export abstract class RelationalCommandResolverExtensions$instance {
    static rentAndPopulateRelationalCommand(relationalCommandResolver: RelationalCommandResolver, queryContext: RelationalQueryContext): IRelationalCommand;
}


export type RelationalCommandResolverExtensions = RelationalCommandResolverExtensions$instance;

export abstract class RelationalModelExtensions$instance {
    static ensureRelationalModel(model: IModel): void;
}


export type RelationalModelExtensions = RelationalModelExtensions$instance;

export abstract class TupleExtensions$instance {
    static formatTable(table: ValueTuple<System_Internal.String, System_Internal.String>): string;
    static formatTables(tables: IEnumerable__System_Collections_Generic<ValueTuple<System_Internal.String, System_Internal.String>>): string;
}


export type TupleExtensions = TupleExtensions$instance;

export abstract class TypeBaseExtensions$instance {
    static displayName(entityType: TypeBase): string;
    static getComplexProperty(type: ITypeBase, name: string): IComplexProperty;
    static getOwnedName(type: IReadOnlyTypeBase, simpleName: string, ownershipNavigation: string): string;
    static getRuntimeFields(type: IReadOnlyTypeBase): IReadOnlyDictionary<System_Internal.String, FieldInfo>;
    static getRuntimeProperties(type: IReadOnlyTypeBase): IReadOnlyDictionary<System_Internal.String, PropertyInfo>;
    static shortName(entityType: TypeBase): string;
}


export type TypeBaseExtensions = TypeBaseExtensions$instance;

export abstract class TypeExtensions$instance {
    static findIndexerProperty(type: Type): PropertyInfo | undefined;
    static generateParameterName(type: Type): string;
    static getFieldInfo(type: Type, fieldName: string): FieldInfo | undefined;
    static isDefaultValue(type: Type, value: unknown): boolean;
}


export type TypeExtensions = TypeExtensions$instance;

