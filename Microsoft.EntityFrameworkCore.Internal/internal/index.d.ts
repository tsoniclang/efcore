// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Internal
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IChangeDetector, IEntityGraphAttacher, InternalEntityEntry, IStateManager } from "../../Microsoft.EntityFrameworkCore.ChangeTracking.Internal/internal/index.js";
import type { CascadeTiming, DetectChangesEventArgs, DetectedChangesEventArgs, DetectedEntityChangesEventArgs, DetectEntityChangesEventArgs, EntityEntry_1, EntityStateChangedEventArgs, EntityStateChangingEventArgs, EntityTrackedEventArgs, EntityTrackingEventArgs, LoadOptions, LocalView_1 } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IDiagnosticsLogger_1 } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { ICurrentDbContext, IDbContextOptions, IDbSetFinder, IInfrastructure_1, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { TypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata.Internal/internal/index.js";
import type { IComplexProperty, IEntityType, IModel, INavigation, IProperty, IReadOnlyProperty, IReadOnlyPropertyBase, IReadOnlyTypeBase, ISkipNavigation, ITypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { RelationalCommandResolver } from "../../Microsoft.EntityFrameworkCore.Query.Internal/internal/index.js";
import type { IAsyncQueryProvider, RelationalQueryContext } from "../../Microsoft.EntityFrameworkCore.Query/internal/index.js";
import type { ValueConverter } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion/internal/index.js";
import type { IExceptionDetector, IRelationalCommand, ValueBuffer } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Internal from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { AutoTransactionBehavior, DbContext, DbContextOptions, DbContextOptions_1, DbLoggerCategory_Infrastructure, DbLoggerCategory_Update, DbSet_1, IDbContextFactory_1, ModelConfigurationBuilder, QueryTrackingBehavior, SaveChangesFailedEventArgs, SavedChangesEventArgs, SavingChangesEventArgs } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IAsyncEnumerable, IAsyncEnumerator, IComparer, IEnumerable as IEnumerable__System_Collections_Generic, IEqualityComparer as IEqualityComparer__System_Collections_Generic, IReadOnlyDictionary, IReadOnlyList, ISet } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable, IEqualityComparer } from "@tsonic/dotnet/System.Collections.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { IListSource } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, EventHandler, Func, IAsyncDisposable, IDisposable, IEquatable, Int32, IServiceProvider, Nullable, Object as ClrObject, String as ClrString, Type, ValueTuple, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression, ParameterExpression, UnaryExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import * as System_Linq_Internal from "@tsonic/dotnet/System.Linq.js";
import type { IQueryable } from "@tsonic/dotnet/System.Linq.js";
import type { FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface ICollectionLoader$instance {
    Load(entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(entry: InternalEntityEntry): IQueryable;
}


export type ICollectionLoader = ICollectionLoader$instance;

export interface ICollectionLoader_1$instance<TEntity> extends ICollectionLoader {
    Load(entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(entry: InternalEntityEntry): IQueryable;
    Query(entry: InternalEntityEntry): IQueryable<TEntity>;
}


export interface ICollectionLoader_1$instance<TEntity> extends ICollectionLoader$instance {}

export type ICollectionLoader_1<TEntity> = ICollectionLoader_1$instance<TEntity>;

export interface IDbContextDependencies$instance {
    readonly SetSource: IDbSetSource;
    readonly EntityFinderFactory: IEntityFinderFactory;
    readonly QueryProvider: IAsyncQueryProvider;
    readonly StateManager: IStateManager;
    readonly ChangeDetector: IChangeDetector;
    readonly EntityGraphAttacher: IEntityGraphAttacher;
    readonly ExceptionDetector: IExceptionDetector;
    readonly UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    readonly InfrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
}


export type IDbContextDependencies = IDbContextDependencies$instance;

export interface IDbContextFactorySource_1$instance<TContext extends DbContext> {
    readonly Factory: Func<IServiceProvider, DbContextOptions_1<TContext>, TContext>;
}


export type IDbContextFactorySource_1<TContext extends DbContext> = IDbContextFactorySource_1$instance<TContext>;

export interface IDbContextPool$instance {
    Rent(): IDbContextPoolable;
    Return(context: IDbContextPoolable): void;
    ReturnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export type IDbContextPool = IDbContextPool$instance;

export interface IDbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool {
    Rent(): IDbContextPoolable;
    Return(context: IDbContextPoolable): void;
    ReturnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export interface IDbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool$instance {}

export type IDbContextPool_1<TContext extends DbContext> = IDbContextPool_1$instance<TContext>;

export interface IDbContextPoolable$instance extends IResettableService, IDisposable, IAsyncDisposable {
    ClearLease(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
    SetLease(lease: DbContextLease): void;
    SetLeaseAsync(lease: DbContextLease, cancellationToken: CancellationToken): Task;
    ResetState(): void;
}


export interface IDbContextPoolable$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type IDbContextPoolable = IDbContextPoolable$instance;

export interface IDbContextServices$instance {
    readonly CurrentContext: ICurrentDbContext;
    readonly Model: IModel;
    readonly DesignTimeModel: IModel;
    readonly ContextOptions: DbContextOptions;
    readonly InternalServiceProvider: IServiceProvider;
    Initialize(scopedProvider: IServiceProvider, contextOptions: DbContextOptions, context: DbContext): IDbContextServices;
}


export type IDbContextServices = IDbContextServices$instance;

export interface IDbSetCache$instance {
    GetOrAddSet(source: IDbSetSource, entityTypeName: string, type: Type): unknown;
    GetOrAddSet(source: IDbSetSource, type: Type): unknown;
    GetSets(): IEnumerable__System_Collections_Generic<unknown>;
}


export type IDbSetCache = IDbSetCache$instance;

export interface IDbSetInitializer$instance {
    InitializeSets(context: DbContext): void;
}


export type IDbSetInitializer = IDbSetInitializer$instance;

export interface IDbSetSource$instance {
    Create(context: DbContext, name: string, type: Type): unknown;
    Create(context: DbContext, type: Type): unknown;
}


export type IDbSetSource = IDbSetSource$instance;

export interface IEntityFinder$instance {
    Find(keyValues: unknown[]): unknown | undefined;
    FindAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<unknown>;
    FindEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    FindEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    FindEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    FindEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    GetDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    GetDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    GetEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(navigation: INavigation, entry: InternalEntityEntry): IQueryable;
}


export type IEntityFinder = IEntityFinder$instance;

export interface IEntityFinder_1$instance<TEntity> extends IEntityFinder {
    Find(keyValues: unknown[]): unknown | undefined;
    Find(keyValues: unknown[]): TEntity | undefined;
    FindAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<TEntity>;
    FindAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<unknown>;
    FindEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    FindEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    FindEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    FindEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    GetDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    GetDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    GetEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(navigation: INavigation, entry: InternalEntityEntry): IQueryable;
    Query(navigation: INavigation, entry: InternalEntityEntry): IQueryable<TEntity>;
}


export type IEntityFinder_1<TEntity> = IEntityFinder_1$instance<TEntity>;

export interface IEntityFinderFactory$instance {
    Create(type: IEntityType): IEntityFinder;
}


export type IEntityFinderFactory = IEntityFinderFactory$instance;

export interface IEntityFinderSource$instance {
    Create(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, type: IEntityType): IEntityFinder;
}


export type IEntityFinderSource = IEntityFinderSource$instance;

export interface IInjectableService$instance {
    Attaching(context: DbContext, entityType: IEntityType, entity: unknown): void;
    Detaching(context: DbContext, entity: unknown): boolean;
    Injected(context: DbContext, entity: unknown, queryTrackingBehavior: Nullable<QueryTrackingBehavior>, structuralType: ITypeBase): void;
}


export type IInjectableService = IInjectableService$instance;

export interface IPatchServiceInjectionSite$instance {
    InjectServices(serviceProvider: IServiceProvider): void;
}


export type IPatchServiceInjectionSite = IPatchServiceInjectionSite$instance;

export interface IRegisteredServices$instance {
    readonly Services: ISet<Type>;
}


export type IRegisteredServices = IRegisteredServices$instance;

export interface IScopedDbContextLease_1$instance<TContext extends DbContext> {
    readonly Context: TContext;
}


export type IScopedDbContextLease_1<TContext extends DbContext> = IScopedDbContextLease_1$instance<TContext>;

export interface ISingletonOptionsInitializer$instance {
    EnsureInitialized(serviceProvider: IServiceProvider, options: IDbContextOptions): void;
}


export type ISingletonOptionsInitializer = ISingletonOptionsInitializer$instance;

export interface DbContextLease$instance {
    readonly Context: IDbContextPoolable;
    readonly IsActive: boolean;
    readonly IsStandalone: boolean;
    ContextDisposed(): void;
    ContextDisposedAsync(): ValueTask;
    Release(): void;
    ReleaseAsync(): ValueTask;
}


export const DbContextLease: {
    new(contextPool: IDbContextPool, standalone: boolean): DbContextLease;
    readonly InactiveLease: DbContextLease;
};


export type DbContextLease = DbContextLease$instance;

export interface DbContextDependencies$instance {
    readonly ChangeDetector: IChangeDetector;
    readonly EntityFinderFactory: IEntityFinderFactory;
    readonly EntityGraphAttacher: IEntityGraphAttacher;
    readonly ExceptionDetector: IExceptionDetector;
    readonly InfrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>;
    readonly QueryProvider: IAsyncQueryProvider;
    readonly SetSource: IDbSetSource;
    readonly StateManager: IStateManager;
    readonly UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    _Clone_$(): DbContextDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: DbContextDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const DbContextDependencies: {
    new(currentContext: ICurrentDbContext, changeDetector: IChangeDetector, setSource: IDbSetSource, entityFinderSource: IEntityFinderSource, entityGraphAttacher: IEntityGraphAttacher, queryProvider: IAsyncQueryProvider, stateManager: IStateManager, exceptionDetector: IExceptionDetector, updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>, infrastructureLogger: IDiagnosticsLogger_1<DbLoggerCategory_Infrastructure>): DbContextDependencies;
};


export interface __DbContextDependencies$views {
    As_IDbContextDependencies(): IDbContextDependencies$instance;
}

export interface DbContextDependencies$instance extends IDbContextDependencies$instance {}

export type DbContextDependencies = DbContextDependencies$instance & __DbContextDependencies$views;


export interface DbContextFactory_1$instance<TContext extends DbContext> {
    CreateDbContext(): TContext;
    CreateDbContextAsync(cancellationToken?: CancellationToken): Task<TContext>;
}


export const DbContextFactory_1: {
    new<TContext extends DbContext>(serviceProvider: IServiceProvider, options: DbContextOptions_1<TContext>, factorySource: IDbContextFactorySource_1<TContext>): DbContextFactory_1<TContext>;
};


export interface __DbContextFactory_1$views<TContext extends DbContext> {
    As_IDbContextFactory_1(): Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext>;
}

export interface DbContextFactory_1$instance<TContext extends DbContext> extends Microsoft_EntityFrameworkCore_Internal.IDbContextFactory_1$instance<TContext> {}

export type DbContextFactory_1<TContext extends DbContext> = DbContextFactory_1$instance<TContext> & __DbContextFactory_1$views<TContext>;


export interface DbContextFactorySource_1$instance<TContext extends DbContext> {
    readonly Factory: Func<IServiceProvider, DbContextOptions_1<TContext>, TContext>;
}


export const DbContextFactorySource_1: {
    new<TContext extends DbContext>(): DbContextFactorySource_1<TContext>;
};


export interface __DbContextFactorySource_1$views<TContext extends DbContext> {
    As_IDbContextFactorySource_1(): IDbContextFactorySource_1$instance<TContext>;
}

export interface DbContextFactorySource_1$instance<TContext extends DbContext> extends IDbContextFactorySource_1$instance<TContext> {}

export type DbContextFactorySource_1<TContext extends DbContext> = DbContextFactorySource_1$instance<TContext> & __DbContextFactorySource_1$views<TContext>;


export interface DbContextPool_1$instance<TContext extends DbContext> extends IDbContextPool_1<TContext> {
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Rent(): IDbContextPoolable;
    Return(context: IDbContextPoolable): void;
    ReturnAsync(context: IDbContextPoolable, cancellationToken?: CancellationToken): ValueTask;
}


export const DbContextPool_1: {
    new<TContext extends DbContext>(options: DbContextOptions_1<TContext>, serviceProvider: IServiceProvider): DbContextPool_1<TContext>;
    readonly DefaultPoolSize: int;
};


export interface __DbContextPool_1$views<TContext extends DbContext> {
    As_IDbContextPool(): IDbContextPool$instance;
}

export type DbContextPool_1<TContext extends DbContext> = DbContextPool_1$instance<TContext> & __DbContextPool_1$views<TContext>;


export interface DbContextPoolConfigurationSnapshot$instance {
    readonly AutoDetectChangesEnabled: boolean;
    readonly AutoSavepointsEnabled: boolean;
    readonly AutoTransactionBehavior: AutoTransactionBehavior;
    readonly CascadeDeleteTiming: CascadeTiming;
    readonly DeleteOrphansTiming: CascadeTiming;
    readonly DetectedAllChanges: EventHandler<DetectedChangesEventArgs> | undefined;
    readonly DetectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs> | undefined;
    readonly DetectingAllChanges: EventHandler<DetectChangesEventArgs> | undefined;
    readonly DetectingEntityChanges: EventHandler<DetectEntityChangesEventArgs> | undefined;
    readonly HasChangeDetectorConfiguration: boolean;
    readonly HasChangeTrackerConfiguration: boolean;
    readonly HasDatabaseConfiguration: boolean;
    readonly HasStateManagerConfiguration: boolean;
    readonly LazyLoadingEnabled: boolean;
    readonly QueryTrackingBehavior: Nullable<QueryTrackingBehavior>;
    readonly SaveChangesFailed: EventHandler<SaveChangesFailedEventArgs> | undefined;
    readonly SavedChanges: EventHandler<SavedChangesEventArgs> | undefined;
    readonly SavingChanges: EventHandler<SavingChangesEventArgs> | undefined;
    readonly StateChanged: EventHandler<EntityStateChangedEventArgs> | undefined;
    readonly StateChanging: EventHandler<EntityStateChangingEventArgs> | undefined;
    readonly Tracked: EventHandler<EntityTrackedEventArgs> | undefined;
    readonly Tracking: EventHandler<EntityTrackingEventArgs> | undefined;
}


export const DbContextPoolConfigurationSnapshot: {
    new(hasDatabaseConfiguration: boolean, hasStateManagerConfiguration: boolean, hasChangeTrackerConfiguration: boolean, hasChangeDetectorConfiguration: boolean, autoDetectChangesEnabled: boolean, queryTrackingBehavior: Nullable<QueryTrackingBehavior>, autoTransactionBehavior: AutoTransactionBehavior, autoSavepointsEnabled: boolean, lazyLoadingEnabled: boolean, cascadeDeleteTiming: CascadeTiming, deleteOrphansTiming: CascadeTiming, savingChanges: EventHandler<SavingChangesEventArgs>, savedChanges: EventHandler<SavedChangesEventArgs>, saveChangesFailed: EventHandler<SaveChangesFailedEventArgs>, tracking: EventHandler<EntityTrackingEventArgs>, tracked: EventHandler<EntityTrackedEventArgs>, stateChanging: EventHandler<EntityStateChangingEventArgs>, stateChanged: EventHandler<EntityStateChangedEventArgs>, detectingAllChanges: EventHandler<DetectChangesEventArgs>, detectedAllChanges: EventHandler<DetectedChangesEventArgs>, detectingEntityChanges: EventHandler<DetectEntityChangesEventArgs>, detectedEntityChanges: EventHandler<DetectedEntityChangesEventArgs>): DbContextPoolConfigurationSnapshot;
};


export type DbContextPoolConfigurationSnapshot = DbContextPoolConfigurationSnapshot$instance;

export interface DbContextServices$instance {
    readonly ContextOptions: DbContextOptions;
    readonly CurrentContext: ICurrentDbContext;
    readonly DesignTimeModel: IModel;
    readonly InternalServiceProvider: IServiceProvider;
    readonly Model: IModel;
    Initialize(scopedProvider: IServiceProvider, contextOptions: DbContextOptions, context: DbContext): IDbContextServices;
}


export const DbContextServices: {
    new(): DbContextServices;
};


export interface __DbContextServices$views {
    As_IDbContextServices(): IDbContextServices$instance;
}

export interface DbContextServices$instance extends IDbContextServices$instance {}

export type DbContextServices = DbContextServices$instance & __DbContextServices$views;


export interface DbSetInitializer$instance {
    InitializeSets(context: DbContext): void;
}


export const DbSetInitializer: {
    new(setFinder: IDbSetFinder, setSource: IDbSetSource): DbSetInitializer;
};


export interface __DbSetInitializer$views {
    As_IDbSetInitializer(): IDbSetInitializer$instance;
}

export interface DbSetInitializer$instance extends IDbSetInitializer$instance {}

export type DbSetInitializer = DbSetInitializer$instance & __DbSetInitializer$views;


export interface DbSetSource$instance {
    Create(context: DbContext, type: Type): unknown;
    Create(context: DbContext, name: string, type: Type): unknown;
}


export const DbSetSource: {
    new(): DbSetSource;
};


export interface __DbSetSource$views {
    As_IDbSetSource(): IDbSetSource$instance;
}

export interface DbSetSource$instance extends IDbSetSource$instance {}

export type DbSetSource = DbSetSource$instance & __DbSetSource$views;


export interface EntityFinder_1$instance<TEntity> {
    Find(keyValues: unknown[]): TEntity | undefined;
    FindAsync(keyValues: unknown[], cancellationToken?: CancellationToken): ValueTask<TEntity>;
    FindEntry<TKey>(keyValue: TKey): InternalEntityEntry | undefined;
    FindEntry<TProperty>(property: IProperty, propertyValue: TProperty): InternalEntityEntry | undefined;
    FindEntry(keyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    FindEntry(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): InternalEntityEntry | undefined;
    GetDatabaseValues(entry: InternalEntityEntry): unknown[] | undefined;
    GetDatabaseValuesAsync(entry: InternalEntityEntry, cancellationToken?: CancellationToken): Task<unknown[] | undefined>;
    GetEntries<TProperty>(property: IProperty, propertyValue: TProperty): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    GetEntries(properties: IEnumerable__System_Collections_Generic<IProperty>, propertyValues: IEnumerable__System_Collections_Generic<unknown>): IEnumerable__System_Collections_Generic<InternalEntityEntry>;
    Load(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(navigation: INavigation, entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(navigation: INavigation, entry: InternalEntityEntry): IQueryable<TEntity>;
}


export const EntityFinder_1: {
    new<TEntity>(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, entityType: IEntityType): EntityFinder_1<TEntity>;
};


export interface __EntityFinder_1$views<TEntity> {
    As_IEntityFinder(): IEntityFinder$instance;
    As_IEntityFinder_1(): IEntityFinder_1$instance<TEntity>;
}

export type EntityFinder_1<TEntity> = EntityFinder_1$instance<TEntity> & __EntityFinder_1$views<TEntity>;


export interface EntityFinderCollectionLoaderAdapter$instance {
    Load(entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(entry: InternalEntityEntry): IQueryable;
}


export const EntityFinderCollectionLoaderAdapter: {
    new(entityFinder: IEntityFinder, navigation: INavigation): EntityFinderCollectionLoaderAdapter;
};


export interface __EntityFinderCollectionLoaderAdapter$views {
    As_ICollectionLoader(): ICollectionLoader$instance;
}

export interface EntityFinderCollectionLoaderAdapter$instance extends ICollectionLoader$instance {}

export type EntityFinderCollectionLoaderAdapter = EntityFinderCollectionLoaderAdapter$instance & __EntityFinderCollectionLoaderAdapter$views;


export interface EntityFinderFactory$instance {
    Create(type: IEntityType): IEntityFinder;
}


export const EntityFinderFactory: {
    new(entityFinderSource: IEntityFinderSource, stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache): EntityFinderFactory;
};


export interface __EntityFinderFactory$views {
    As_IEntityFinderFactory(): IEntityFinderFactory$instance;
}

export interface EntityFinderFactory$instance extends IEntityFinderFactory$instance {}

export type EntityFinderFactory = EntityFinderFactory$instance & __EntityFinderFactory$views;


export interface EntityFinderSource$instance {
    Create(stateManager: IStateManager, setSource: IDbSetSource, setCache: IDbSetCache, type: IEntityType): IEntityFinder;
}


export const EntityFinderSource: {
    new(): EntityFinderSource;
};


export interface __EntityFinderSource$views {
    As_IEntityFinderSource(): IEntityFinderSource$instance;
}

export interface EntityFinderSource$instance extends IEntityFinderSource$instance {}

export type EntityFinderSource = EntityFinderSource$instance & __EntityFinderSource$views;


export interface InternalDbSet_1$instance<TEntity> extends DbSet_1<TEntity> {
    readonly EntityType: IEntityType;
    readonly Local: LocalView_1<TEntity>;
    Add(entity: TEntity): EntityEntry_1<TEntity>;
    Add(entity: TEntity): EntityEntry_1<TEntity>;
    AddAsync(entity: TEntity, cancellationToken?: CancellationToken): ValueTask<EntityEntry_1<TEntity>>;
    AddAsync(entity: TEntity, cancellationToken?: CancellationToken): ValueTask<EntityEntry_1<TEntity>>;
    AddRange(...entities: TEntity[]): void;
    AddRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    AddRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    AddRangeAsync(...entities: TEntity[]): Task;
    AddRangeAsync(entities: IEnumerable__System_Collections_Generic<TEntity>, cancellationToken?: CancellationToken): Task;
    AddRangeAsync(entities: IEnumerable__System_Collections_Generic<TEntity>, cancellationToken?: CancellationToken): Task;
    Attach(entity: TEntity): EntityEntry_1<TEntity>;
    Attach(entity: TEntity): EntityEntry_1<TEntity>;
    AttachRange(...entities: TEntity[]): void;
    AttachRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    AttachRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    Entry(entity: TEntity): EntityEntry_1<TEntity>;
    Entry(entity: TEntity): EntityEntry_1<TEntity>;
    Find(...keyValues: unknown[]): TEntity | undefined;
    FindAsync(...keyValues: unknown[]): ValueTask<TEntity>;
    FindAsync(keyValues: unknown[], cancellationToken: CancellationToken): ValueTask<TEntity>;
    FindAsync(...keyValues: unknown[]): ValueTask<TEntity>;
    FindAsync(keyValues: unknown[], cancellationToken: CancellationToken): ValueTask<TEntity>;
    Remove(entity: TEntity): EntityEntry_1<TEntity>;
    Remove(entity: TEntity): EntityEntry_1<TEntity>;
    RemoveRange(...entities: TEntity[]): void;
    RemoveRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    RemoveRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    Update(entity: TEntity): EntityEntry_1<TEntity>;
    Update(entity: TEntity): EntityEntry_1<TEntity>;
    UpdateRange(...entities: TEntity[]): void;
    UpdateRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
    UpdateRange(entities: IEnumerable__System_Collections_Generic<TEntity>): void;
}


export const InternalDbSet_1: {
    new<TEntity>(context: DbContext, entityTypeName: string): InternalDbSet_1<TEntity>;
};


export interface __InternalDbSet_1$views<TEntity> {
    As_IInfrastructure_1(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<IServiceProvider>;
    As_IResettableService(): Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance;
}

export interface InternalDbSet_1$instance<TEntity> extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IInfrastructure_1$instance<IServiceProvider>, Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type InternalDbSet_1<TEntity> = InternalDbSet_1$instance<TEntity> & __InternalDbSet_1$views<TEntity>;


export interface ManyToManyLoader_2$instance<TEntity, TSourceEntity> {
    Load(entry: InternalEntityEntry, options: LoadOptions): void;
    LoadAsync(entry: InternalEntityEntry, options: LoadOptions, cancellationToken?: CancellationToken): Task;
    Query(entry: InternalEntityEntry): IQueryable<TEntity>;
}


export const ManyToManyLoader_2: {
    new<TEntity, TSourceEntity>(skipNavigation: ISkipNavigation): ManyToManyLoader_2<TEntity, TSourceEntity>;
};


export interface __ManyToManyLoader_2$views<TEntity, TSourceEntity> {
    As_ICollectionLoader(): ICollectionLoader$instance;
    As_ICollectionLoader_1(): ICollectionLoader_1$instance<TEntity>;
}

export type ManyToManyLoader_2<TEntity, TSourceEntity> = ManyToManyLoader_2$instance<TEntity, TSourceEntity> & __ManyToManyLoader_2$views<TEntity, TSourceEntity>;


export interface ManyToManyLoaderFactory$instance {
    Create(skipNavigation: ISkipNavigation): ICollectionLoader;
}


export const ManyToManyLoaderFactory: {
    new(): ManyToManyLoaderFactory;
    readonly Instance: ManyToManyLoaderFactory;
};


export type ManyToManyLoaderFactory = ManyToManyLoaderFactory$instance;

export interface NullableComparerAdapter_1$instance<TNullableKey> {
    Equals(x: TNullableKey, y: TNullableKey): boolean;
    GetHashCode(obj: TNullableKey): int;
}


export const NullableComparerAdapter_1: {
    new<TNullableKey>(): NullableComparerAdapter_1<TNullableKey>;
    Wrap<TNullableKey>(comparer: IEqualityComparer, valueConverter?: ValueConverter): IEqualityComparer__System_Collections_Generic<TNullableKey>;
};


export type NullableComparerAdapter_1<TNullableKey> = NullableComparerAdapter_1$instance<TNullableKey>;

export interface RegisteredServices$instance {
    readonly Services: ISet<Type>;
}


export const RegisteredServices: {
    new(services: IEnumerable__System_Collections_Generic<Type>): RegisteredServices;
};


export interface __RegisteredServices$views {
    As_IRegisteredServices(): IRegisteredServices$instance;
}

export interface RegisteredServices$instance extends IRegisteredServices$instance {}

export type RegisteredServices = RegisteredServices$instance & __RegisteredServices$views;


export interface ScopedDbContextLease_1$instance<TContext extends DbContext> {
    readonly Context: TContext;
}


export const ScopedDbContextLease_1: {
    new<TContext extends DbContext>(contextPool: IDbContextPool_1<TContext>): ScopedDbContextLease_1<TContext>;
};


export interface __ScopedDbContextLease_1$views<TContext extends DbContext> {
    As_IScopedDbContextLease_1(): IScopedDbContextLease_1$instance<TContext>;
}

export interface ScopedDbContextLease_1$instance<TContext extends DbContext> extends IScopedDbContextLease_1$instance<TContext> {}

export type ScopedDbContextLease_1<TContext extends DbContext> = ScopedDbContextLease_1$instance<TContext> & __ScopedDbContextLease_1$views<TContext>;


export interface SemanticVersionComparer$instance {
    Compare(x: string, y: string): int;
}


export const SemanticVersionComparer: {
    new(): SemanticVersionComparer;
};


export type SemanticVersionComparer = SemanticVersionComparer$instance;

export interface ServiceProviderCache$instance {
    GetOrAdd(options: IDbContextOptions, providerRequired: boolean): IServiceProvider;
}


export const ServiceProviderCache: {
    new(): ServiceProviderCache;
    readonly Instance: ServiceProviderCache;
};


export type ServiceProviderCache = ServiceProviderCache$instance;

export interface SingletonOptionsInitializer$instance {
    EnsureInitialized(serviceProvider: IServiceProvider, options: IDbContextOptions): void;
}


export const SingletonOptionsInitializer: {
    new(): SingletonOptionsInitializer;
};


export interface __SingletonOptionsInitializer$views {
    As_ISingletonOptionsInitializer(): ISingletonOptionsInitializer$instance;
}

export interface SingletonOptionsInitializer$instance extends ISingletonOptionsInitializer$instance {}

export type SingletonOptionsInitializer = SingletonOptionsInitializer$instance & __SingletonOptionsInitializer$views;


export interface TypeFullNameComparer$instance {
    Compare(x: Type, y: Type): int;
    Equals(x: Type, y: Type): boolean;
    GetHashCode(obj: Type): int;
}


export const TypeFullNameComparer: {
    new(): TypeFullNameComparer;
    readonly Instance: TypeFullNameComparer;
};


export type TypeFullNameComparer = TypeFullNameComparer$instance;

export abstract class DbContextDependenciesExtensions$instance {
    static GetDependencies(currentContext: ICurrentDbContext): IDbContextDependencies;
    static GetDependencies(context: IDbContextDependencies): IDbContextDependencies;
}


export type DbContextDependenciesExtensions = DbContextDependenciesExtensions$instance;

export abstract class DbContextExtensions$instance {
    static ConfigureConventions(context: DbContext, configurationBuilder: ModelConfigurationBuilder): void;
}


export type DbContextExtensions = DbContextExtensions$instance;

export abstract class EntityTypeExtensions$instance {
    static IsAdHoc(entityType: IEntityType): boolean;
}


export type EntityTypeExtensions = EntityTypeExtensions$instance;

export abstract class ExpressionExtensions$instance {
    static BuildPredicate(keyProperties: IReadOnlyList<IReadOnlyProperty>, keyValues: ValueBuffer, entityParameter: ParameterExpression): Expression;
    static GetLambdaOrNull(expression: Expression): LambdaExpression | undefined;
    static IsLogicalNot(sqlUnaryExpression: UnaryExpression): boolean;
    static IsLogicalOperation(expression: Expression): boolean;
    static MakeHasSentinel(currentValueExpression: Expression, propertyBase: IReadOnlyPropertyBase): Expression;
    static MatchMemberAccessList<TMemberInfo extends MemberInfo>(lambdaExpression: LambdaExpression, memberMatcher: Func<Expression, Expression, TMemberInfo>): IReadOnlyList<TMemberInfo> | undefined;
    static MatchSimpleMemberAccess<TMemberInfo extends MemberInfo>(parameterExpression: Expression, memberAccessExpression: Expression): TMemberInfo | undefined;
    static RemoveTypeAs(expression: Expression): Expression | undefined;
}


export type ExpressionExtensions = ExpressionExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static MethodIsClosedFormOf(methodInfo: MethodInfo, genericMethod: MethodInfo): boolean;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class MethodInfoExtensions2$instance {
    static DisplayName(methodInfo: MethodInfo): string;
}


export type MethodInfoExtensions2 = MethodInfoExtensions2$instance;

export abstract class RelationalCommandResolverExtensions$instance {
    static RentAndPopulateRelationalCommand(relationalCommandResolver: RelationalCommandResolver, queryContext: RelationalQueryContext): IRelationalCommand;
}


export type RelationalCommandResolverExtensions = RelationalCommandResolverExtensions$instance;

export abstract class RelationalModelExtensions$instance {
    static EnsureRelationalModel(model: IModel): void;
}


export type RelationalModelExtensions = RelationalModelExtensions$instance;

export abstract class TupleExtensions$instance {
    static FormatTable(table: ValueTuple<System_Internal.String, System_Internal.String>): string;
    static FormatTables(tables: IEnumerable__System_Collections_Generic<ValueTuple<System_Internal.String, System_Internal.String>>): string;
}


export type TupleExtensions = TupleExtensions$instance;

export abstract class TypeBaseExtensions$instance {
    static DisplayName(entityType: TypeBase): string;
    static GetComplexProperty(type: ITypeBase, name: string): IComplexProperty;
    static GetOwnedName(type: IReadOnlyTypeBase, simpleName: string, ownershipNavigation: string): string;
    static GetRuntimeFields(type: IReadOnlyTypeBase): IReadOnlyDictionary<System_Internal.String, FieldInfo>;
    static GetRuntimeProperties(type: IReadOnlyTypeBase): IReadOnlyDictionary<System_Internal.String, PropertyInfo>;
    static ShortName(entityType: TypeBase): string;
}


export type TypeBaseExtensions = TypeBaseExtensions$instance;

export abstract class TypeExtensions$instance {
    static FindIndexerProperty(type: Type): PropertyInfo | undefined;
    static GenerateParameterName(type: Type): string;
    static GetFieldInfo(type: Type, fieldName: string): FieldInfo | undefined;
    static IsDefaultValue(type: Type, value: unknown): boolean;
}


export type TypeExtensions = TypeExtensions$instance;

