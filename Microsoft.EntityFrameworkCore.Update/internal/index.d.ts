// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Update
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { CascadeTiming, ChangeTrackerDebugStringOptions, EntityEntry } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IDiagnosticsLogger_1, IRelationalCommandDiagnosticsLogger } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IAnnotatable, ICurrentDbContext, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IColumn, IColumnBase, IComplexProperty, IEntityType, IForeignKey, IKey, IModel, IProperty, IPropertyBase, IStoreStoredProcedure, ITable } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IRelationalCommandBuilderFactory, IRelationalConnection, IRelationalTypeMappingSource, ISqlGenerationHelper, RelationalDataReader, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { DbContext, DbLoggerCategory_Update, EntityState } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { IComparer, IDictionary, IEnumerable, IEqualityComparer, IList, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbParameterCollection } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Enum, Func, IComparable, IConvertible, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum ResultSetMapping {
    noResults = 0,
    hasResultRow = 1,
    notLastInResultSet = 3,
    lastInResultSet = 5,
    resultSetWithRowsAffectedOnly = 9,
    isPositionalResultMappingEnabled = 17,
    hasOutputParameters = 32
}


export interface IBatchExecutor$instance {
    execute(commandBatches: IEnumerable<ModificationCommandBatch>, connection: IRelationalConnection): int;
    executeAsync(commandBatches: IEnumerable<ModificationCommandBatch>, connection: IRelationalConnection, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export type IBatchExecutor = IBatchExecutor$instance;

export interface IColumnModification$instance {
    readonly entry: IUpdateEntry;
    readonly property: IProperty;
    readonly column: IColumnBase;
    readonly typeMapping: RelationalTypeMapping;
    readonly isNullable: Nullable<System_Internal.Boolean>;
    isRead: boolean;
    isWrite: boolean;
    isCondition: boolean;
    isKey: boolean;
    readonly useOriginalValueParameter: boolean;
    readonly useCurrentValueParameter: boolean;
    readonly useOriginalValue: boolean;
    readonly useCurrentValue: boolean;
    readonly useParameter: boolean;
    readonly parameterName: string | undefined;
    readonly originalParameterName: string | undefined;
    readonly columnName: string;
    readonly columnType: string | undefined;
    originalValue: unknown;
    get value(): unknown | undefined;
    set value(value: unknown);
    readonly jsonPath: string | undefined;
    addSharedColumnModification(modification: IColumnModification): void;
    resetParameterNames(): void;
}


export type IColumnModification = IColumnModification$instance;

export interface ICommandBatchPreparer$instance extends IResettableService {
    batchCommands(entries: IList<IUpdateEntry>, updateAdapter: IUpdateAdapter): IEnumerable<ModificationCommandBatch>;
    createCommandBatches(commandSet: IEnumerable<IReadOnlyModificationCommand>, moreCommandSets: boolean): IEnumerable<ModificationCommandBatch>;
    resetState(): void;
    resetStateAsync(cancellationToken?: CancellationToken): Task;
}


export interface ICommandBatchPreparer$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type ICommandBatchPreparer = ICommandBatchPreparer$instance;

export interface IModificationCommand$instance extends IReadOnlyModificationCommand {
    readonly table: ITable;
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly tableName: string;
    readonly schema: string;
    readonly columnModifications: IReadOnlyList<IColumnModification>;
    readonly entries: IReadOnlyList<IUpdateEntry>;
    readonly entityState: EntityState;
    readonly rowsAffectedColumn: IColumnBase | undefined;
    addEntry(entry: IUpdateEntry, mainEntry: boolean): void;
    propagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    propagateResults(relationalReader: RelationalDataReader): void;
}


export interface IModificationCommand$instance extends IReadOnlyModificationCommand$instance {}

export type IModificationCommand = IModificationCommand$instance;

export interface IModificationCommandBatchFactory$instance {
    create(): ModificationCommandBatch;
}


export type IModificationCommandBatchFactory = IModificationCommandBatchFactory$instance;

export interface IModificationCommandFactory$instance {
    createModificationCommand(modificationCommandParameters: ModificationCommandParameters): IModificationCommand;
    createNonTrackedModificationCommand(modificationCommandParameters: NonTrackedModificationCommandParameters): INonTrackedModificationCommand;
}


export type IModificationCommandFactory = IModificationCommandFactory$instance;

export interface INonTrackedModificationCommand$instance extends IReadOnlyModificationCommand {
    entityState: EntityState;
    readonly table: ITable;
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly tableName: string;
    readonly schema: string;
    readonly columnModifications: IReadOnlyList<IColumnModification>;
    readonly entries: IReadOnlyList<IUpdateEntry>;
    readonly rowsAffectedColumn: IColumnBase | undefined;
    addColumnModification(columnModificationParameters: ColumnModificationParameters): IColumnModification;
    propagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    propagateResults(relationalReader: RelationalDataReader): void;
}


export type INonTrackedModificationCommand = INonTrackedModificationCommand$instance;

export interface IReadOnlyModificationCommand$instance {
    readonly table: ITable;
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly tableName: string;
    readonly schema: string;
    readonly columnModifications: IReadOnlyList<IColumnModification>;
    readonly entries: IReadOnlyList<IUpdateEntry>;
    readonly entityState: EntityState;
    readonly rowsAffectedColumn: IColumnBase | undefined;
    propagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    propagateResults(relationalReader: RelationalDataReader): void;
}


export type IReadOnlyModificationCommand = IReadOnlyModificationCommand$instance;

export interface IUpdateAdapter$instance {
    deleteOrphansTiming: CascadeTiming;
    cascadeDeleteTiming: CascadeTiming;
    readonly entries: IEnumerable<IUpdateEntry>;
    readonly model: IModel;
    cascadeDelete(entry: IUpdateEntry, foreignKeys?: IEnumerable<IForeignKey>): void;
    createEntry(values: IDictionary<System_Internal.String, unknown>, entityType: IEntityType): IUpdateEntry;
    detectChanges(): void;
    findPrincipal(dependentEntry: IUpdateEntry, foreignKey: IForeignKey): IUpdateEntry | undefined;
    getDependents(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable<IUpdateEntry>;
    getEntriesToSave(): IList<IUpdateEntry>;
    tryGetEntry(key: IKey, keyValues: unknown[]): IUpdateEntry | undefined;
}


export type IUpdateAdapter = IUpdateAdapter$instance;

export interface IUpdateAdapterFactory$instance {
    create(): IUpdateAdapter;
    createStandalone(model?: IModel): IUpdateAdapter;
}


export type IUpdateAdapterFactory = IUpdateAdapterFactory$instance;

export interface IUpdateEntry$instance {
    readonly context: DbContext;
    readonly entityType: IEntityType;
    entityState: EntityState;
    readonly sharedIdentityEntry: IUpdateEntry | undefined;
    canHaveOriginalValue(propertyBase: IPropertyBase): boolean;
    getCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    getCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    getOriginalValue<TProperty>(property: IProperty): TProperty;
    isModified(property: IComplexProperty): boolean;
    isModified(property: IProperty): boolean;
    setOriginalValue(property: IProperty, value: unknown): void;
    setPropertyModified(property: IProperty): void;
    setStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
    toEntityEntry(): EntityEntry;
}


export type IUpdateEntry = IUpdateEntry$instance;

export interface IUpdateSqlGenerator$instance {
    appendBatchHeader(commandStringBuilder: StringBuilder): void;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    appendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    generateNextSequenceValueOperation(name: string, schema: string): string;
}


export type IUpdateSqlGenerator = IUpdateSqlGenerator$instance;

export interface ColumnModificationParameters$instance {
    column: IColumnBase;
    columnName: string;
    get columnType(): string | undefined;
    set columnType(value: string);
    get entry(): IUpdateEntry | undefined;
    set entry(value: IUpdateEntry);
    get generateParameterName(): Func<System_Internal.String> | undefined;
    set generateParameterName(value: Func<System_Internal.String>);
    isCondition: boolean;
    isKey: boolean;
    isNullable: Nullable<System_Internal.Boolean>;
    isRead: boolean;
    isWrite: boolean;
    get jsonPath(): string | undefined;
    set jsonPath(value: string);
    get originalValue(): unknown | undefined;
    set originalValue(value: unknown);
    get property(): IProperty | undefined;
    set property(value: IProperty);
    sensitiveLoggingEnabled: boolean;
    get typeMapping(): RelationalTypeMapping | undefined;
    set typeMapping(value: RelationalTypeMapping);
    value: unknown;
    equals(obj: unknown): boolean;
    equals(other: ColumnModificationParameters): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const ColumnModificationParameters: {
    new(columnName: string, originalValue: unknown, value: unknown, property: IProperty, columnType: string, typeMapping: RelationalTypeMapping, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
    new(column: IColumn, originalValue: unknown, value: unknown, property: IProperty, typeMapping: RelationalTypeMapping, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
    new(entry: IUpdateEntry, property: IProperty, column: IColumnBase, generateParameterName: Func<System_Internal.String>, typeMapping: RelationalTypeMapping, valueIsRead: boolean, valueIsWrite: boolean, columnIsKey: boolean, columnIsCondition: boolean, sensitiveLoggingEnabled: boolean): ColumnModificationParameters;
    new(columnName: string, value: unknown, property: IProperty, columnType: string, typeMapping: RelationalTypeMapping, jsonPath: string, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
};


export type ColumnModificationParameters = ColumnModificationParameters$instance;

export interface ModificationCommandParameters$instance {
    get comparer(): IComparer<IUpdateEntry> | undefined;
    set comparer(value: IComparer<IUpdateEntry>);
    detailedErrorsEnabled: boolean;
    get generateParameterName(): Func<System_Internal.String> | undefined;
    set generateParameterName(value: Func<System_Internal.String>);
    logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    get schema(): string | undefined;
    set schema(value: string);
    sensitiveLoggingEnabled: boolean;
    readonly storeStoredProcedure: IStoreStoredProcedure | undefined;
    get table(): ITable | undefined;
    set table(value: ITable);
    tableName: string;
    equals(obj: unknown): boolean;
    equals(other: ModificationCommandParameters): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const ModificationCommandParameters: {
    new(table: ITable, storeStoredProcedure: IStoreStoredProcedure, sensitiveLoggingEnabled: boolean, detailedErrorsEnabled: boolean, comparer: IComparer<IUpdateEntry>, generateParameterName: Func<System_Internal.String>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandParameters;
    new(table: ITable, sensitiveLoggingEnabled: boolean, detailedErrorsEnabled: boolean, comparer: IComparer<IUpdateEntry>, generateParameterName: Func<System_Internal.String>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandParameters;
};


export type ModificationCommandParameters = ModificationCommandParameters$instance;

export interface NonTrackedModificationCommandParameters$instance {
    get schema(): string | undefined;
    set schema(value: string);
    sensitiveLoggingEnabled: boolean;
    get table(): ITable | undefined;
    set table(value: ITable);
    tableName: string;
    equals(obj: unknown): boolean;
    equals(other: NonTrackedModificationCommandParameters): boolean;
    getHashCode(): int;
    toString(): string | undefined;
}


export const NonTrackedModificationCommandParameters: {
    new(tableName: string, schemaName: string, sensitiveLoggingEnabled: boolean): NonTrackedModificationCommandParameters;
    new(table: ITable, sensitiveLoggingEnabled: boolean): NonTrackedModificationCommandParameters;
};


export type NonTrackedModificationCommandParameters = NonTrackedModificationCommandParameters$instance;

export interface AffectedCountModificationCommandBatch$instance extends ReaderModificationCommandBatch {
}


export const AffectedCountModificationCommandBatch: {
};


export type AffectedCountModificationCommandBatch = AffectedCountModificationCommandBatch$instance;

export interface ColumnModification$instance {
    readonly column: IColumnBase;
    readonly columnName: string;
    readonly columnType: string | undefined;
    readonly entry: IUpdateEntry;
    isCondition: boolean;
    isKey: boolean;
    readonly isNullable: Nullable<System_Internal.Boolean>;
    isRead: boolean;
    isWrite: boolean;
    readonly jsonPath: string | undefined;
    readonly originalParameterName: string | undefined;
    originalValue: unknown;
    readonly parameterName: string | undefined;
    readonly property: IProperty;
    readonly typeMapping: RelationalTypeMapping;
    readonly useCurrentValue: boolean;
    readonly useCurrentValueParameter: boolean;
    readonly useOriginalValue: boolean;
    readonly useOriginalValueParameter: boolean;
    readonly useParameter: boolean;
    get value(): unknown | undefined;
    set value(value: unknown);
    addSharedColumnModification(modification: IColumnModification): void;
    resetParameterNames(): void;
}


export const ColumnModification: {
    new(columnModificationParameters: ColumnModificationParameters): ColumnModification;
    getCurrentProviderValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    getCurrentValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    getOriginalProviderValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    getOriginalValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    isModified(entry: IUpdateEntry, property: IProperty): boolean;
    isStoreGenerated(entry: IUpdateEntry, property: IProperty): boolean;
    setStoreGeneratedValue(entry: IUpdateEntry, property: IProperty, value: unknown): void;
};


export interface __ColumnModification$views {
    As_IColumnModification(): IColumnModification$instance;
}

export interface ColumnModification$instance extends IColumnModification$instance {}

export type ColumnModification = ColumnModification$instance & __ColumnModification$views;


export interface EquatableKeyValue_1$instance<TKey> {
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const EquatableKeyValue_1: {
    new<TKey>(metadata: IAnnotatable, keyValue: TKey, keyComparer: IEqualityComparer<TKey>): EquatableKeyValue_1<TKey>;
};


export type EquatableKeyValue_1<TKey> = EquatableKeyValue_1$instance<TKey>;

export interface ModificationCommand$instance {
    readonly columnModifications: IReadOnlyList<IColumnModification>;
    entityState: EntityState;
    readonly entries: IReadOnlyList<IUpdateEntry>;
    readonly rowsAffectedColumn: IColumnBase | undefined;
    readonly schema: string;
    readonly storeStoredProcedure: IStoreStoredProcedure;
    readonly table: ITable;
    readonly tableName: string;
    addColumnModification(columnModificationParameters: ColumnModificationParameters): IColumnModification;
    addEntry(entry: IUpdateEntry, mainEntry: boolean): void;
    assertColumnsNotInitialized(): void;
    propagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    propagateResults(relationalReader: RelationalDataReader): void;
    toString(): string;
}


export const ModificationCommand: {
    new(modificationCommandParameters: ModificationCommandParameters): ModificationCommand;
    new(modificationCommandParameters: NonTrackedModificationCommandParameters): ModificationCommand;
};


export interface __ModificationCommand$views {
    As_IModificationCommand(): IModificationCommand$instance;
    As_INonTrackedModificationCommand(): INonTrackedModificationCommand$instance;
    As_IReadOnlyModificationCommand(): IReadOnlyModificationCommand$instance;
}

export type ModificationCommand = ModificationCommand$instance & __ModificationCommand$views;


export interface ModificationCommandBatch$instance {
    readonly areMoreBatchesExpected: boolean;
    readonly modificationCommands: IReadOnlyList<IReadOnlyModificationCommand>;
    readonly requiresTransaction: boolean;
    complete(moreBatchesExpected: boolean): void;
    execute(connection: IRelationalConnection): void;
    executeAsync(connection: IRelationalConnection, cancellationToken?: CancellationToken): Task;
    tryAddCommand(modificationCommand: IReadOnlyModificationCommand): boolean;
}


export const ModificationCommandBatch: {
};


export type ModificationCommandBatch = ModificationCommandBatch$instance;

export interface ModificationCommandBatchFactoryDependencies$instance {
    commandBuilderFactory: IRelationalCommandBuilderFactory;
    currentContext: ICurrentDbContext;
    logger: IRelationalCommandDiagnosticsLogger;
    sqlGenerationHelper: ISqlGenerationHelper;
    readonly updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    updateSqlGenerator: IUpdateSqlGenerator;
    _Clone_$(): ModificationCommandBatchFactoryDependencies;
    equals(obj: unknown): boolean;
    equals(other: ModificationCommandBatchFactoryDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const ModificationCommandBatchFactoryDependencies: {
    new(commandBuilderFactory: IRelationalCommandBuilderFactory, sqlGenerationHelper: ISqlGenerationHelper, updateSqlGenerator: IUpdateSqlGenerator, currentContext: ICurrentDbContext, logger: IRelationalCommandDiagnosticsLogger, updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandBatchFactoryDependencies;
};


export type ModificationCommandBatchFactoryDependencies = ModificationCommandBatchFactoryDependencies$instance;

export interface ReaderModificationCommandBatch$instance extends ModificationCommandBatch {
    readonly areMoreBatchesExpected: boolean;
    readonly modificationCommands: IReadOnlyList<IReadOnlyModificationCommand>;
    readonly requiresTransaction: boolean;
    complete(moreBatchesExpected: boolean): void;
    execute(connection: IRelationalConnection): void;
    executeAsync(connection: IRelationalConnection, cancellationToken?: CancellationToken): Task;
    tryAddCommand(modificationCommand: IReadOnlyModificationCommand): boolean;
}


export const ReaderModificationCommandBatch: {
};


export type ReaderModificationCommandBatch = ReaderModificationCommandBatch$instance;

export interface SingularModificationCommandBatch$instance extends AffectedCountModificationCommandBatch {
}


export const SingularModificationCommandBatch: {
    new(dependencies: ModificationCommandBatchFactoryDependencies): SingularModificationCommandBatch;
};


export type SingularModificationCommandBatch = SingularModificationCommandBatch$instance;

export interface UpdateAndSelectSqlGenerator$instance extends UpdateSqlGenerator$instance {
    appendBatchHeader(commandStringBuilder: StringBuilder): void;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    appendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    appendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    appendStoredProcedureCall(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    generateNextSequenceValueOperation(name: string, schema: string): string;
}


export const UpdateAndSelectSqlGenerator: {
};


export interface __UpdateAndSelectSqlGenerator$views {
    As_IUpdateSqlGenerator(): IUpdateSqlGenerator$instance;
}

export type UpdateAndSelectSqlGenerator = UpdateAndSelectSqlGenerator$instance & __UpdateAndSelectSqlGenerator$views;


export interface UpdateSqlGenerator$instance {
    appendBatchHeader(commandStringBuilder: StringBuilder): void;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    appendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    appendInsertReturningOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    appendObtainNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    appendStoredProcedureCall(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    appendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    generateNextSequenceValueOperation(name: string, schema: string): string;
    generateObtainNextSequenceValueOperation(name: string, schema: string): string;
    prependEnsureAutocommit(commandStringBuilder: StringBuilder): void;
}


export const UpdateSqlGenerator: {
};


export interface __UpdateSqlGenerator$views {
    As_IUpdateSqlGenerator(): IUpdateSqlGenerator$instance;
}

export interface UpdateSqlGenerator$instance extends IUpdateSqlGenerator$instance {}

export type UpdateSqlGenerator = UpdateSqlGenerator$instance & __UpdateSqlGenerator$views;


export interface UpdateSqlGeneratorDependencies$instance {
    sqlGenerationHelper: ISqlGenerationHelper;
    typeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): UpdateSqlGeneratorDependencies;
    equals(obj: unknown): boolean;
    equals(other: UpdateSqlGeneratorDependencies): boolean;
    getHashCode(): int;
    toString(): string;
}


export const UpdateSqlGeneratorDependencies: {
    new(sqlGenerationHelper: ISqlGenerationHelper, typeMappingSource: IRelationalTypeMappingSource): UpdateSqlGeneratorDependencies;
};


export type UpdateSqlGeneratorDependencies = UpdateSqlGeneratorDependencies$instance;

export abstract class UpdateEntryExtensions$instance {
    static buildCurrentValuesString(entry: IUpdateEntry, properties: IEnumerable<IPropertyBase>): string;
    static buildOriginalValuesString(entry: IUpdateEntry, properties: IEnumerable<IPropertyBase>): string;
    static getCurrentProviderValue(updateEntry: IUpdateEntry, property: IProperty): unknown | undefined;
    static getOriginalProviderValue(updateEntry: IUpdateEntry, property: IProperty): unknown | undefined;
    static toDebugString(updateEntry: IUpdateEntry, options?: ChangeTrackerDebugStringOptions, indent?: int): string;
}


export type UpdateEntryExtensions = UpdateEntryExtensions$instance;

