// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Update
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { CascadeTiming, ChangeTrackerDebugStringOptions, EntityEntry } from "../../Microsoft.EntityFrameworkCore.ChangeTracking/internal/index.js";
import type { IDiagnosticsLogger_1, IRelationalCommandDiagnosticsLogger } from "../../Microsoft.EntityFrameworkCore.Diagnostics/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Infrastructure_Internal from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IAnnotatable, ICurrentDbContext, IResettableService } from "../../Microsoft.EntityFrameworkCore.Infrastructure/internal/index.js";
import type { IColumn, IColumnBase, IComplexProperty, IEntityType, IForeignKey, IKey, IModel, IProperty, IPropertyBase, IStoreStoredProcedure, ITable } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { IRelationalCommandBuilder, IRelationalCommandBuilderFactory, IRelationalConnection, IRelationalTypeMappingSource, ISqlGenerationHelper, RawSqlCommand, RelationalDataReader, RelationalTypeMapping } from "../../Microsoft.EntityFrameworkCore.Storage/internal/index.js";
import type { DbContext, DbLoggerCategory_Update, EntityState } from "../../Microsoft.EntityFrameworkCore/internal/index.js";
import type { Dictionary, IComparer, IDictionary, IEnumerable, IEqualityComparer, IList, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbParameterCollection } from "@tsonic/dotnet/System.Data.Common.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Enum, Func, IComparable, IConvertible, IEquatable, IFormattable, Int32, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum ResultSetMapping {
    NoResults = 0,
    HasResultRow = 1,
    NotLastInResultSet = 3,
    LastInResultSet = 5,
    ResultSetWithRowsAffectedOnly = 9,
    IsPositionalResultMappingEnabled = 17,
    HasOutputParameters = 32
}


export interface IBatchExecutor$instance {
    Execute(commandBatches: IEnumerable<ModificationCommandBatch>, connection: IRelationalConnection): int;
    ExecuteAsync(commandBatches: IEnumerable<ModificationCommandBatch>, connection: IRelationalConnection, cancellationToken?: CancellationToken): Task<System_Internal.Int32>;
}


export type IBatchExecutor = IBatchExecutor$instance;

export interface IColumnModification$instance {
    readonly Entry: IUpdateEntry | undefined;
    readonly Property: IProperty | undefined;
    readonly Column: IColumnBase | undefined;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly IsNullable: Nullable<System_Internal.Boolean>;
    IsRead: boolean;
    IsWrite: boolean;
    IsCondition: boolean;
    IsKey: boolean;
    readonly UseOriginalValueParameter: boolean;
    readonly UseCurrentValueParameter: boolean;
    readonly UseOriginalValue: boolean;
    readonly UseCurrentValue: boolean;
    readonly UseParameter: boolean;
    readonly ParameterName: string | undefined;
    readonly OriginalParameterName: string | undefined;
    readonly ColumnName: string;
    readonly ColumnType: string | undefined;
    get OriginalValue(): unknown | undefined;
    set OriginalValue(value: unknown | undefined);
    get Value(): unknown | undefined;
    set Value(value: unknown | undefined);
    readonly JsonPath: string | undefined;
    AddSharedColumnModification(modification: IColumnModification): void;
    ResetParameterNames(): void;
}


export type IColumnModification = IColumnModification$instance;

export interface ICommandBatchPreparer$instance extends IResettableService {
    BatchCommands(entries: IList<IUpdateEntry>, updateAdapter: IUpdateAdapter): IEnumerable<ModificationCommandBatch>;
    CreateCommandBatches(commandSet: IEnumerable<IReadOnlyModificationCommand>, moreCommandSets: boolean): IEnumerable<ModificationCommandBatch>;
    ResetState(): void;
    ResetStateAsync(cancellationToken?: CancellationToken): Task;
}


export interface ICommandBatchPreparer$instance extends Microsoft_EntityFrameworkCore_Infrastructure_Internal.IResettableService$instance {}

export type ICommandBatchPreparer = ICommandBatchPreparer$instance;

export interface IModificationCommand$instance extends IReadOnlyModificationCommand {
    readonly Table: ITable | undefined;
    readonly StoreStoredProcedure: IStoreStoredProcedure | undefined;
    readonly TableName: string;
    readonly Schema: string | undefined;
    readonly ColumnModifications: IReadOnlyList<IColumnModification>;
    readonly Entries: IReadOnlyList<IUpdateEntry>;
    readonly EntityState: EntityState;
    readonly RowsAffectedColumn: IColumnBase | undefined;
    AddEntry(entry: IUpdateEntry, mainEntry: boolean): void;
    PropagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    PropagateResults(relationalReader: RelationalDataReader): void;
}


export interface IModificationCommand$instance extends IReadOnlyModificationCommand$instance {}

export type IModificationCommand = IModificationCommand$instance;

export interface IModificationCommandBatchFactory$instance {
    Create(): ModificationCommandBatch;
}


export type IModificationCommandBatchFactory = IModificationCommandBatchFactory$instance;

export interface IModificationCommandFactory$instance {
    CreateModificationCommand(modificationCommandParameters: ModificationCommandParameters): IModificationCommand;
    CreateNonTrackedModificationCommand(modificationCommandParameters: NonTrackedModificationCommandParameters): INonTrackedModificationCommand;
}


export type IModificationCommandFactory = IModificationCommandFactory$instance;

export interface INonTrackedModificationCommand$instance extends IReadOnlyModificationCommand {
    EntityState: EntityState;
    readonly Table: ITable | undefined;
    readonly StoreStoredProcedure: IStoreStoredProcedure | undefined;
    readonly TableName: string;
    readonly Schema: string | undefined;
    readonly ColumnModifications: IReadOnlyList<IColumnModification>;
    readonly Entries: IReadOnlyList<IUpdateEntry>;
    readonly RowsAffectedColumn: IColumnBase | undefined;
    AddColumnModification(columnModificationParameters: ColumnModificationParameters): IColumnModification;
    PropagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    PropagateResults(relationalReader: RelationalDataReader): void;
}


export type INonTrackedModificationCommand = INonTrackedModificationCommand$instance;

export interface IReadOnlyModificationCommand$instance {
    readonly Table: ITable | undefined;
    readonly StoreStoredProcedure: IStoreStoredProcedure | undefined;
    readonly TableName: string;
    readonly Schema: string | undefined;
    readonly ColumnModifications: IReadOnlyList<IColumnModification>;
    readonly Entries: IReadOnlyList<IUpdateEntry>;
    readonly EntityState: EntityState;
    readonly RowsAffectedColumn: IColumnBase | undefined;
    PropagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    PropagateResults(relationalReader: RelationalDataReader): void;
}


export type IReadOnlyModificationCommand = IReadOnlyModificationCommand$instance;

export interface IUpdateAdapter$instance {
    DeleteOrphansTiming: CascadeTiming;
    CascadeDeleteTiming: CascadeTiming;
    readonly Entries: IEnumerable<IUpdateEntry>;
    readonly Model: IModel;
    CascadeDelete(entry: IUpdateEntry, foreignKeys?: IEnumerable<IForeignKey>): void;
    CreateEntry(values: IDictionary<System_Internal.String, unknown>, entityType: IEntityType): IUpdateEntry;
    DetectChanges(): void;
    FindPrincipal(dependentEntry: IUpdateEntry, foreignKey: IForeignKey): IUpdateEntry | undefined;
    GetDependents(principalEntry: IUpdateEntry, foreignKey: IForeignKey): IEnumerable<IUpdateEntry>;
    GetEntriesToSave(): IList<IUpdateEntry>;
    TryGetEntry(key: IKey, keyValues: unknown[]): IUpdateEntry | undefined;
}


export type IUpdateAdapter = IUpdateAdapter$instance;

export interface IUpdateAdapterFactory$instance {
    Create(): IUpdateAdapter;
    CreateStandalone(model?: IModel): IUpdateAdapter;
}


export type IUpdateAdapterFactory = IUpdateAdapterFactory$instance;

export interface IUpdateEntry$instance {
    readonly Context: DbContext;
    readonly EntityType: IEntityType;
    EntityState: EntityState;
    readonly SharedIdentityEntry: IUpdateEntry | undefined;
    CanHaveOriginalValue(propertyBase: IPropertyBase): boolean;
    GetCurrentValue(propertyBase: IPropertyBase): unknown | undefined;
    GetCurrentValue<TProperty>(propertyBase: IPropertyBase): TProperty;
    GetOriginalValue<TProperty>(property: IProperty): TProperty;
    IsModified(property: IComplexProperty): boolean;
    IsModified(property: IProperty): boolean;
    SetOriginalValue(property: IProperty, value: unknown): void;
    SetPropertyModified(property: IProperty): void;
    SetStoreGeneratedValue(property: IProperty, value: unknown, setModified?: boolean): void;
    ToEntityEntry(): EntityEntry;
}


export type IUpdateEntry = IUpdateEntry$instance;

export interface IUpdateSqlGenerator$instance {
    AppendBatchHeader(commandStringBuilder: StringBuilder): void;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    GenerateNextSequenceValueOperation(name: string, schema: string): string;
}


export type IUpdateSqlGenerator = IUpdateSqlGenerator$instance;

export interface ColumnModificationParameters$instance {
    get Column(): IColumnBase | undefined;
    set Column(value: IColumnBase | undefined);
    ColumnName: string;
    get ColumnType(): string | undefined;
    set ColumnType(value: string | undefined);
    get Entry(): IUpdateEntry | undefined;
    set Entry(value: IUpdateEntry | undefined);
    get GenerateParameterName(): Func<System_Internal.String> | undefined;
    set GenerateParameterName(value: Func<System_Internal.String> | undefined);
    IsCondition: boolean;
    IsKey: boolean;
    IsNullable: Nullable<System_Internal.Boolean>;
    IsRead: boolean;
    IsWrite: boolean;
    get JsonPath(): string | undefined;
    set JsonPath(value: string | undefined);
    get OriginalValue(): unknown | undefined;
    set OriginalValue(value: unknown | undefined);
    get Property(): IProperty | undefined;
    set Property(value: IProperty | undefined);
    SensitiveLoggingEnabled: boolean;
    get TypeMapping(): RelationalTypeMapping | undefined;
    set TypeMapping(value: RelationalTypeMapping | undefined);
    get Value(): unknown | undefined;
    set Value(value: unknown | undefined);
    Equals(obj: unknown): boolean;
    Equals(other: ColumnModificationParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ColumnModificationParameters: {
    new(columnName: string, originalValue: unknown, value: unknown, property: IProperty, columnType: string, typeMapping: RelationalTypeMapping, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
    new(column: IColumn, originalValue: unknown, value: unknown, property: IProperty, typeMapping: RelationalTypeMapping, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
    new(entry: IUpdateEntry, property: IProperty, column: IColumnBase, generateParameterName: Func<System_Internal.String>, typeMapping: RelationalTypeMapping, valueIsRead: boolean, valueIsWrite: boolean, columnIsKey: boolean, columnIsCondition: boolean, sensitiveLoggingEnabled: boolean): ColumnModificationParameters;
    new(columnName: string, value: unknown, property: IProperty, columnType: string, typeMapping: RelationalTypeMapping, jsonPath: string, read: boolean, write: boolean, key: boolean, condition: boolean, sensitiveLoggingEnabled: boolean, isNullable: Nullable<System_Internal.Boolean>): ColumnModificationParameters;
};


export type ColumnModificationParameters = ColumnModificationParameters$instance;

export interface ModificationCommandParameters$instance {
    get Comparer(): IComparer<IUpdateEntry> | undefined;
    set Comparer(value: IComparer<IUpdateEntry> | undefined);
    DetailedErrorsEnabled: boolean;
    get GenerateParameterName(): Func<System_Internal.String> | undefined;
    set GenerateParameterName(value: Func<System_Internal.String> | undefined);
    get Logger(): IDiagnosticsLogger_1<DbLoggerCategory_Update> | undefined;
    set Logger(value: IDiagnosticsLogger_1<DbLoggerCategory_Update> | undefined);
    get Schema(): string | undefined;
    set Schema(value: string | undefined);
    SensitiveLoggingEnabled: boolean;
    readonly StoreStoredProcedure: IStoreStoredProcedure | undefined;
    get Table(): ITable | undefined;
    set Table(value: ITable | undefined);
    TableName: string;
    Equals(obj: unknown): boolean;
    Equals(other: ModificationCommandParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModificationCommandParameters: {
    new(table: ITable, storeStoredProcedure: IStoreStoredProcedure, sensitiveLoggingEnabled: boolean, detailedErrorsEnabled: boolean, comparer: IComparer<IUpdateEntry>, generateParameterName: Func<System_Internal.String>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandParameters;
    new(table: ITable, sensitiveLoggingEnabled: boolean, detailedErrorsEnabled: boolean, comparer: IComparer<IUpdateEntry>, generateParameterName: Func<System_Internal.String>, logger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandParameters;
};


export type ModificationCommandParameters = ModificationCommandParameters$instance;

export interface NonTrackedModificationCommandParameters$instance {
    get Schema(): string | undefined;
    set Schema(value: string | undefined);
    SensitiveLoggingEnabled: boolean;
    get Table(): ITable | undefined;
    set Table(value: ITable | undefined);
    TableName: string;
    Equals(obj: unknown): boolean;
    Equals(other: NonTrackedModificationCommandParameters): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NonTrackedModificationCommandParameters: {
    new(tableName: string, schemaName: string, sensitiveLoggingEnabled: boolean): NonTrackedModificationCommandParameters;
    new(table: ITable, sensitiveLoggingEnabled: boolean): NonTrackedModificationCommandParameters;
};


export type NonTrackedModificationCommandParameters = NonTrackedModificationCommandParameters$instance;

export interface AffectedCountModificationCommandBatch$instance extends ReaderModificationCommandBatch {
    Consume(reader: RelationalDataReader): void;
    ConsumeAsync(reader: RelationalDataReader, cancellationToken?: CancellationToken): Task;
    ConsumeResultSet(startCommandIndex: int, reader: RelationalDataReader): int;
    ConsumeResultSetAsync(startCommandIndex: int, reader: RelationalDataReader, cancellationToken: CancellationToken): Task<System_Internal.Int32>;
    ConsumeResultSetWithRowsAffectedOnly(commandIndex: int, reader: RelationalDataReader): int;
    ConsumeResultSetWithRowsAffectedOnlyAsync(commandIndex: int, reader: RelationalDataReader, cancellationToken: CancellationToken): Task<System_Internal.Int32>;
    ThrowAggregateUpdateConcurrencyException(reader: RelationalDataReader, commandIndex: int, expectedRowsAffected: int, rowsAffected: int): void;
    ThrowAggregateUpdateConcurrencyExceptionAsync(reader: RelationalDataReader, commandIndex: int, expectedRowsAffected: int, rowsAffected: int, cancellationToken: CancellationToken): Task;
}


export const AffectedCountModificationCommandBatch: (abstract new(dependencies: ModificationCommandBatchFactoryDependencies, maxBatchSize: Nullable<System_Internal.Int32>) => AffectedCountModificationCommandBatch) & {
};


export type AffectedCountModificationCommandBatch = AffectedCountModificationCommandBatch$instance;

export interface ColumnModification$instance {
    readonly Column: IColumnBase | undefined;
    readonly ColumnName: string;
    readonly ColumnType: string | undefined;
    readonly Entry: IUpdateEntry | undefined;
    IsCondition: boolean;
    IsKey: boolean;
    readonly IsNullable: Nullable<System_Internal.Boolean>;
    IsRead: boolean;
    IsWrite: boolean;
    readonly JsonPath: string | undefined;
    readonly OriginalParameterName: string | undefined;
    get OriginalValue(): unknown | undefined;
    set OriginalValue(value: unknown | undefined);
    readonly ParameterName: string | undefined;
    readonly Property: IProperty | undefined;
    readonly TypeMapping: RelationalTypeMapping | undefined;
    readonly UseCurrentValue: boolean;
    readonly UseCurrentValueParameter: boolean;
    readonly UseOriginalValue: boolean;
    readonly UseOriginalValueParameter: boolean;
    readonly UseParameter: boolean;
    get Value(): unknown | undefined;
    set Value(value: unknown | undefined);
    AddSharedColumnModification(modification: IColumnModification): void;
    ResetParameterNames(): void;
}


export const ColumnModification: {
    new(columnModificationParameters: ColumnModificationParameters): ColumnModification;
    GetCurrentProviderValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    GetCurrentValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    GetOriginalProviderValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    GetOriginalValue(entry: IUpdateEntry, property: IProperty): unknown | undefined;
    IsModified(entry: IUpdateEntry, property: IProperty): boolean;
    IsStoreGenerated(entry: IUpdateEntry, property: IProperty): boolean;
    SetStoreGeneratedValue(entry: IUpdateEntry, property: IProperty, value: unknown): void;
};


export interface __ColumnModification$views {
    As_IColumnModification(): IColumnModification$instance;
}

export interface ColumnModification$instance extends IColumnModification$instance {}

export type ColumnModification = ColumnModification$instance & __ColumnModification$views;


export interface EquatableKeyValue_1$instance<TKey> {
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const EquatableKeyValue_1: {
    new<TKey>(metadata: IAnnotatable, keyValue: TKey, keyComparer: IEqualityComparer<TKey>): EquatableKeyValue_1<TKey>;
};


export type EquatableKeyValue_1<TKey> = EquatableKeyValue_1$instance<TKey>;

export interface ModificationCommand$instance {
    readonly ColumnModifications: IReadOnlyList<IColumnModification>;
    EntityState: EntityState;
    readonly Entries: IReadOnlyList<IUpdateEntry>;
    get RowsAffectedColumn(): IColumnBase | undefined;
    set RowsAffectedColumn(value: IColumnBase | undefined);
    readonly Schema: string | undefined;
    readonly StoreStoredProcedure: IStoreStoredProcedure | undefined;
    readonly Table: ITable | undefined;
    readonly TableName: string;
    AddColumnModification(columnModificationParameters: ColumnModificationParameters): IColumnModification;
    AddEntry(entry: IUpdateEntry, mainEntry: boolean): void;
    AssertColumnsNotInitialized(): void;
    CreateColumnModification(columnModificationParameters: ColumnModificationParameters): IColumnModification;
    ProcessSinglePropertyJsonUpdate(parameters: ColumnModificationParameters): void;
    PropagateOutputParameters(parameterCollection: DbParameterCollection, baseParameterIndex: int): void;
    PropagateResults(relationalReader: RelationalDataReader): void;
    ToString(): string;
}


export const ModificationCommand: {
    new(modificationCommandParameters: ModificationCommandParameters): ModificationCommand;
    new(modificationCommandParameters: NonTrackedModificationCommandParameters): ModificationCommand;
};


export interface __ModificationCommand$views {
    As_IModificationCommand(): IModificationCommand$instance;
    As_INonTrackedModificationCommand(): INonTrackedModificationCommand$instance;
    As_IReadOnlyModificationCommand(): IReadOnlyModificationCommand$instance;
}

export type ModificationCommand = ModificationCommand$instance & __ModificationCommand$views;


export interface ModificationCommandBatch$instance {
    readonly AreMoreBatchesExpected: boolean;
    readonly ModificationCommands: IReadOnlyList<IReadOnlyModificationCommand>;
    readonly RequiresTransaction: boolean;
    Complete(moreBatchesExpected: boolean): void;
    Execute(connection: IRelationalConnection): void;
    ExecuteAsync(connection: IRelationalConnection, cancellationToken?: CancellationToken): Task;
    TryAddCommand(modificationCommand: IReadOnlyModificationCommand): boolean;
}


export const ModificationCommandBatch: (abstract new() => ModificationCommandBatch) & {
};


export type ModificationCommandBatch = ModificationCommandBatch$instance;

export interface ModificationCommandBatchFactoryDependencies$instance {
    CommandBuilderFactory: IRelationalCommandBuilderFactory;
    CurrentContext: ICurrentDbContext;
    Logger: IRelationalCommandDiagnosticsLogger;
    SqlGenerationHelper: ISqlGenerationHelper;
    readonly UpdateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>;
    UpdateSqlGenerator: IUpdateSqlGenerator;
    _Clone_$(): ModificationCommandBatchFactoryDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ModificationCommandBatchFactoryDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ModificationCommandBatchFactoryDependencies: {
    new(commandBuilderFactory: IRelationalCommandBuilderFactory, sqlGenerationHelper: ISqlGenerationHelper, updateSqlGenerator: IUpdateSqlGenerator, currentContext: ICurrentDbContext, logger: IRelationalCommandDiagnosticsLogger, updateLogger: IDiagnosticsLogger_1<DbLoggerCategory_Update>): ModificationCommandBatchFactoryDependencies;
};


export type ModificationCommandBatchFactoryDependencies = ModificationCommandBatchFactoryDependencies$instance;

export interface ReaderModificationCommandBatch$instance extends ModificationCommandBatch {
    readonly AreMoreBatchesExpected: boolean;
    readonly Dependencies: ModificationCommandBatchFactoryDependencies;
    readonly IsCommandTextEmpty: boolean;
    readonly MaxBatchSize: int;
    readonly ModificationCommands: IReadOnlyList<IReadOnlyModificationCommand>;
    readonly ParameterValues: Dictionary<System_Internal.String, unknown | undefined>;
    readonly RelationalCommandBuilder: IRelationalCommandBuilder;
    readonly RequiresTransaction: boolean;
    readonly ResultSetMappings: IList<ResultSetMapping>;
    readonly SqlBuilder: StringBuilder;
    get StoreCommand(): RawSqlCommand | undefined;
    set StoreCommand(value: RawSqlCommand | undefined);
    readonly UpdateSqlGenerator: IUpdateSqlGenerator;
    AddCommand(modificationCommand: IReadOnlyModificationCommand): void;
    AddParameter(columnModification: IColumnModification): void;
    AddParameters(modificationCommand: IReadOnlyModificationCommand): void;
    Complete(moreBatchesExpected: boolean): void;
    Consume(reader: RelationalDataReader): void;
    ConsumeAsync(reader: RelationalDataReader, cancellationToken?: CancellationToken): Task;
    Execute(connection: IRelationalConnection): void;
    ExecuteAsync(connection: IRelationalConnection, cancellationToken?: CancellationToken): Task;
    IsValid(): boolean;
    RollbackLastCommand(modificationCommand: IReadOnlyModificationCommand): void;
    SetRequiresTransaction(requiresTransaction: boolean): void;
    TryAddCommand(modificationCommand: IReadOnlyModificationCommand): boolean;
}


export const ReaderModificationCommandBatch: (abstract new(dependencies: ModificationCommandBatchFactoryDependencies, maxBatchSize: Nullable<System_Internal.Int32>) => ReaderModificationCommandBatch) & {
};


export type ReaderModificationCommandBatch = ReaderModificationCommandBatch$instance;

export interface SingularModificationCommandBatch$instance extends AffectedCountModificationCommandBatch {
}


export const SingularModificationCommandBatch: {
    new(dependencies: ModificationCommandBatchFactoryDependencies): SingularModificationCommandBatch;
};


export type SingularModificationCommandBatch = SingularModificationCommandBatch$instance;

export interface UpdateAndSelectSqlGenerator$instance extends UpdateSqlGenerator$instance {
    AppendBatchHeader(commandStringBuilder: StringBuilder): void;
    AppendDeleteAndSelectOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendFromClause(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    AppendIdentityWhereCondition(commandStringBuilder: StringBuilder, columnModification: IColumnModification): void;
    AppendInsertAndSelectOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    AppendRowsAffectedWhereCondition(commandStringBuilder: StringBuilder, expectedRowsAffected: int): void;
    AppendSelectAffectedCommand(commandStringBuilder: StringBuilder, name: string, schema: string, readOperations: IReadOnlyList<IColumnModification>, conditionOperations: IReadOnlyList<IColumnModification>, commandPosition: int): ResultSetMapping;
    AppendSelectAffectedCountCommand(commandStringBuilder: StringBuilder, name: string, schema: string, commandPosition: int): ResultSetMapping;
    AppendSelectCommandHeader(commandStringBuilder: StringBuilder, operations: IReadOnlyList<IColumnModification>): void;
    AppendStoredProcedureCall(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendUpdateAndSelectOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendWhereAffectedClause(commandStringBuilder: StringBuilder, operations: IReadOnlyList<IColumnModification>): void;
    GenerateNextSequenceValueOperation(name: string, schema: string): string;
    IsIdentityOperation(modification: IColumnModification): boolean;
}


export const UpdateAndSelectSqlGenerator: (abstract new(dependencies: UpdateSqlGeneratorDependencies) => UpdateAndSelectSqlGenerator) & {
};


export interface __UpdateAndSelectSqlGenerator$views {
    As_IUpdateSqlGenerator(): IUpdateSqlGenerator$instance;
}

export type UpdateAndSelectSqlGenerator = UpdateAndSelectSqlGenerator$instance & __UpdateAndSelectSqlGenerator$views;


export interface UpdateSqlGenerator$instance {
    readonly Dependencies: UpdateSqlGeneratorDependencies;
    readonly SqlGenerationHelper: ISqlGenerationHelper;
    AppendBatchHeader(commandStringBuilder: StringBuilder): void;
    AppendDeleteCommand(commandStringBuilder: StringBuilder, name: string, schema: string, readOperations: IReadOnlyList<IColumnModification>, conditionOperations: IReadOnlyList<IColumnModification>, appendReturningOneClause?: boolean): void;
    AppendDeleteCommandHeader(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendDeleteOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendDeleteReturningOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendInsertCommand(commandStringBuilder: StringBuilder, name: string, schema: string, writeOperations: IReadOnlyList<IColumnModification>, readOperations: IReadOnlyList<IColumnModification>): void;
    AppendInsertCommandHeader(commandStringBuilder: StringBuilder, name: string, schema: string, operations: IReadOnlyList<IColumnModification>): void;
    AppendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendInsertOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendInsertReturningOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    AppendObtainNextSequenceValueOperation(commandStringBuilder: StringBuilder, name: string, schema: string): void;
    AppendReturningClause(commandStringBuilder: StringBuilder, operations: IReadOnlyList<IColumnModification>, additionalValues?: string): void;
    AppendStoredProcedureCall(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendUpdateColumnValue(updateSqlGeneratorHelper: ISqlGenerationHelper, columnModification: IColumnModification, stringBuilder: StringBuilder, name: string, schema: string): void;
    AppendUpdateCommand(commandStringBuilder: StringBuilder, name: string, schema: string, writeOperations: IReadOnlyList<IColumnModification>, readOperations: IReadOnlyList<IColumnModification>, conditionOperations: IReadOnlyList<IColumnModification>, appendReturningOneClause?: boolean): void;
    AppendUpdateCommandHeader(commandStringBuilder: StringBuilder, name: string, schema: string, operations: IReadOnlyList<IColumnModification>): void;
    AppendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendUpdateOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int): ResultSetMapping;
    AppendUpdateReturningOperation(commandStringBuilder: StringBuilder, command: IReadOnlyModificationCommand, commandPosition: int, requiresTransaction: boolean): ResultSetMapping;
    AppendValues(commandStringBuilder: StringBuilder, name: string, schema: string, operations: IReadOnlyList<IColumnModification>): void;
    AppendValuesHeader(commandStringBuilder: StringBuilder, operations: IReadOnlyList<IColumnModification>): void;
    AppendWhereClause(commandStringBuilder: StringBuilder, operations: IReadOnlyList<IColumnModification>): void;
    AppendWhereCondition(commandStringBuilder: StringBuilder, columnModification: IColumnModification, useOriginalValue: boolean): void;
    GenerateNextSequenceValueOperation(name: string, schema: string): string;
    GenerateObtainNextSequenceValueOperation(name: string, schema: string): string;
    PrependEnsureAutocommit(commandStringBuilder: StringBuilder): void;
}


export const UpdateSqlGenerator: (abstract new(dependencies: UpdateSqlGeneratorDependencies) => UpdateSqlGenerator) & {
    AppendSqlLiteral(commandStringBuilder: StringBuilder, modification: IColumnModification, tableName: string, schema: string): void;
};


export interface __UpdateSqlGenerator$views {
    As_IUpdateSqlGenerator(): IUpdateSqlGenerator$instance;
}

export interface UpdateSqlGenerator$instance extends IUpdateSqlGenerator$instance {}

export type UpdateSqlGenerator = UpdateSqlGenerator$instance & __UpdateSqlGenerator$views;


export interface UpdateSqlGeneratorDependencies$instance {
    SqlGenerationHelper: ISqlGenerationHelper;
    TypeMappingSource: IRelationalTypeMappingSource;
    _Clone_$(): UpdateSqlGeneratorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: UpdateSqlGeneratorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const UpdateSqlGeneratorDependencies: {
    new(sqlGenerationHelper: ISqlGenerationHelper, typeMappingSource: IRelationalTypeMappingSource): UpdateSqlGeneratorDependencies;
};


export type UpdateSqlGeneratorDependencies = UpdateSqlGeneratorDependencies$instance;

export abstract class UpdateEntryExtensions$instance {
    static BuildCurrentValuesString(entry: IUpdateEntry, properties: IEnumerable<IPropertyBase>): string;
    static BuildOriginalValuesString(entry: IUpdateEntry, properties: IEnumerable<IPropertyBase>): string;
    static GetCurrentProviderValue(updateEntry: IUpdateEntry, property: IProperty): unknown | undefined;
    static GetOriginalProviderValue(updateEntry: IUpdateEntry, property: IProperty): unknown | undefined;
    static ToDebugString(updateEntry: IUpdateEntry, options?: ChangeTrackerDebugStringOptions, indent?: int): string;
}


export type UpdateEntryExtensions = UpdateEntryExtensions$instance;

