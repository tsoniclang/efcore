// Generated by tsbindgen - Architecture
// Namespace: Microsoft.EntityFrameworkCore.Storage.ValueConversion
// Assembly: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Relational

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IEntityType, IProperty, ITypeBase } from "../../Microsoft.EntityFrameworkCore.Metadata/internal/index.js";
import type { JsonValueReaderWriter } from "../../Microsoft.EntityFrameworkCore.Storage.Json/internal/index.js";
import * as Microsoft_EntityFrameworkCore_Storage_ValueConversion_Internal_Internal from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal/internal/index.js";
import type { StringCharConverter_2, StringDateOnlyConverter_2, StringDateTimeConverter_2, StringDateTimeOffsetConverter_2, StringEnumConverter_3, StringGuidConverter_2, StringNumberConverter_3, StringTimeOnlyConverter_2, StringTimeSpanConverter_2, StringUriConverter_2 } from "../../Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal/internal/index.js";
import type { ValueGenerator } from "../../Microsoft.EntityFrameworkCore.ValueGeneration/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { DbType } from "@tsonic/dotnet/System.Data.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DateTimeOffset, Decimal, Enum, Func, Guid, IEquatable, Int32, Int64, Nullable, Object as ClrObject, String as ClrString, TimeOnly, TimeSpan, Type, Uri, ValueType } from "@tsonic/dotnet/System.js";
import type { Expression, LambdaExpression } from "@tsonic/dotnet/System.Linq.Expressions.js";
import * as System_Net_Internal from "@tsonic/dotnet/System.Net.js";
import type { IPAddress } from "@tsonic/dotnet/System.Net.js";
import * as System_Net_NetworkInformation_Internal from "@tsonic/dotnet/System.Net.NetworkInformation.js";
import type { PhysicalAddress } from "@tsonic/dotnet/System.Net.NetworkInformation.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";

export interface IValueConverterSelector$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Storage_ValueConversion_IValueConverterSelector: never;

    Select(modelClrType: Type, providerClrType?: Type): IEnumerable<ValueConverterInfo>;
}


export type IValueConverterSelector = IValueConverterSelector$instance;

export interface ValueConverterInfo$instance {
    readonly MappingHints: ConverterMappingHints | undefined;
    readonly ModelClrType: Type;
    readonly ProviderClrType: Type;
    Create(): ValueConverter;
}


export const ValueConverterInfo: {
    new(modelClrType: Type, providerClrType: Type, factory: Func<ValueConverterInfo, ValueConverter>, mappingHints: ConverterMappingHints): ValueConverterInfo;
};


export type ValueConverterInfo = ValueConverterInfo$instance;

export interface BoolToStringConverter$instance extends BoolToTwoValuesConverter_1<System_Internal.String> {
}


export const BoolToStringConverter: {
    new(falseValue: string, trueValue: string, mappingHints: ConverterMappingHints): BoolToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type BoolToStringConverter = BoolToStringConverter$instance;

export interface BoolToTwoValuesConverter_1$instance<TProvider> extends ValueConverter_2<System_Internal.Boolean, TProvider> {
}


export const BoolToTwoValuesConverter_1: {
    new<TProvider>(falseValue: TProvider, trueValue: TProvider, fromProvider: Expression<Func<TProvider, System_Internal.Boolean>>, mappingHints: ConverterMappingHints): BoolToTwoValuesConverter_1<TProvider>;
};


export type BoolToTwoValuesConverter_1<TProvider> = BoolToTwoValuesConverter_1$instance<TProvider>;

export interface BoolToZeroOneConverter_1$instance<TProvider> extends BoolToTwoValuesConverter_1<TProvider> {
}


export const BoolToZeroOneConverter_1: {
    new<TProvider>(): BoolToZeroOneConverter_1<TProvider>;
    new<TProvider>(mappingHints: ConverterMappingHints): BoolToZeroOneConverter_1<TProvider>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type BoolToZeroOneConverter_1<TProvider> = BoolToZeroOneConverter_1$instance<TProvider>;

export interface BytesToStringConverter$instance extends ValueConverter_2<byte[], System_Internal.String> {
}


export const BytesToStringConverter: {
    new(): BytesToStringConverter;
    new(mappingHints: ConverterMappingHints): BytesToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type BytesToStringConverter = BytesToStringConverter$instance;

export interface CastingConverter_2$instance<TModel, TProvider> extends ValueConverter_2<TModel, TProvider> {
}


export const CastingConverter_2: {
    new<TModel, TProvider>(): CastingConverter_2<TModel, TProvider>;
    new<TModel, TProvider>(mappingHints: ConverterMappingHints): CastingConverter_2<TModel, TProvider>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type CastingConverter_2<TModel, TProvider> = CastingConverter_2$instance<TModel, TProvider>;

export interface CharToStringConverter$instance extends StringCharConverter_2<System_Internal.Char, System_Internal.String> {
}


export const CharToStringConverter: {
    new(): CharToStringConverter;
    new(mappingHints: ConverterMappingHints): CharToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type CharToStringConverter = CharToStringConverter$instance;

export interface CollectionToJsonStringConverter_1$instance<TElement> extends ValueConverter_2<IEnumerable<TElement>, System_Internal.String> {
    readonly JsonReaderWriter: JsonValueReaderWriter;
}


export const CollectionToJsonStringConverter_1: {
    new<TElement>(collectionJsonReaderWriter: JsonValueReaderWriter): CollectionToJsonStringConverter_1<TElement>;
};


export type CollectionToJsonStringConverter_1<TElement> = CollectionToJsonStringConverter_1$instance<TElement>;

export interface ConverterMappingHints$instance {
    readonly IsUnicode: Nullable<System_Internal.Boolean>;
    readonly Precision: Nullable<System_Internal.Int32>;
    readonly Scale: Nullable<System_Internal.Int32>;
    readonly Size: Nullable<System_Internal.Int32>;
    readonly ValueGeneratorFactory: Func<IProperty, IEntityType, ValueGenerator> | undefined;
    OverrideWith(hints: ConverterMappingHints): ConverterMappingHints;
    With(hints: ConverterMappingHints): ConverterMappingHints;
}


export const ConverterMappingHints: {
    new(size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, valueGeneratorFactory: Func<IProperty, IEntityType, ValueGenerator>): ConverterMappingHints;
};


export type ConverterMappingHints = ConverterMappingHints$instance;

export interface DateOnlyToStringConverter$instance extends StringDateOnlyConverter_2<DateOnly, System_Internal.String> {
}


export const DateOnlyToStringConverter: {
    new(): DateOnlyToStringConverter;
    new(mappingHints: ConverterMappingHints): DateOnlyToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type DateOnlyToStringConverter = DateOnlyToStringConverter$instance;

export interface DateTimeOffsetToBinaryConverter$instance extends ValueConverter_2<DateTimeOffset, System_Internal.Int64> {
}


export const DateTimeOffsetToBinaryConverter: {
    new(): DateTimeOffsetToBinaryConverter;
    new(mappingHints: ConverterMappingHints): DateTimeOffsetToBinaryConverter;
    readonly DefaultInfo: ValueConverterInfo;
    ToDateTimeOffset(v: long): DateTimeOffset;
    ToLong(v: DateTimeOffset): long;
};


export type DateTimeOffsetToBinaryConverter = DateTimeOffsetToBinaryConverter$instance;

export interface DateTimeOffsetToBytesConverter$instance extends ValueConverter_2<DateTimeOffset, byte[]> {
}


export const DateTimeOffsetToBytesConverter: {
    new(): DateTimeOffsetToBytesConverter;
    new(mappingHints: ConverterMappingHints): DateTimeOffsetToBytesConverter;
    readonly DefaultInfo: ValueConverterInfo;
    FromBytes(bytes: byte[]): DateTimeOffset;
    ToBytes(value: DateTimeOffset): byte[];
};


export type DateTimeOffsetToBytesConverter = DateTimeOffsetToBytesConverter$instance;

export interface DateTimeOffsetToStringConverter$instance extends StringDateTimeOffsetConverter_2<DateTimeOffset, System_Internal.String> {
}


export const DateTimeOffsetToStringConverter: {
    new(): DateTimeOffsetToStringConverter;
    new(mappingHints: ConverterMappingHints): DateTimeOffsetToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type DateTimeOffsetToStringConverter = DateTimeOffsetToStringConverter$instance;

export interface DateTimeToBinaryConverter$instance extends ValueConverter_2<DateTime, System_Internal.Int64> {
}


export const DateTimeToBinaryConverter: {
    new(): DateTimeToBinaryConverter;
    new(mappingHints: ConverterMappingHints): DateTimeToBinaryConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type DateTimeToBinaryConverter = DateTimeToBinaryConverter$instance;

export interface DateTimeToStringConverter$instance extends StringDateTimeConverter_2<DateTime, System_Internal.String> {
}


export const DateTimeToStringConverter: {
    new(): DateTimeToStringConverter;
    new(mappingHints: ConverterMappingHints): DateTimeToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type DateTimeToStringConverter = DateTimeToStringConverter$instance;

export interface DateTimeToTicksConverter$instance extends ValueConverter_2<DateTime, System_Internal.Int64> {
}


export const DateTimeToTicksConverter: {
    new(): DateTimeToTicksConverter;
    new(mappingHints: ConverterMappingHints): DateTimeToTicksConverter;
};


export type DateTimeToTicksConverter = DateTimeToTicksConverter$instance;

export interface EnumToNumberConverter_2$instance<TEnum extends number, TNumber extends unknown> extends ValueConverter_2<TEnum, TNumber> {
}


export const EnumToNumberConverter_2: {
    new<TEnum extends number, TNumber extends unknown>(): EnumToNumberConverter_2<TEnum, TNumber>;
    new<TEnum extends number, TNumber extends unknown>(mappingHints: ConverterMappingHints): EnumToNumberConverter_2<TEnum, TNumber>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type EnumToNumberConverter_2<TEnum extends number, TNumber> = EnumToNumberConverter_2$instance<TEnum, TNumber>;

export interface EnumToStringConverter_1$instance<TEnum extends number> extends StringEnumConverter_3<TEnum, System_Internal.String, TEnum> {
}


export const EnumToStringConverter_1: {
    new<TEnum extends number>(): EnumToStringConverter_1<TEnum>;
    new<TEnum extends number>(mappingHints: ConverterMappingHints): EnumToStringConverter_1<TEnum>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type EnumToStringConverter_1<TEnum extends number> = EnumToStringConverter_1$instance<TEnum>;

export interface GuidToBytesConverter$instance extends ValueConverter_2<Guid, byte[]> {
}


export const GuidToBytesConverter: {
    new(): GuidToBytesConverter;
    new(mappingHints: ConverterMappingHints): GuidToBytesConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type GuidToBytesConverter = GuidToBytesConverter$instance;

export interface GuidToStringConverter$instance extends StringGuidConverter_2<Guid, System_Internal.String> {
}


export const GuidToStringConverter: {
    new(): GuidToStringConverter;
    new(mappingHints: ConverterMappingHints): GuidToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type GuidToStringConverter = GuidToStringConverter$instance;

export interface IPAddressToBytesConverter$instance extends ValueConverter_2<IPAddress, byte[]> {
}


export const IPAddressToBytesConverter: {
    new(): IPAddressToBytesConverter;
    new(mappingHints: ConverterMappingHints): IPAddressToBytesConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type IPAddressToBytesConverter = IPAddressToBytesConverter$instance;

export interface IPAddressToStringConverter$instance extends ValueConverter_2<IPAddress, System_Internal.String> {
}


export const IPAddressToStringConverter: {
    new(): IPAddressToStringConverter;
    new(mappingHints: ConverterMappingHints): IPAddressToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type IPAddressToStringConverter = IPAddressToStringConverter$instance;

export interface NumberToBytesConverter_1$instance<TNumber> extends ValueConverter_2<TNumber, byte[]> {
}


export const NumberToBytesConverter_1: {
    new<TNumber>(): NumberToBytesConverter_1<TNumber>;
    new<TNumber>(mappingHints: ConverterMappingHints): NumberToBytesConverter_1<TNumber>;
    readonly DefaultInfo: ValueConverterInfo;
    BytesToDecimal<TNumber>(bytes: byte[]): decimal;
    DecimalToBytes<TNumber>(value: decimal): byte[];
    ReverseInt<TNumber>(bytes: byte[]): byte[];
    ReverseLong<TNumber>(bytes: byte[]): byte[];
    ReverseShort<TNumber>(bytes: byte[]): byte[];
    ToBytes<TNumber>(): Expression<Func<TNumber, byte[]>>;
    ToNumber<TNumber>(): Expression<Func<byte[], TNumber>>;
};


export type NumberToBytesConverter_1<TNumber> = NumberToBytesConverter_1$instance<TNumber>;

export interface NumberToStringConverter_1$instance<TNumber> extends StringNumberConverter_3<TNumber, System_Internal.String, TNumber> {
}


export const NumberToStringConverter_1: {
    new<TNumber>(): NumberToStringConverter_1<TNumber>;
    new<TNumber>(mappingHints: ConverterMappingHints): NumberToStringConverter_1<TNumber>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type NumberToStringConverter_1<TNumber> = NumberToStringConverter_1$instance<TNumber>;

export interface PhysicalAddressToBytesConverter$instance extends ValueConverter_2<PhysicalAddress, byte[]> {
}


export const PhysicalAddressToBytesConverter: {
    new(): PhysicalAddressToBytesConverter;
    new(mappingHints: ConverterMappingHints): PhysicalAddressToBytesConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type PhysicalAddressToBytesConverter = PhysicalAddressToBytesConverter$instance;

export interface PhysicalAddressToStringConverter$instance extends ValueConverter_2<PhysicalAddress, System_Internal.String> {
}


export const PhysicalAddressToStringConverter: {
    new(): PhysicalAddressToStringConverter;
    new(mappingHints: ConverterMappingHints): PhysicalAddressToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type PhysicalAddressToStringConverter = PhysicalAddressToStringConverter$instance;

export interface RelationalConverterMappingHints$instance extends ConverterMappingHints {
    readonly DbType: Nullable<DbType>;
    readonly IsFixedLength: Nullable<System_Internal.Boolean>;
    OverrideWith(hints: ConverterMappingHints): ConverterMappingHints;
    With(hints: ConverterMappingHints): ConverterMappingHints;
}


export const RelationalConverterMappingHints: {
    new(size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, fixedLength: Nullable<System_Internal.Boolean>, valueGeneratorFactory: Func<IProperty, IEntityType, ValueGenerator>, dbType: Nullable<DbType>): RelationalConverterMappingHints;
    new(size: Nullable<System_Internal.Int32>, precision: Nullable<System_Internal.Int32>, scale: Nullable<System_Internal.Int32>, unicode: Nullable<System_Internal.Boolean>, fixedLength: Nullable<System_Internal.Boolean>, valueGeneratorFactory: Func<IProperty, ITypeBase, ValueGenerator>): RelationalConverterMappingHints;
};


export type RelationalConverterMappingHints = RelationalConverterMappingHints$instance;

export interface StringToBoolConverter$instance extends ValueConverter_2<System_Internal.String, System_Internal.Boolean> {
}


export const StringToBoolConverter: {
    new(): StringToBoolConverter;
    new(mappingHints: ConverterMappingHints): StringToBoolConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToBoolConverter = StringToBoolConverter$instance;

export interface StringToBytesConverter$instance extends ValueConverter_2<System_Internal.String, byte[]> {
}


export const StringToBytesConverter: {
    new(encoding: Encoding, mappingHints: ConverterMappingHints): StringToBytesConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToBytesConverter = StringToBytesConverter$instance;

export interface StringToCharConverter$instance extends StringCharConverter_2<System_Internal.String, System_Internal.Char> {
}


export const StringToCharConverter: {
    new(): StringToCharConverter;
    new(mappingHints: ConverterMappingHints): StringToCharConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToCharConverter = StringToCharConverter$instance;

export interface StringToDateOnlyConverter$instance extends StringDateOnlyConverter_2<System_Internal.String, DateOnly> {
}


export const StringToDateOnlyConverter: {
    new(): StringToDateOnlyConverter;
    new(mappingHints: ConverterMappingHints): StringToDateOnlyConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToDateOnlyConverter = StringToDateOnlyConverter$instance;

export interface StringToDateTimeConverter$instance extends StringDateTimeConverter_2<System_Internal.String, DateTime> {
}


export const StringToDateTimeConverter: {
    new(): StringToDateTimeConverter;
    new(mappingHints: ConverterMappingHints): StringToDateTimeConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToDateTimeConverter = StringToDateTimeConverter$instance;

export interface StringToDateTimeOffsetConverter$instance extends StringDateTimeOffsetConverter_2<System_Internal.String, DateTimeOffset> {
}


export const StringToDateTimeOffsetConverter: {
    new(): StringToDateTimeOffsetConverter;
    new(mappingHints: ConverterMappingHints): StringToDateTimeOffsetConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToDateTimeOffsetConverter = StringToDateTimeOffsetConverter$instance;

export interface StringToEnumConverter_1$instance<TEnum extends number> extends StringEnumConverter_3<System_Internal.String, TEnum, TEnum> {
}


export const StringToEnumConverter_1: {
    new<TEnum extends number>(): StringToEnumConverter_1<TEnum>;
    new<TEnum extends number>(mappingHints: ConverterMappingHints): StringToEnumConverter_1<TEnum>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToEnumConverter_1<TEnum extends number> = StringToEnumConverter_1$instance<TEnum>;

export interface StringToGuidConverter$instance extends StringGuidConverter_2<System_Internal.String, Guid> {
}


export const StringToGuidConverter: {
    new(): StringToGuidConverter;
    new(mappingHints: ConverterMappingHints): StringToGuidConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToGuidConverter = StringToGuidConverter$instance;

export interface StringToNumberConverter_1$instance<TNumber> extends StringNumberConverter_3<System_Internal.String, TNumber, TNumber> {
}


export const StringToNumberConverter_1: {
    new<TNumber>(): StringToNumberConverter_1<TNumber>;
    new<TNumber>(mappingHints: ConverterMappingHints): StringToNumberConverter_1<TNumber>;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToNumberConverter_1<TNumber> = StringToNumberConverter_1$instance<TNumber>;

export interface StringToTimeOnlyConverter$instance extends StringTimeOnlyConverter_2<System_Internal.String, TimeOnly> {
}


export const StringToTimeOnlyConverter: {
    new(): StringToTimeOnlyConverter;
    new(mappingHints: ConverterMappingHints): StringToTimeOnlyConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToTimeOnlyConverter = StringToTimeOnlyConverter$instance;

export interface StringToTimeSpanConverter$instance extends StringTimeSpanConverter_2<System_Internal.String, TimeSpan> {
}


export const StringToTimeSpanConverter: {
    new(): StringToTimeSpanConverter;
    new(mappingHints: ConverterMappingHints): StringToTimeSpanConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToTimeSpanConverter = StringToTimeSpanConverter$instance;

export interface StringToUriConverter$instance extends StringUriConverter_2<System_Internal.String, Uri> {
}


export const StringToUriConverter: {
    new(): StringToUriConverter;
    new(mappingHints: ConverterMappingHints): StringToUriConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type StringToUriConverter = StringToUriConverter$instance;

export interface TimeOnlyToStringConverter$instance extends StringTimeOnlyConverter_2<TimeOnly, System_Internal.String> {
}


export const TimeOnlyToStringConverter: {
    new(): TimeOnlyToStringConverter;
    new(mappingHints: ConverterMappingHints): TimeOnlyToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type TimeOnlyToStringConverter = TimeOnlyToStringConverter$instance;

export interface TimeOnlyToTicksConverter$instance extends ValueConverter_2<TimeOnly, System_Internal.Int64> {
}


export const TimeOnlyToTicksConverter: {
    new(): TimeOnlyToTicksConverter;
    new(mappingHints: ConverterMappingHints): TimeOnlyToTicksConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type TimeOnlyToTicksConverter = TimeOnlyToTicksConverter$instance;

export interface TimeSpanToStringConverter$instance extends StringTimeSpanConverter_2<TimeSpan, System_Internal.String> {
}


export const TimeSpanToStringConverter: {
    new(): TimeSpanToStringConverter;
    new(mappingHints: ConverterMappingHints): TimeSpanToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type TimeSpanToStringConverter = TimeSpanToStringConverter$instance;

export interface TimeSpanToTicksConverter$instance extends ValueConverter_2<TimeSpan, System_Internal.Int64> {
}


export const TimeSpanToTicksConverter: {
    new(): TimeSpanToTicksConverter;
    new(mappingHints: ConverterMappingHints): TimeSpanToTicksConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type TimeSpanToTicksConverter = TimeSpanToTicksConverter$instance;

export interface UriToStringConverter$instance extends StringUriConverter_2<Uri, System_Internal.String> {
}


export const UriToStringConverter: {
    new(): UriToStringConverter;
    new(mappingHints: ConverterMappingHints): UriToStringConverter;
    readonly DefaultInfo: ValueConverterInfo;
};


export type UriToStringConverter = UriToStringConverter$instance;

export interface ValueConverter$instance {
    readonly ConstructorExpression: Expression;
    readonly ConvertFromProvider: Func<unknown | undefined, unknown | undefined>;
    readonly ConvertFromProviderExpression: Expression_1<Func_2<TProvider, TModel>> | LambdaExpression;
    readonly ConvertsNulls: boolean;
    readonly ConvertToProvider: Func<unknown | undefined, unknown | undefined>;
    readonly ConvertToProviderExpression: Expression_1<Func_2<TModel, TProvider>> | LambdaExpression;
    readonly MappingHints: ConverterMappingHints | undefined;
    readonly ModelClrType: Type;
    readonly ProviderClrType: Type;
    ComposeWith(secondConverter: ValueConverter): ValueConverter;
}


export const ValueConverter: (abstract new(convertToProviderExpression: LambdaExpression, convertFromProviderExpression: LambdaExpression, mappingHints: ConverterMappingHints) => ValueConverter) & (abstract new(convertToProviderExpression: LambdaExpression, convertFromProviderExpression: LambdaExpression, convertsNulls: boolean, mappingHints: ConverterMappingHints) => ValueConverter) & {
    CheckTypeSupported(type: Type, converterType: Type, ...supportedTypes: Type[]): Type;
};


export type ValueConverter = ValueConverter$instance;

export interface ValueConverter_2$instance<TModel, TProvider> extends ValueConverter {
    readonly ConstructorExpression: Expression;
    readonly ConvertFromProvider: Func<unknown | undefined, unknown | undefined>;
    readonly ConvertFromProviderExpression: Expression_1<Func_2<TProvider, TModel>> | LambdaExpression;
    readonly ConvertFromProviderTyped: Func<TProvider, TModel>;
    readonly ConvertToProvider: Func<unknown | undefined, unknown | undefined>;
    readonly ConvertToProviderExpression: Expression_1<Func_2<TModel, TProvider>> | LambdaExpression;
    readonly ConvertToProviderTyped: Func<TModel, TProvider>;
    readonly ModelClrType: Type;
    readonly ProviderClrType: Type;
}


export const ValueConverter_2: {
    new<TModel, TProvider>(convertToProviderExpression: Expression<Func<TModel, TProvider>>, convertFromProviderExpression: Expression<Func<TProvider, TModel>>, mappingHints: ConverterMappingHints): ValueConverter_2<TModel, TProvider>;
    new<TModel, TProvider>(convertToProviderExpression: Expression<Func<TModel, TProvider>>, convertFromProviderExpression: Expression<Func<TProvider, TModel>>, convertsNulls: boolean, mappingHints: ConverterMappingHints): ValueConverter_2<TModel, TProvider>;
};


export type ValueConverter_2<TModel, TProvider> = ValueConverter_2$instance<TModel, TProvider>;

export interface ValueConverterSelector$instance {
    readonly __tsonic_iface_Microsoft_EntityFrameworkCore_Storage_ValueConversion_IValueConverterSelector: never;

    readonly Dependencies: ValueConverterSelectorDependencies;
    Select(modelClrType: Type, providerClrType?: Type): IEnumerable<ValueConverterInfo>;
}


export const ValueConverterSelector: {
    new(dependencies: ValueConverterSelectorDependencies): ValueConverterSelector;
};


export interface __ValueConverterSelector$views {
    As_IValueConverterSelector(): IValueConverterSelector$instance;
}

export interface ValueConverterSelector$instance extends IValueConverterSelector$instance {}

export type ValueConverterSelector = ValueConverterSelector$instance & __ValueConverterSelector$views;


export interface ValueConverterSelectorDependencies$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    _Clone_$(): ValueConverterSelectorDependencies;
    Equals(obj: unknown): boolean;
    Equals(other: ValueConverterSelectorDependencies): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueConverterSelectorDependencies: {
    new(): ValueConverterSelectorDependencies;
};


export type ValueConverterSelectorDependencies = ValueConverterSelectorDependencies$instance;

